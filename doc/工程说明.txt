本工程使用芯片为STM32F10x系列.
各个子目录的说明在各个目录之下.

程序版本:0.04
编写人员: 
编写日期:2012-5-15
编写记录:
1.	将Typedef_struLinePrtBuf定义中下划线缓存与打印内容缓冲区合并,
	最后PRT_DOT_NUMBERS个字节作为下划线使用,前面字节作为打印内容.
2.	当前程序暂不考虑处理下划线,也处理不打印下划线,留待以后完善.


编写人员: 
编写日期:2012-5-16
编写记录:
1.	其中的指令文件是当前没有起用.


程序版本:0.05
编写人员: 
编写日期:2012-5-16
1.	从此版本开始逐步添加P04的具体功能.
2.	编写DEBUG版本头文件和C文件.
3.	编写feedpaper头文件和C文件.完成正常延时按键上纸程序处理.
	目前上纸程序中没有处理衰减方式,初始化时为混合衰减.目前程序
	中定义的时间和参数都是按照一步一点行驱动方式设置的.
4.	添加cutter头文件和C文件.未完成.


程序版本:0.06
编写人员: 
编写日期:2012-5-17
1.	cutter驱动已写完.目前的延时程序使用DelayUs().有待调试.
	以后用定时器实现延时.并添加切刀状态全局变量的处理.
2.	添加heat驱动.已完成.目前的延时程序使用DelayUs().有待调试.
3.	添加led驱动.已完成.


程序版本:0.07
编写人员: 
编写日期:2012-5-28
1.	指令文件全部使用POS886.
2.	添加defcontant.h,gvar.h,extgvar.h三个头文件.
3.	添加esc.h文件,添加esc函数声明.
4.	修改Command_1B75()函数.该指令需要查找命令定义进行修改.
5.	修改esc.c中函数,暂时不处理二维条码和钱箱相关函数
	PrintBarCode_2D(),ProcessBarCode_2D(),Command_1014fnmt(),
	Command_1B70(),Command_1B75(),Command_1B5A()这些函数.编译通过.
6.	修改monobyte.c中函数.添加appgpio.h文件.编译通过.
7.	修改fs.c中函数.编译通过.
8.	添加codebar.c及头文件.编译通过.
9.	修改gs.c中函数.编译通过.
10.	将selftest.c中的变量添加到gvar.h中.
11.	temp.c中的函数有待以后实现.


程序版本:0.08
编写人员: 
编写日期:2012-5-28
1.	修改文件放置方式.将所有驱动部分的程序放到同一个目录drive下.
2.	添加setcommand.c文件.编译通过.
3.	添加字库SPI驱动文件spiflash.c.编译通过.机芯使用的SPI单独编程.
4.	添加机芯SPI驱动文件spiheat.c.编译通过.SPI相关的DMA及中断均未设置.


程序版本:0.09
编写人员: 
编写日期:2012-5-29
1.	添加ADC相关的程序.编写adc.c文件.编译通过.错误结构值定义需要整理.


程序版本:0.10
编写人员: 
编写日期:2012-5-29
1.	编写字符处理程序.charprocess.c文件.
2.	接收缓存数据结构重定义,并修改其中成员名称,修改缓存数据结构变量名称.
	修改相关函数名称.编译通过.
3.	添加串口相关函数.usart.c文件.编译通过.
4.	添加中断处理文件.添加串口通信中断.有待日后调试完善.编译通过.


程序版本:0.11
编写人员: 
编写日期:2012-5-29
1.	根据最新布完的PCBA实际使用管脚更新各个驱动.全部检查完毕.
2.	SPI_Heat还需要添加DMA相关程序.


程序版本:0.12
编写人员: 
编写日期:2012-5-30
1.	添加字符变化处理程序.charprocess.c中函数有待修改.


程序版本:0.13
编写人员: 
编写日期:2012-5-30
1.	修改stm32f10x_conf.h文件,注释掉不需要的功能的头文件.打开USE_FULL_ASSERT功能.
2.	修改了usart.c和spiheat.c管脚初始化时钟时候的错误.
3.	打开USE_FULL_ASSERT功能后stm32f10x_usart.c库文件编译通不过.在normal.c中添加
	assert_failed()函数后通过.
4.	添加selftest.c和hexmode.c文件.


程序版本:0.14
编写人员: 
编写日期:2012-5-31
1.	继续selftest.c实现.
2.	添加init.c文件.处理初始化部分.
3.	完善了读写内部FLASH,外部SPI,切刀驱动等程序.
4.	编译通过.


程序版本:0.15
编写人员: 
编写日期:2012-6-1
1.	按照高速POS打印流程修改程序流程.修改charmaskbuf.c文件.
2.	修改DataProcess()函数.PrintChar()待修改.
3.	PrintChar()调用PrintAscII(),JudgePrintSelfDefChinese(),JudgePrintBIG5(),
	JudgePrintGB18030()四个函数.这四个函数需要修改.
4.	修改PrintAscII().GetAscIIDotData(),FillPrint().
5.	修改PrintUserHZ(),PrintGB18030(),PrintBIG5().有待处理启动SPI DMA内容.
6.	FillPrint()还未修改.
7.	CHAR_MASK_READ_BUF_STATUS_ILDE的程序处理完毕.
8.	charprocess.c文件中内容合并到charmaskbuf.c中,不再保留charprocess.c文件.
9.	有待添加SPI1 DMA相关的程序.


程序版本:0.16
编写人员: 
编写日期:2012-6-4
1.	添加机芯SPI DMA部分程序.
2.	添加TIM2,3,4,5初始化及设置程序.
3.	添加中断设置.
4.	更新初始化程序.
5.	用sFLASH_ReadBuffer()替代SPI_FLASH_BufferRead().
	字库字模读取采用正常等待程序.暂不使用DMA方式.
6.	更新charmaskbuf.c并添加新函数.读取字符字模及编辑行打印缓冲区基本程序已编译通过.
	还需要进一步修改.


程序版本:0.17
编写人员: 
编写日期:2012-6-5
1.	修改行打印缓冲区处理程序.重新调整行打印缓冲区处理流程,流程基本完成.
	点行数据横向转换及启动DMA发送还未实现.


程序版本:0.18
编写人员: 
编写日期:2012-6-6
1.	修改行打印缓冲区处理程序.实现打印数据点行数据横向转换及启动DMA发送.
	正向打印数据横向转换完成,反向打印数据横向转换未完成
2.	修改Command_1D57()函数.


程序版本:0.19
编写人员: 
编写日期:2012-6-7
1.	修改行打印缓冲区处理程序.注意填充行打印缓冲区时,当一行满后,
	需要重新初始化某些打印控制全局变量.
2.	修改行打印缓冲区处理程序完成.当前除了计算加热时间、走电机时间部分外都已完成.
	目前的程序没有处理上划线或者下划线的打印.已定义和保留下划线的存储地址.
	将来调试看打印程序工作正常后再添加处理下划线.


程序版本:0.20
编写人员: 
编写日期:2012-6-7
1.	修改初始化init.c程序.添加行打印缓冲区A,B的初始化.
	添加行横向转换结果加热缓冲区初始化.
	添加编辑和打印全局标志变量初始化.
	添加加热控制结构变量初始化.
2.	添加打印完一行后重新初始化该行的操作.
3.	在编辑一行开始时需要对关于打印一行的控制变量进行从公共变量中初始化.
4.	修改字符点阵缓冲区空闲状态判断.添加需要有可用或正在使用的行打印缓冲区时才处理
	通信接收缓冲区的判断以确保行打印时需要的设置不会被丢失.
5.	添加加热次数判断.


程序版本:0.21
编写人员: 
编写日期:2012-6-21
添加部件测试部分的程序.
1.	添加部件测试部分的程序.添加TIMx的测试程序.添加stm32f10x_it.h中所有可能能用到的中断声明.
2.	添加TIMx的测试中断处理程序.
3.	修改button检测方式,改为通过外部中断和查询两种.默认为通过中断方式.修改button端口初始化程序.
4.	修改InitNVIC(),添加按键EXTI中断优先级定义.
5.	添加EXTI15_10中断函数.添加以太网按键定义gstructResetEthButton.
6.	KeyCtrlStruct变量修改为gstructFeedButton.
	原上纸按键中成员变量KeyOe,FeedStus,FeedCount涉及到的程序全部修改为统一按键定义.
	修改按键变量初始化程序,添加gstructResetEthButton初始化.
7.	添加BUTTON测试处理程序完毕.
8.	添加UART4测试处理程序完毕.修改串口中断.在测试时原样发回接收到的数据.
9.	修改USART_Config(),添加测试程序.


程序版本:0.22
编写人员: 
编写日期:2012-6-26
添加部件测试部分的程序.
1.	添加测试ADC部分的程序.各路检测方法相同.将测量结果以mv为基准的数的各位值转换为ASCII码,
	在ADC的DMA中断处理函数中通过串口发送到PC.
2.	将USART_Config()函数中默认设置为串口调试DBG_USART和ADC调试DBG_ADC时相同.
3.	添加测试上纸电机控制程序.添加ErrorDetect()函数,该函数有待以后需要.


程序版本:0.23
编写人员: 
编写日期:2012-6-27
修改上纸电机控制部分的程序.
1.	添加加热输出电压控制测试程序.


程序版本:0.24
编写人员: 
编写日期:2012-6-28
测试程序.
1.	使用JLINK测试TIM2,定时器设置预分频延时10us,自动重载计数值100,中断中计数1000及10000次,
	测试延时1s及10s,通过LED指示灯显示正常.
2.	测试TIM3,定时器设置预分频延时1us,自动重载计数值1000,中断中计数1000及10000次,
	测试延时1s及10s,通过LED指示灯显示正常.
3.	测试TIM4,定时器设置预分频延时1us,自动重载计数值1000,中断中计数1000及10000次,
	测试延时1s及10s,通过LED指示灯显示正常.
4.	测试TIM5,定时器设置预分频延时0.001us,自动重载计数值1000,中断中计数1000及10000次,
	测试延时1s,实际测试定时延时时间很长.
	将定时器设置预分频延时1000us,自动重载计数值1,测试1s延时,实际测试结果为延时2s.
	将定时器设置预分频延时100us,自动重载计数值10,测试1s延时,实际测试结果为延时10s.
	将定时器设置预分频延时1us,自动重载计数值1000,测试1s延时,实际测试结果正常.
	原因是TimerConfigPrescaler()函数中设置预分频系数固定为1,此时如果预分频设置值大于系统时钟,
	则相除时得到的值小于1,与1相减后为负数,结果溢出.
	重新修改该函数,测试与预期不符.将其设置为固定不超过3.6us定时工作正常.使用时需要注意.
5.	测试FEED按键,通过中断检测,无反应.ETH_RST按键悬空未焊接,一种重复进入中断.
	将按键检测由EXTI改为查询模式,测试上纸按键工作正常.
	还有待检查按键EXTI中断工作不正常的原因.
6.	测试软件控制加热电压输出工作正常.每个↑导通,然后经过硬件决定的时间后自动关断输出.
7.	添加切纸测试程序.
8.	测试USART,PC端发送,MCU中断接收后原值回传.测试正常.
9.	测试ADC.添加InitADCPort()函数及各个分部件ADC管脚的单独初始化的函数.
	修改ADC测试程序,初始化TIM5作为系统时标启动ADC.TIM5中断中开启ADC,DMA1_ADC中断中关闭ADC.
	测试POWER_IN测量结果基本正常.但是通过串口上传数据不正常.
	将测量转换的电压值与实际使用电压比较,通过LED指示,发现测量很准确.
10.	


程序版本:0.25
编写人员: 
编写日期:2012-6-29
测试程序.
1.	修改FEEDPAPER控制管脚对应MCU管脚号,互换上纸方向控制,修改StepFeedMotor()中的错误,测试上纸功能.
	默认一直允许SR,衰减模式使用混合衰减,全步驱动方式,一步一点行.R/C参数为2K/0.01uF.
	电机最高电流设置为500mA时测试高速上纸,最高速度达到最大值220mm/s,电机部分耗电直流电流稳定在450mA左右.
2.	将电机最高电流设置为250mA时测试高速上纸,最高速度达到最大值220mm/s,电机部分耗电直流电流稳定在450mA左右.
3.	默认一直允许SR,衰减模式使用混合衰减,全步驱动方式,一步一点行.R/C参数为20K/0.0022uF.
	将电机最高电流设置为250mA时测试高速上纸,电机啸叫,不走纸,电机部分耗电直流电流稳定在50mA左右.
4.	将电机最高电流设置为500mA时测试高速上纸,上纸前半部分上纸正常,电机部分耗电直流电流稳定在300mA左右,
	后半部分上纸被憋住,电机啸叫,电机部分耗电直流电流稳定在200mA左右.
5.	默认一直允许SR,衰减模式使用混合衰减,全步驱动方式,一步一点行.R/C参数为10K/0.0044uF.
	将电机最高电流设置为500mA时测试高速上纸,上纸正常,电机部分耗电直流电流稳定在320mA左右,最高速度220mm/S.
	多次上纸测试,大部分时候正常.有时出现下半部分憋住的情况,此时电机电流约200mA.
6.	目前最终选择R/C参数为2K/0.01uF,电机最高电流设置为500mA.
7.	测试高速上纸和恒速单步上纸均正常.
8.	按照实际PCB修改CUT管脚定义.
9.	测试切刀.切刀工作不正常,正常切纸1次,其他时候出现错误.
10.	修改切刀信号指示是否在HOME位置的宏定义值,切纸工作正常.连续切完半卷纸全部正常.切纸效果良好.


程序版本:0.26
编写人员: 
编写日期:2012-6-29
编写测试程序.
1.	修改某些变量名称定义,并更新程序中对应处内容.
2.	编写字库SPI读取测试,包括环境变量初始化,接收到的字符根据不同环境解析,
	读取字库中对应字符的点阵数据,读取完毕发送到PC.
3.	修改ReadInBuffer()函数.处理缓冲区空,驱动打印模式,宏定义模式的情况.未处理曲线打印模式.
4.	添加ReceiveInterrupt()函数.
5.	添加端口检测.
6.	添加InitInterfaceParameter()函数.并添加到InitParameter().
7.	修改InitStdPeriph(),添加端口检测.
8.	PrintBIG5(),PrintGB18030(),GetAscIIFlashDotData()中添加读取结束将结果上传到PC的条件编译内容.
	只测试从FLASH中读取的内容.
9.	测试字库读取时默认系统语言为ENGLISH,其他时候默认为CHINESE.修改宏定义.



程序版本:0.27
编写人员: 
编写日期:2012-6-30
编写测试程序.
1.	SPI读写测试不正常.
2.	测试USART中断接收,即时查询发送正常.
3.	测试USART中断接收放入接收缓冲区,查询方式发送接收缓冲区.大批量发送无丢码,误码.
	表明串口中断接收及INBUF接收,读取等相关程序工作正常.
4.	修改测试字库SPI程序,根据按键读取字库指定起始地址处内容发送到PC.回传结果与预期不符.
5.	修改字库SPI测试程序,调试发现擦除,写入,读出均正常.
	单个字节的读取或者是缓冲区读取及单个字节发送及缓冲区发送单步执行时都正常,但是批量发送时PC接收丢数.
6.	将批量发送的程序前后均添加延时,无丢数.
7.	修改UpLoadData(),串口发送时每发送一个字节后添加延时10us,还出现丢数.延时1000us,无丢数.延时100us,无丢数.
6.	测试读取字库SPI,批量发送时接收无丢数,工作正常.
7.	测试中断接收处理,读数处理,字符命令解析处理,字库内容读取,上传均正常.
8.	FillLinePrintBuf()函数修改修改.
	FillPrintBuff()函数需要进行修改.原填充PrtDataBuf,需要改为读取编辑的行打印缓冲区.
	FillDataPrintBuff()函数修改修改.
9.	修改FillLinePrintBuf()定义,添加参数指向当前填充的行打印缓冲区的指针pstructLinePrtBuf,
	修改FillPrintBuff()定义,添加参数指向当前填充的行打印缓冲区的指针pstructLinePrtBuf,
	修改FillDataPrintBuff()定义,添加参数指向当前填充的行打印缓冲区的指针pstructLinePrtBuf.
	修改FillPrint()定义,添加参数指向当前填充的行打印缓冲区的指针pstructLinePrtBuf.
	并修改对应调用程序处.
10.	修改FillPrintBuff()函数.


程序版本:0.28
编写人员: 
编写日期:2012-6-30
按照新的处理流程处理行打印缓冲区的编辑和打印.
1.	修改行打印缓冲区编辑部分的程序charmaskbuf.c中程序.
2.	修改FillLinePrintBuf(),不需要选择编辑缓冲区,改变处理判断条件.
3.	修改JudgeLineBufFull(),不需要指针参数.
4.	修改FillLinePrintBuf(),不需要指针参数.
5.	修改FillPrintBuff(),不需要指针参数.
6.	修改FillDataPrintBuff(),不需要指针参数.
7.	修改FillPrint(),不需要指针参数.
8.	修改以上函数设计的部分.
9.	添加gPrtDataBufStatus变量.
10.	行打印缓冲区编辑部分的程序已经修改完毕.


程序版本:0.29
编写人员: 
编写日期:2012-7-3
按照新的处理流程处理行打印缓冲区的打印处理程序部分.
1.	修改print.c中程序.原有两个打印缓冲区,现在只处理唯一一个.去掉相关的打印缓冲区选择修改程序.
2.	修改ProcessLinePrintBuffer()函数.
3.	修改InitLinePrtBuf(),InitParameter(),GetLinePrtBufStartColumnIndex(),FillHeatElementBuf(),
	LineBufToHeatElementNormalDir(),LineBufToHeatElementReverseDir(),WaitToPrintLineBuf(),
	StartPrintLineBuf(),StartHeat(),SetGoLineSpace(),PrintLineBuffer(),
	去掉所有与两个打印缓冲区选择相关的程序.


程序版本:0.30
编写人员: 
编写日期:2012-7-18
按照新的处理流程处理行打印缓冲区的打印处理程序部分.
1.	修改Print.c中指针定义,定义时全部初始化为NULL.
2.	修改LineBufToHeatElementNormalDir(),修改最后赋值到横向加热缓冲区部分的程序.
3.	修改LineBufToHeatElementReverseDir(),修改最后赋值到横向加热缓冲区部分的程序.
4.	添加加热控制函数EndHeat().
5.	修改ErrorDetect(),添加处理关闭加热,走纸,切刀,及其控制定时器.
6.	修改StartHeat(),添加提前计算加热时间的处理.充分利用空闲时间.
7.	控制打印的定时器定时值可以灵活设置,在每一步完成后由相应程序设置并开/关定时器.
	这些部分还没有添加.


程序版本:0.31
编写人员: 
编写日期:2012-7-18
测试机芯SPI总线DMA方式发送一点行缓冲区数据部分的程序.
1.	修改sHeat_DMAInit(),sHeat_StartDMATx(),使用print.h中的宏定义.
2.	main()中关闭JTAG,但是使能SWJ.
3.	修改DMA2_Channel2_IRQHandler(),添加SPI_HEAT测试程序.
4.	测试程序编写完毕,等待测试.


程序版本:0.32
编写人员: 
编写日期:2012-7-31
1.	测试SPI DMA发送.
	测试发现一直没有进入DMA中断.调试发现将SPI3_CR2寄存器的TXDMAEN设置后,即可进入DMA中断.
2.	修改sHeat_Init(),添加TXDMAEN的设置.
	修改后SPI3 DMA中断测试正常.
3.	添加systimfunc.c文件,处理定时器中断函数.
	TIM2作为系统时标,周期性启动ADC,检查某些参数等;
	TIM3控制加热和走电机;
	TIM4控制打印进程;
	TIM5备用.
4.	修改InitStdPeriph(),重设置各个定时器预分频值.使用宏定义.
5.	修改Init(),设置定时器定时值.并启动定时器.
6.	编写SystemTimer2Func(),处理系统周期性工作.
7.	编写打印测试程序.检测系统状态,进入正常流程,未完成.


程序版本:0.33
编写人员: 
编写日期:2012-8-1
1.	修改GetConfigData(),将COMPANY_FLAG宏定义直接改为字符串类型.
	将所有"Spirit"赋值的地方改为"WHKJ".
2.	修改UART4_IRQHandler(),正常功能处理中添加入回传处理.在产品调试阶段一直存在.
3.	启用TIM2程序,将ADC_CONVERT_NUMBER由5改为4.
3.	FillPrintBuff()处理错误,待修改.
	FillDataPrintBuff()处理错误,待修改.
4.	修改JudgeLineBufFull(),最后只返回是否满行,不处理PrtCtrlData.PrtDataDotIndex.
5.	使用PrtDataBuf[]作为填充区.
6.	修改FillLinePrintBuf()中汉字高度赋值参数错误.
	修改TypeDef_StructPrintMode定义,添加变量CharHigh.
7.	修改FillPrintBuff(),修改指针首地址定义,原定义错误.
	PrtCtrlData.LineHigh标志一行中最高字符,经过*纵向放大倍数处理.
	字符放大缓冲区使用前先清空.
8.	修改FillDataPrintBuff(),修改指针首地址定义,原程序错误.处理输入参数防止下标越界.
9.	添加初始化gPrtDataBufStatus,PrtDataBuf,UnderlineBuf.
10.	字符和汉字解码及读取字模,填充行打印缓冲区,判断是否满行等编辑行打印缓冲区处理测试通过.
11.	添加ADC初始化及DMA设置.启动TIM2启动ADC测试通过.


程序版本:0.34
编写人员: 
编写日期:2012-8-1
1.	修改ProcessCharMaskReadBuf(),当编辑过程中一行满后,
	添加赋值当前设置的打印控制变量,并启动打印加热控制定时器.
2.	TypeDef_StructPrtCtrl添加BitImageFlag成员.标志位图打印模式.
3.	添加新函数SetLinePrtModeVariable(),
	在一个行打印缓冲区满后,赋值打印控制变量到行打印缓冲区控制结构.
4.	添加新函数CopyPrtDataToLineSturct()将PrtDataBuf中数据及控制变量赋值到控制结构.
5.	添加新函数PrepareNewLine()清空PrtDataBuf及下划线等控制变量准备下一行编辑.
6.	修改ProcessCharMaskReadBuf(),满行后启动打印进程.
7.	修改WaitToPrintLineBuf(),处理完毕设置定时器定时值1,进入下一步骤.
8.	修改StartPrintLineBuf(),进入后关闭PRINT_CHECK_TIMER.
9.	修改DMA2_Channel2_IRQHandler(),传输完毕,设置PRINT_CHECK_TIMER并启动,
	修改gstruLinePrtBuf.Status标志为传输结束.
10.	启用SystemTimer4Func()用来处理打印进程.
11.	修改StartHeat(),进入后先关闭PRINT_CHECK_TIMER.
	在不同的条件下分别设置延时时间和启动定时器.
12.	修改SetGoLineSpace(),进入后关闭PRINT_CHECK_TIMER.
13.	基本打印流程处理完毕.
	需要添加计算加热时间及调整电机延时处理.
	需要添加定时器控制加热和走电机处理程序.
14.	测试程序流程正常.


程序版本:0.35
编写人员: 
编写日期:2012-8-2
1.	添加不同情况下加速最高步数的宏定义.低温,动态加热,驱动打印.
2.	添加LTPF347机芯加热时间计算相关的程序.相关程序放到heat.c中.
	添加gStepCount,gHeatUs全局变量.
	添加计算温度,计算电压,计算加热时间的函数.
	计算方法按照说明书中参数进行.
3.	编写测试程序.
4.	调试发现温度计算值错误.ADC转换不准确,数字乱变.
5.	4.54版本不支持JLINK V8.改用4.53版本.


程序版本:0.36
编写人员: 
编写日期:2012-8-2
1.	检查ADC相关程序.
	ADC初始化时没有设置ADC时钟分频.设置后程序转换正常.
	ADC转换结果不稳定,误差较大.	
2.	采样频率由原ADC_SampleTime_239Cycles5改为ADC_SampleTime_1Cycles5,测得值比真值小.
	改为ADC_SampleTime_7Cycles5,测得值比真值稍小.
	改为ADC_SampleTime_13Cycles5,测得值与真值相同.
3.	其他参数不变,测试发现加热时间参数计算非常稳定精确.
4.	编写TIM3控制加热和走纸中断控制程序.
	调用者必须设置定时值,自动重载定时值,启动定时器,可选设置HeatEn或者StepNumber.
5.	添加标志电机运行的控制变量MotorMoveCntr,MotorRunFlag等到gvar.h.
6.	修改电机起始,停止,断开,步进函数为全局函数.
7.	修改StepFeedMotor(),加入标志加速步数的
8.	StartHeat()函数改名为StartHeatAndRotateMotor().
	添加赋值加热时间gHeatUs.
	添加计算本点行加热次数,设置加热控制管脚.
9.	添加StartHeat(),处理加热.
10.	添加SetHeatNumber(),统计加热次数,设置控制数组值.
11.	添加AdjustMotorStep(),GetMaxAccelerateSteps(),处理调整电机步数.
12.	添加模拟调试打印宏定义DBG_DUMMY_PRT,
	将加热和走电机部分函数设置成条件编译便于实际调试.
13.	程序流程有待调试.目前还没有处理关闭走纸电机.


程序版本:0.37
编写人员: 
编写日期:2012-8-3
1.	测试打印流程.
2.	修改调用AdjustMotorStep()时赋值错误.
3.	将定时器2,3,4,5,DMA1,DMA2,UART4的中断状态标志位全部由原来放到最后清除改为放到开始清除.
4.	添加GoDotLine(),通过中断设置走纸.
5.	暂时禁用ErrorDetect().
6.	测试GoDotLine().
7.	暂时使用SystemCtrlStruct变量进行程序编写,不使用gstruSystemCtrl.
	将gstruSystemCtrl编写的程序的地方改用SystemCtrlStruct.
8.	将变量HeatCtrlStruct改为gstructHeatCtrl,并修改程序中对应处.
9.	修改ProcessMotor(),电机走完结束时需要添加结束擎住处理.
10.	测试中断设置走纸通过.
11.	将定时器3中断标志位清除放到最后.否则调试过程中发现停止定时器后还会再次进入一次中断.
	可能是在调试中定时时间已经到达导致.


程序版本:0.38
编写人员: 
编写日期:2012-8-3
1.	测试打印流程.
	发送内容可以打印,但是打印内容空白.
2.	优化FillPrintBuff(),复制时先判断纵向放大倍数,如果不为1才执行放大处理.
3.	修改SetHeatNumber()错误,一次加热时两个管脚同时打开.
4.	修改LineBufToHeatElementNormalDir(),调试用,横向转换机芯数据一律赋值10101010.
5.	以9600BPS发送,出现丢数.因为需要回传,所以会影响接收.
	修改UpLoadData(),将其中的延时100us去掉.115200时不会丢数.
6.	固定设置加热数据,打印结果为空白.估计问题是数据没有发送到机芯中.
7.	编写测试程序,测试加热信号控制是否正确.
	检查电路焊接的电阻值10K过大,改为1K以下值,否则会影响电平正确值.
8.	另外发现打印过程中会出现死机,再发送其他数据时不会执行打印,无反应.


程序版本:0.39
编写人员: 
编写日期:2012-8-3
1.	当发送数据较多时出现死机,再发送其他数据时不会执行打印,无反应.
	调试此时gPrtDataBufStatus为等待打印状态,而没有程序启动打印导致程序一直循环等待.
2.	修改ProcessCharMaskReadBuf(),添加启动打印处理.
	修改后还会出现死机现象,调试发现gPrtDataBufStatus一直没有处于空闲状态.
	留待以后修改.
3.	修改StartPrintLineBuf(),将机芯数据发送改为查询方式SPI_HeatSendByte().
	依然打印空白.检测SPI3信号线,SPI3_MOSI信号一直为低.
4.	修改硬件连接,将机芯输出接到SPI3_MISO.
	修改SPI_HeatSendByte(),发送同时返回.
	修改机芯初始化,添加SPI_MISO.
	修改StartPrintLineBuf(),发送同时接收.


程序版本:0.40
编写人员: 
编写日期:2012-8-13
1.	修改sHeat_Init(),添加使能SPI_CR2_TXDMAEN.打印依然为空白.
2.	修改SPI_HeatSendByte(),显式接收返回值,
	通过测试程序发现查询发送发送一个字节,同时接收一个字节数据正确.
3.	测试加热控制管脚,控制正常,输出高为3.0V,输出低为0V.不使用电平转接口芯片.


编写日期:2012-8-14
4.	改用电平转换芯片,依然打印空白.
5.	检查程序发现加热时没有打开软件控制加热电压操作.
	添加后依然打印空白.测量加热电压基本保持为低.
6.	调试发现机芯SPI返回值恒为0.
7.	通过使用示波器及编写测试程序,发现软件加电控制,加热控制DST1,2.锁存信号控制,
	SPI3_CLK均表现正常.但是SPI3_MOSI和MISO一直为0.


程序版本:0.41
编写人员: 
编写日期:2012-8-14
1.	经检查发现是原理图中SPI3_MOSI线接到74HC244的管脚17,从管脚9输出到机芯.
	实际应该从管脚3输出.原管脚3一直输出0,所以打印结果永远为空白.
	修改此硬件错误后打印正常.
3.	但是目前打印过程不流畅,以一行为单位打印,每打印一行作为一个流程.中间有停顿.


程序版本:0.42
编写人员: 
编写日期:2012-8-15
1.	修改ProcessCharMaskReadBuf(),修改CHAR_MASK_READ_BUF_STATUS_WAIT_TO_DEAL的处理.
	将gPrtDataBufStatus做为函数内的静态变量.	
	修改后不再出现发送内容多时死机无法处理全部打印字符的错误,发送的全部字符都会被
	打印出来,而且不会出现过流异常.但是会出现压缩及电机反向进纸的错误.
	有待继续修改行打印缓冲区处理部分程序.


程序版本:0.43
编写人员: 
编写日期:2012-8-16
1.	修改CopyPrtDataToLineStruct(),需要打印下划线时才复制下划线缓冲区.
2.	检查ProcessCharMaskReadBuf()处理流程正常.
3.	修改InitLinePrtBuf(),清零变量时根据下划线是否打印来清零缓冲区.
4.	检查PrintLineBuffer(),处理流程正常.
5.	修改SetGoLineSpace(),如果之前的加热及走电机任务完成,则进行设置行间距处理,否则不处理.
6.	修改后还是会出现连续打印行间距变为0,甚至反向走纸的问题.
7.	修改SetGoLineSpace(),设置行间距同时关闭上纸定时器,设置完毕之后再设置延时并开启上纸定时器.
	修改后逐行打印时不再出现少走行间距,反向走纸等异常.但是有时压缩.
	但是连续打印多行时,不走行间距.
	修改行间距为12点行时,还出现反向走纸的错误.
8.	关闭起始和结束擎住阶段处理,还会出现反向打印的错误.


程序版本:0.44
编写人员: 
编写日期:2012-8-16
1.	将关闭电机的操作移到主循环中处理.
2.	一次发送两行内容时,两行间行间距消失.行前行后行间距正常.
3.	修改StartHeatAndRotateMotor(),可以加热下一点行时设置好加热时间后设置定时器为2,立即启动此次加热.
	修改ProcessHeatAndMotor()加热结束后电机延时处理.添加处理走行间距的定时器设置.
	修改ProcessMotor()上纸结束后关闭定时器,不再处理延时等待两次.
	修改主程序,在其中检查并停止电机.
	修改后打印严重压缩.
4.	单步跟踪GoDotLine()中断处理逻辑正确.
编写日期:2012-8-17
1.	去掉起始擎住和结束擎住处理,置保留步进和断开处理.
	打印依然出现反向进纸错误.
2.	编写测试程序,只通过中断周期性上纸,定时器中断中关闭电机延时结束擎住时间.
	上纸时发现还出现反向上纸错误.
	修改关闭电机程序,当上纸结束后直接关闭电机和定时器,无需经过延时.
	修改后GoDotLine()发现上纸不再出现反向上纸错误.此时无论是否加起始擎住处理打印还出现反向上纸错误.
	改用FeedPaper(FEED_FORWARD, 24)周期性上纸测试,不出现反向上纸错误.
	加起始擎住处理后,GoDotLine()周期性上纸还会出现反向错误.不加起始擎住,GoDotLine()周期性上纸不出现反向错误.	
3.	修改电机驱动芯片设置参数,将限流电阻由0.75换为0.33及0.1,打印反向问题均无改变.
	将RC值由2K/0.01uF换为47K/1nF,限流电阻为0.1,出现反向的频率更多了.
4.	将驱动模式由1步1点行改为4步1点行,问题解决.


程序版本:0.45
编写人员: 
编写日期:2012-8-20
使用0.44修改.
1.	使用4步1点行方式,限流电阻值0.75,恢复上纸和加热控制程序中起始和结束擎住处理,恢复方向处理.
	测试打印速度.满行汉字打印速度51mm/s.
	打印颜色较淡,越往后打印颜色越淡.电机非常平稳,声音很小.
2.	恢复RC值为2K/0.01uF.
	上纸电机噪声很大.
	恢复RC值为47K/1nF,上纸电机噪声很小.
3.	改用2步1点行.
	打印速度加快,但是又出现压缩.打印中感觉每行都停顿.
4.	将起始和结束擎住处理都去掉,电机行间距走完就停住关闭.
	打印颜色均匀,无压缩.感觉每行都停顿.电机噪声不大.
5.	定时器中不处理关闭电机,在主程序循环中关闭电机.
	打印颜色均匀,中间有一行丢失一个字,有的行间距没走.
6.	定时器中关闭电机,恢复结束擎住处理.
	打印中只打印前几行,后面的都不再打印.


程序版本:0.46
编写人员: 
编写日期:2012-8-20
使用0.44修改.
1.	改用2步1点行.恢复起始和结束擎住.在定时器中关闭电机.
	会出现打印压缩.压缩一整行.连续打印时丢失行间距.
2.	定时器中将起始和结束擎住处理都去掉,电机行间距走完就停住关闭.
	打印颜色均匀,无压缩.感觉每行都停顿.电机噪声不大.
3.	定时器中添加起始擎住,电机行间距走完就停住关闭.
	打印效果同上.
4.	定时器中行间距走完后添加结束擎住,结束擎住结束后关闭电机,
	修改后反而有停顿,并且行间距有的丢失.
5.	定时器中去掉结束擎住,但是保留结束擎住的定时,
	打印有停顿.有时压缩.有丢失行间距.
6.	定时器中不处理结束擎住和关电机和定时器,改到主程序中处理.
	当接收缓冲区空时无打印任务时关闭电机和定时器.
	打印有停顿,无压缩.有时丢行间距.
7.	将电机上纸时间表时间改为/STEPNUMBER,将上纸速度时间宏定义改为/STEPNUMBER,
	打印速度加快.行间距消失.
8.	定时器中去掉起始擎住,保留结束擎住和关电机延时处理.
	感觉每行都停顿,每行作为一个打印周期,行间距消失.
9.	不打印行间距.


程序版本:0.47
编写人员: 
编写日期:2012-8-20
使用0.44修改.
1.	将电机上纸时间表时间改为/STEPNUMBER,将上纸速度时间宏定义改为/STEPNUMBER,
2.	定时器添加起始擎住,加热完毕如果不走行间距就关闭定时器.
	上完纸后,关闭电机和定时器,清零控制变量.
	打印速度加快.行间距消失.
3.	定时器上完纸后,不立即关闭电机和定时器,经过一个结束擎住时间加一个最后相位电机时间和后
	才关闭定时器和电机.
编写日期:2012-8-21
1.	修改加热和走电机中断控制,加热完成不关闭定时器.也不设置延时.
	走纸完毕关闭定时器,但是不处理关闭电机.
	在ProcessCharMaskReadBuf()中,如果中断缓冲区为0,且加热和走纸任务完成时关闭加热和电机.
	打印一点行程序中设置延时并启动定时器.
	走行间距程序中设置延时并启动定时器.
	修改后打印不出来,不能正常走纸,走纸电机啸叫.


程序版本:0.48
编写人员: 
编写日期:2012-8-21
使用0.44修改.
1.	使用1/4步驱动,4步一点行.
	将电机上纸时间表时间改为/STEPNUMBER,将上纸速度时间宏定义改为/STEPNUMBER.
	恢复上纸和加热控制程序中起始和结束擎住处理,恢复方向处理.
	修改后打印速度约为43mm/s,无行间距.


程序版本:0.49
编写人员: 
编写日期:2012-8-21
1.	驱动芯片为4步1点行,加速时间为原1步1点行.
	无起始擎住和结束擎住处理,走纸完成后即停止电机,关闭定时器.
	修改后打印字体及行间距均正常.就是速度低.
2.	将电机上纸时间表时间改为/STEPNUMBER,将上纸速度时间宏定义改为/STEPNUMBER.
	将走行间距步数改为点数*STEPNUMBER.
	修改后打印字符正常,但是不走行间距.按键中断走纸正常.
3.	将电机关闭和停止定时器放到主程序中,检查当无打印和上纸任务时停止.
	中断中只清零变量.
	修改后打印多行压缩,有的没有打印出来.
	恢复中断中关闭电机.
4.	中断中添加结束擎住和关闭电机处理.
	打印效果与3相同.
5.	测试擎住电机的实际效果.
	编写测试程序DBG_MOTOR_HOLD,测试起始擎住,结束擎住和关闭电机,
	发现起始和结束擎住电机时电流会增大180mA.
6.	启用起始擎住,不要结束擎住,中断中走完纸后立即停止电机和定时器.
	修改后打印字符正常,但是不走行间距.按键中断走纸正常.
7.	调试跟踪发现,目前程序流程为每点行作为一次加速循环.
	一点行加热完成后电机被停止并被重设为0起始.
	另外程序实际设置了走行间距.在一点行加热完毕之前,不会设置行间距.
	行与行之间行间距之所以没有了,是因为上一行的最后一点行加热完毕后,
	行间距变量被下一次上纸中断设置为0.
8.	修改加热处理,加热完毕如果行间距值为零,关闭定时器.
	修改上纸处理,上纸完毕后清零行间距变量,关闭定时器.
	电机关闭在主程序中执行.
	在ProcessCharMaskReadBuf()中,如果中断缓冲区为0,且加热和走纸任务完成时关闭加热和电机.
	修改后单行打印可以打印出但是没有行间距.多行连续打印会压缩,也无行间距.
9.	屏蔽关掉电机的处理.相当于只要有打印内容就不停打印.
	打印效果同上.
10.	将上纸时间改为/2,4步1点行驱动,
	连续打印行间距不丢失.
	打印中间行间距变得非常长.因为行间距设置程序错误.
11.	效果行间距设置程序,去掉*STEPNUMBER.
	修改后连续打印行间距尺寸正常,不会丢失行间距.
12.	如果在4步1点行驱动时,电机时间使用1步1点行的加速表,打印一切正常.
	如果采用/2或者/4的加速表,就会出现打印压缩或者丢行或者丢失行间距的错误.
13.	采用/4的加速表,逐行打印字符正常,但是没有行间距.如果连续批量打印,就会压缩并丢行间距.


程序版本:0.50
编写人员: 
编写日期:2012-8-21
1.	编写测试程序,查找不打印行间距及压缩的原因.
2.	按照维络城的模式,接收内容后不是边收边打,而是等到全部接收完毕再处理.
3.	定义DBG_RX_TOTAL_THEN_PRT.
	defconstant.h中添加RX_FLAG_TIM等宏定义.
	gvar.h,extgvar.h中添加giRxFinishFlag变量定义.
	修改main()函数,添加变量初始化.
	修改UART4_IRQHandler(),添加收完再处理程序.
	修改TIM5_IRQHandler(),添加收完再处理程序.
	修改ProcessCharMaskReadBuf(),添加收完再处理程序.
4.	修改后批量发送完毕后,打印压缩,无行间距.
5.	跟踪发现前面一行内容打印完毕后,走完行间距后还要等待一段时间才能准备好下一行内容.
	所以中间出现了断档.
	电机会完整走完行间距处理,接收缓冲区非空时也不会关闭电机.
	需要将字库SPI读取也设置成DMA方式,以减少时间占用.


程序版本:0.51
编写人员: 
编写日期:2012-8-21
将字库SPI读取也设置成DMA方式,以减少时间占用.
1.	添加sFLASH_DMAInit()函数.
	添加sFLASH_StartDMARx()函数.
	sFLASH_Init()无需修改.
	更改未完成.待继续.


程序版本:0.52
编写人员: 
编写日期:2012-8-22
1.	添加测试程序,测试填满一行打印缓冲区最快需要多长时间.
	使用定时器1做为计时器.
2.	定义DBG_DEAL_ONE_LINE_TIME.
	定义DBG_TIMER.
	修改TimerConfigPrescaler(),添加所有定时器的时钟使能.
	修改预分频计算部分的程序,使之适应APB1和APB2所有定时器.
	添加DBG_TIMER的预分频设置,设置为预分频1us.
	修改ProcessCharMaskReadBuf(),添加统计一行处理时间计时处理程序.
	添加条件编译的全局变量giDealOneLineTimeCount;
	添加条件编译的TIM1中断程序处理.
	修改InitNVIC(),添加TIM1_UP_IRQn中断使能.
3.	实际调试测试无放大等特殊处理的汉字满行处理,中间无打印走电机等中断打扰,
	第1行填满耗时5740us.(计时中断间隔10us)
	第1行填满耗时2900us.(计时中断间隔100us)
	
	后续汉字无放大等特殊处理,满行,中间包括加热走电机打印等所有中断程序.
	LINE_PRT_BUF_CHECK_INTERVAL_US = 5
	第2行填满耗时10200us.(计时中断间隔100us)
	第3行填满耗时11100us.(计时中断间隔100us)
	第4行填满耗时11200us.(计时中断间隔100us)
	第5行填满耗时11200us.(计时中断间隔100us)
	第6行填满耗时11200us.(计时中断间隔100us)
	第7行填满耗时11300us.(计时中断间隔100us)
	第8行填满耗时11200us.(计时中断间隔100us)
4.	从以上测试看,处理一行字符只需要2.9ms.
	但是复制一行内容及打印一行合计需要的时间较长.
	需要逐个环节测试各部分环节需要的时间.


程序版本:0.53
编写人员: 
编写日期:2012-8-22
1.	测试满行数据复制消耗的时间.
	定义DBG_ONE_LINE_TIME,DBG_COPY_ONE_LINE_TIME.
	修改程序,将测试耗时环节的公共程序改为DBG_ONE_LINE_TIME条件编译.
	ProcessCharMaskReadBuf()中根据DBG_DEAL_ONE_LINE_TIME条件编译测试处理一行时间.
	修改CopyPrtDataToLineStruct(),添加测试复制所需时间的条件测试程序.
	测试发现复制时间120~130us.(定时器间隔10us)
2.	添加DBG_TIM1测试程序.测试TIM1定时是否正确.
	测试发现TIM1实际延时与预期延时相差1倍.设定延时1s,实际延时2s.
	测试TIM2延时正确.
	修改TimerConfigPrescaler(),将重复值设置为0后TIM1定时正确.
	之前测试的打印处理各个环节的值应该增加两倍.
3.	实际调试测试无放大等特殊处理的汉字满行处理,中间无打印走电机等中断打扰,
	第1行填满耗时6000us.(计时中断间隔100us)
	后续汉字无放大等特殊处理,满行,中间包括加热走电机打印等所有中断程序.
	LINE_PRT_BUF_CHECK_INTERVAL_US = 5
	第2行填满耗时24000us.(计时中断间隔100us)
	第3行填满耗时23400us.(计时中断间隔100us)
	第4行填满耗时22800us.(计时中断间隔100us)
	第5行填满耗时22600us.(计时中断间隔100us)
	第6行填满耗时22600us.(计时中断间隔100us)
	第7行填满耗时22600us.(计时中断间隔100us)
	第8行填满耗时22400us.(计时中断间隔100us)
	第9行填满耗时22500us.(计时中断间隔100us)
4.	可以正常打印.


程序版本:0.54
编写人员: 
编写日期:2012-8-22
1.	测试复制并清零原缓冲区需要时间.
	修改ProcessCharMaskReadBuf(),添加测试程序.
	测试耗时310,320,340,350.一般为340,最大350us.
2.	修改打印流程中各个步骤的延时值定义.添加各个阶段的宏定义.
3.	修改DMA2_Channel2_IRQHandler()中定时时间为1us.
4.	修改WaitToPrintLineBuf()中去掉检测前一行是否加热和走纸完毕的程序,延时设为1us.
	StartPrintLineBuf()不做修改,
5.	修改StartHeatAndRotateMotor(),将行打印缓冲区检测定时器延时时间根据上纸和加热电机的
	控制定时器当前延时时间决定.设置前读取FEED定时器的当前计数值,将其增加一定值后设置.
	先开始处理加热和走纸,后处理判断各点行是否全打完.
6.	修改SetGoLineSpace(),如果加热和走电机结束设置行间距并停止打印检查定时器,
	如果未完成则读取FEED定时器的当前计数值,将其增加一定值后设置打印检查定时器并启动.
7.	修改完毕打印出现问题,不打印.
	调试发现行编辑缓冲区一直为忙.
	0.53版本可以正常打印.
8.	将StartHeatAndRotateMotor()和SetGoLineSpace()中读取TIM3当前定时器值再设置部分的程序改为
	SetTimerCounter(PRINT_CHECK_TIMER, 10);
	打印还是出错.


程序版本:0.55
编写人员: 
编写日期:2012-8-22
由0.53版本修改.
1.	测试复制并清零原缓冲区需要时间.
	修改ProcessCharMaskReadBuf(),添加测试程序.
	测试耗时310,320,340,350.一般为340,最大350us.
2.	修改打印流程中各个步骤的延时值定义.添加各个阶段的宏定义.
3.	修改DMA2_Channel2_IRQHandler()中定时时间为1us.
	修改后可正常打印.
4.	修改WaitToPrintLineBuf()中去掉检测前一行是否加热和走纸完毕的程序,延时设为5us.
	修改后可正常打印.
5.	StartPrintLineBuf()不做修改.
6.	修改StartHeatAndRotateMotor(),将行打印缓冲区检测定时器延时时间根据上纸和加热电机的
	控制定时器当前延时时间决定.设置前读取FEED定时器的当前计数值,
	先开始处理加热和走纸,后处理判断各点行是否全打完.
	修改之后不打印.	
	修改前程序可以正常连续打印.只是不打印行间距.恢复为修改前打印控制定时器的时间设置.
7.	将定时器1~5的中断标志位清除由最后放到最前面.
	修改后看正常连续打印,不打印行间距.
8.	修改SetGoLineSpace(),如果加热和走电机结束设置行间距并停止打印检查定时器,
	如果未完成则读取FEED定时器的当前计数值,将其增加一定值后设置打印检查定时器并启动.
	修改之后可以单行打印,不能连续多行打印,否则会出现压缩.不打印行间距.
9.	将定时器4的主优先级由3改为4.
	所有问题全部解决.
	打印非常快.而且行间距正常.
	测试速度为172mm/s.打印浓度较淡.
10.	将StartHeatAndRotateMotor()打印检查定时器值设置为上纸电机控制定时器值.
	又会变得不打印.
11.	恢复10的修改.
	将StartHeatAndRotateMotor()最后设置打印下点行的延时设置为1,
	走行间距的延时设置为LINE_PRT_BUF_CHECK_INTERVAL_US.目前为5us.
	连续打印正常.行间距正常.浓度稍微深了一些.
12.	将LINE_PRT_BUF_CHECK_INTERVAL_US改为10us.
	修改后不能打印.恢复为5us打印正常.
13.	编写测试程序,测试打印速度.以收完再打的方式进行计时.
	添加宏定义DBG_PRT_SPEED.
	实测满行汉字打印速度220mm/s.打印浓度稍淡.
14.	人为将最终加热时间加倍.
	打印浓度增加.较清晰.
15.	人为将最终加热时间*3, *2.5.
	打印浓度很高,非常清晰,但是打印流程出问题,连续发送打印时只打印了第一行就死机.
	目前先使用*2倍的计算加热时间.
16.	打印清晰浓度下最高满行打印速度220mm/s.


程序版本:0.56
编写人员: 
编写日期:2012-8-23
由0.55版本修改.
1.	添加PrintOneLine()函数,实现复制行打印缓冲区数据,复制控制变量,清零编辑行打印缓冲区,开始打印本行的功能.
	将ProcessCharMaskReadBuf()内的静态变量PrtDataBufStatus改为全局变量,名称改为giLineEditBufStatus.
	增加编辑行打印缓冲区的状态的宏定义.
	修改ProcessCharMaskReadBuf()内的相关程序.
	修改0x0D和0x0A命令,实现换行打印.通过调用PrintOneLine()函数实现.
	程序流程出错.处理过程中有冲突.
2.	修改CopyPrtDataToLineStruct()复制打印编辑缓冲区时,如果缓冲区内容为空,不再复制.
	注意此时换行将只打印行间距.
	修改PrintOneLine(),复制完毕,赋值控制变量后,立即启动打印.
	将清空编辑缓冲区的工作放到后面执行.	
3.	修改WaitToPrintLineBuf(),如果打印缓冲区为空白,直接跳到走行间距状态.
4.	初始化时将上纸电机定时器值预设值为1.
5.	2,3,4修改完毕,单独打印0x0A工作正常.
	单独连续打印满行汉字工作正常.
	但是如果打印内容不满一行,连续发送打印内容后不再打印.
6.	修改SetLinePrtModeVariable()中pstruLinePrtBuf->PrtMode.MaxLineHigh的定义.
	修改后只执行新行的0D,0A,不执行新行的满行打印和不满行打印及混合换行.
	改为原24时可以打印满行和0A,0D.
	该值只能根据打印字体的高度不同而定义为17和24,不能超过24.
7.	修改ProcessCharMaskReadBuf()中通信接收缓冲区内容空白时,
	如果无打印任务,只关闭电机和加热,不关闭加热上纸控制定时器.	
8.	目前程序处理正常,包括以下情况:
	不满行汉字+换行;
	不满行汉字+不满行汉字,到满行时自动换行打印;
	不满行汉字+字符+换行;
	字符+换行;
	字符+汉字+字符+换行;
	即汉字和字符单独及混合方式不满行+换行正常.
	汉字和字符单独及混合方式满行后自动换行正常.
9.	设置行间距时,走纸距离改为行高-字符高.
	修改SetGoLineSpace().
	回车换行的含义应该是走的行间距值为两个字符行之间的空白区.
	修改后逐行打印没有问题,批量连续多行打印时会出现压缩.
	根据编程手册,默认行间距为32点(1/6英寸),修改回原来设定.


程序版本:0.57
编写人员: 
编写日期:2012-8-23
由0.56版本修改.
1.	测试目前程序中各个环节的耗时.单位us.
	填满第一行满行汉字:	6100
	第2行满行汉字:		19100
	第3行满行汉字:		18900
	第4行满行汉字:		17400
	第5行满行汉字:		17200
	第6行满行汉字:		17200
	第7行满行汉字:		17200
	第8行满行汉字:		17100
	第9行满行汉字:		17100
	...:				17100
2.	修改LINE_PRT_BUF_CHECK_INTERVAL_US,由5改为10.
	处理流程中会出现错误.恢复为5.
3.	修改StartHeatAndRotateMotor(),加热或者走电机未完成时设置打印检查定时器
	计数器值为上纸定时器计数器值.
	修改后测量处理各行值除了第一行为6100外,其他各行基本为7100,7200.最大不超过7400.
	修改后有时候可以打印,有时候会出现电机一直停电无法关断的异常.
	此时死机不再处理后续打印内容.
4.	修改上纸加热控制定时器.恢复之前结束擎住的附加处理.只在上纸控制定时器中断中关闭定时器.
	打印几行后会死机.电机不会关不掉.
5.	恢复3的修改.
	会正常打印.无压缩.无丢失.
	默认行间距时满行汉字打印速度不低于220mm/s.电机会可靠关断.
6.	目前程序使用行间距为16以上时连续打印不会出现压缩现象.
	使用行间距8时连续打印会出现压缩现象.
	还需要想办法降低打印时打印检查中断对CPU的占用.
7.	修改StartHeatAndRotateMotor(),加热或者走电机未完成时设置打印检查定时器
	加热时设置打印检查定时器值为上纸定时器当前值的1/2,
	上纸时设置打印检查定时器值为100,
	修改后不打印.
	加热时设置打印检查定时器值为20,
	上纸时设置打印检查定时器值为50,
	修改后可以打印,但是有时打印压缩,电机噪声大.
	放弃更改.


程序版本:0.58
编写人员: 
编写日期:2012-8-23
1.	修改程序流程.检查行打印缓冲区状态为SPI_SEND_OVER时:
	修改StartHeatAndRotateMotor(),检查加热是否完成,如果未完成,停止PRINT_CHECK_TIMER,
	计算加热时间,退出.不再设置延时并启动PRINT_CHECK_TIMER.如果加热已经完成,原程序处理方式不变.
	修改ProcessHeatAndMotor(),加热完成后,清零控制变量,然后检查gstruLinePrtBuf的状态
	是否为LINE_PRT_BUF_STATUS_SPI_SEND_OVER,如果是则立即启动PRINT_CHECK_TIMER.其他的程序不做修改.
	修改后各种方式打印正常.
2.	修改程序流程.检查行打印缓冲区状态为SPI_SEND_OVER时:
	修改StartHeatAndRotateMotor(),检查加热是否完成,如果未完成,程序修改同1.
	如果已经完成,锁存数据,可能计算加热时间,再检查电机是否走完.如果电机没有走完,关定时器退出.
	如果电机已经走完,原程序处理方式不变.
	修改ProcessMotor(),上纸完成后,清零控制变量,然后检查gstruLinePrtBuf的状态
	是否为LINE_PRT_BUF_STATUS_SPI_SEND_OVER,如果是则立即启动PRINT_CHECK_TIMER.
	修改后各种方式打印正常.
3.	修改程序流程.检查行打印缓冲区状态为LINE_PRT_BUF_STATUS_SET_GO_LINE_SPACE时:
	修改SetGoLineSpace(),先停止PRINT_CHECK_TIMER,后检查是否可以设置行间距.
	如果可以则设置并启动走纸,如果不可以则不做任何处理.
	修改ProcessMotor(),上纸完成后,清零控制变量,然后检查gstruLinePrtBuf的状态
	是否为LINE_PRT_BUF_STATUS_SET_GO_LINE_SPACE,如果是则立即启动PRINT_CHECK_TIMER.
	修改后出现错误.电机控制过程中出错.
4.	暂时只进行1,2步的修改.
5.	修改后测试填满一行耗时:
	第1行填满耗时很长,38400us.
	从第2行开始基本都为6200us.
	测试打印效果良好.
6.	目前程序使用行间距为16以上时连续打印不会出现压缩现象.
	设置行间距为8,12点行时,打印第一行会整行全部压缩为一点行.
	使用边收边打和收完再打都可以正常工作.
7.	修改GetMaxAccelerateSteps(),修改程序速度设置,当行间距低于16时降低打印速度.
	根据行间距的不同而设置不同的最大加速表.
	修改后各种行间距从0到32都可以正常打印.
	不过当行间距为0,1,2,3时,加热浓度很低.而从4开始,加热效果都基本一致.
8.	将三种情况下的最高加速度从50,20,10改为70,40,20后,
	全部都能正常打印,而且加热浓度基本一致.
9.	暂时使用目前的打印处理流程.


程序版本:0.59
编写人员: 
编写日期:2012-8-24
1.	行间距含义为字符高度+两行之间的空白高度.
	目前默认行间距为32点,默认字符高度为17或者24,所以设置的走空白间距为或者15或者8点行.
	程序还需要做一定调整.
2.	继续测试目前程序,打印过程中填满一行内容的同时上一行是否已经打印完毕.
	跟踪发现在处理下一点行的同时,打印过程总是停止在走行间距的状态.
	可见在走行间距之前已经编辑好了下一点行的内容.
	如果能提高走行间距的效率,就可以解决行间距短的问题.
3.	测试打印中没有数据丢失.
	修改设置行间距部分的程序.
	修改SetGoLineSpace(),如果加热及走行间距未完成,则关闭PRINT_CHECK_TIMER退出.
	如果已完成则设置行间距并立即启动走纸,然后清空打印缓冲区内容.
	行间距设置为PrtMode.CodeLineHigh - PrtMode.MaxLineHigh * STEPNUMBER.
	修改ProcessHeatAndMotor(),加热完成后,如果上纸距离为0,检查行打印缓冲区状态是否为走行间距,
	如果是则立即启动PRINT_CHECK_TIMER.
	修改GetMaxAccelerateSteps(),去掉根据行间距限制最高速度的程序.
	修改后连续打印会出现整行压缩成一点行的错误.
4.	修改ProcessHeatAndMotor(),加热完成后,如果上纸距离为0,去掉关闭上纸定时器的操作.
	修改后连续打印会出现整行压缩成一点行的错误.
5.	修改ProcessCharMaskReadBuf(),去掉接收缓冲区如果为空时关闭上纸电机和上纸定时器的程序.
	修改后连续打印还是会出现整行压缩成一点行的错误,但是出现的频率降低了很多.
6.	将起始和结束擎住的时间由10000改为1000 / STEPNUMBER.
	修改后连续打印满缓冲区4K的内容都没有出现压缩.
	修改成功.
7.	满行汉字,可变加热,行间距32点,字高24点,
	测试最高打印速度175mm/s.
	汉字,字符,0A0D混合打印正常.
8.	修改SetHeatNumber(),添加测试一次加热的条件编译测试程序.打印测试条件同上.
	修改后测试满行打印效果同之前相同,速度基本还是为175mm/s,打印半行汉字速度220mm/s.
9.	修改InitLinePrtBuf(),InitCharMaskBufParameter(),InitHeatElementBuf(),
	InitHeatElementBufLeftEmpty(),InitHeatCtrlStruct(),
	将其中缓冲区清零部分的操作由循环全部改为memset().
	修改后打印工作正常.


程序版本:0.60
编写人员: 
编写日期:2012-8-24
1.	调试测试读取1个汉字的字模需要时间为200us.
2.	调试发现目前程序在加热完成后如果行间距=0时不关闭FEED_TIMER,则后续程序连续进入ProcessMotor().
	而此时不需要进入该处理.
	修改ProcessHeatAndMotor(),恢复加热完毕,如果行间距=0则停止FEED_TIMER.
	修改后打印效果无改善.
3.	调试发现ProcessMotor()处理中,行间距走完后将电机加速下标步数重新设置为了0.
	这样打印下一行时会又从第一步加速表开始.
	修改为电机走完后清零控制变量,关闭定时器.
	在主程序中检查并关闭电机.
	修改后调试发现电机一直保持在最高速度,直到最后关闭.
	修改后逐行打印正常,连续打印会连续多行压缩成点行.
4.	修改ProcessMotor(),走完上纸后检查行打印缓冲区状态如果为SPI_SEND_OVER或者SET_GO_LINE_SPACE,
	均起动PRINT_CHECK_TIMER.增加FEED_MOTOR_ILDE_NUMBER为3,
	修改后还会出现连续打印多行时出现压缩问题,同时速度也没有提高.
5.	ProcessMotor()去掉结束擎住,
	连续多行打印不再出现压缩.满行打印最高速度为165mm/s.(默认行间距)
6.	加热和走纸时去掉起始擎住,连续打印出现多行压缩.恢复起始擎住.
7.	将结束擎住时间增加1倍到5000.连续多行打印会压缩.恢复结束擎住时间.
8.	恢复根据行间距设定最高打印速度的程序.
	修改GetMaxAccelerateSteps(),根据空白的点行数确定最高速度.
	目前设置的参数都能平稳打印.
	实际速度可以在以后调试.目前的程序打印平稳.
9.	从下一个版本开始编写USB通信部分的内容.


程序版本:0.61
编写人员: 
编写日期:2012-8-28,2012-8-29
从本版本开始添加USB通信部分的内容.
1.	添加USB-FS-DEVICE驱动库及文件.
2.	添加USB驱动文件.(886版本)
3.	目前编译无法通过,需要修改.
4.	逐个添加USB相关的处理.
5.	添加hw_config.h,hw_config.c两个文件.
	main()中添加USB初始化,
	InitNVIC()USB中断设置改为根据端口检测结果设置.
	Set_USBClock()已检查.
	已添加SetUSBPort().
6.	相关stm32f10x_it.c,USB相关的中断处理函数的条件编译处理.
	暂未启用.
7.	添加usb_conf.h文件.添加的是Mass_Storage样例中的文件.
	注意对应的程序名称不同,需要修改.
8	添加usb_istr.h文件.添加的是Mass_Storage样例中的文件.
	注意对应的程序名称不同,需要修改.
9.	添加usb_desc.h和usb_desc.c文件.添加的是886中的文件.ok
10.	添加endp.c文件.添加的是886中的文件.
	注意原程序使用EP1_IN,EP2_OUT,与CL系列的不同.需要修改.
11.	添加usb_istr.c文件.添加的是Mass_Storage样例中的文件.
	两种芯片使用的是不同的处理程序.原103系列芯片的处理程序相同.
12.	添加usb_prop.h和usb_prop.c文件.添加的是886中的文件.
	这是主要的处理文件.
13.	添加usb_pwr.h和usb_pwr.c文件,添加的是Mass_Storage样例中的文件.
14.	hw_config.h改为usb_hwconfig.h.
15.	修改usb_prop.c文件,将原来的处理函数改为条件编译.
	需要编写新的函数替代以上各个程序.
16.	修改hw_config.c,注释掉不需要的程序.名称改为usb_hwconfig.c.
	目前的版本编译通过,但是没有实现USB功能.需要安装OTG_D标准重新改写.


程序版本:0.62
编写人员: 
编写日期:2012-8-29
1.	usb_conf.h文件中既包括了USB_FS_Device的情况也包括了OTG_FS_Device的情况.
2.	Get_SerialNum()函数目前用的是MASS-STORE样例中程序,与886的不同.按照886的进行修改.
3.	修改PRINTER_init(),按照条件编译方式修改.添加OTGD模式的初始化程序.
	修改Get_SerialNum(),综合MASS-STORE和886.
4.	修改PRINTER_Reset(),包括CL和其他芯片两种的条件编译.
5.	修改PRINTER_SetConfiguration(),包括CL和其他芯片两种的条件编译.
6.	PRINTER_SetDeviceAddress(),PRINTER_Status_In(),PRINTER_Status_Out()对各种芯片都同样程序.


程序版本:0.63
编写人员: 
编写日期:2012-8-30
1.	修改PRINTER_Data_Setup(),改为两种芯片都使用同样的原程序.
2.	修改PRINTER_NoData_Setup(),修改为根据不同芯片使用不同程序.
3.	PRINTER_Get_Interface_Setting()使用同一程序,原程序.
4.	修改PRINTER_Out(),修改为根据不同芯片使用不同程序.
5.	修改USB_Transfer_Data(),修改为根据不同芯片使用不同程序.
6.	添加CAN1_TX_IRQn和CAN1_RX0_IRQn中断函数的定义.空函数.
	修改stm32f10x_it.h,添加条件编译的函数声明.
	OTG_FS_IRQHandler()函数中调用STM32_PCD_OTG_ISR_Handler().
7.	usb_pwr.c已检查.暂时可不修改.
8.	基本的修改已经完毕,下一版本编写USB测试程序进行测试.


程序版本:0.64
编写人员: 
编写日期:2012-8-30
1.	编写USB测试程序,初始化时,添加USB时钟和端口初始化,添加USB初始化,清USB忙.
2.	修改ReceiveInterrupt(),添加USB中断控制,添加根据不同芯片条件编译的程序.
3.	修改usb_init.c,头文件修改为usb_init.h,
	而usb_init.h的头文件包含添加usb_lib.h.
	将u8 PRINTER_Status = 0x18从usb_prop.h中移动到usb_prop.c中,头文件中改为声明.
	添加usb_prop.h头文件中包含的函数声明.
	编译通过.
4.	修改ReadInBuffer(),添加USB清忙.
	修改UpLoadData(),添加USB接口.
	usb_prop.h中添加usb_core.h包含.
	检查完毕,在下一版本中测试.


程序版本:0.65
编写人员: 
编写日期:2012-8-31
1.	测试打印一次成功.
	主机不动,打印后断电,再次加电后依然可以打印.
	POS机不动,主机重启动后,继续使用测试工具打印,工作正常.
2.	将USB描述标识符中公司名称改为WHKJ相关.
	修改usb_desc.c中程序.
3.	指令相关修改放到以后修改.
4.	从下一版本开始添加以太网驱动相关程序.


程序版本:0.72
编写人员: 
编写日期:2012-9-20
由0.65修改.中间从0.66到0.71均为添加以太网过程中的版本.
1.	将所有#include	<stdio.h>改为#include <string.h>.
2.	还有TIM6,TIM7两个16位定时器可以使用.
	修改timconfig.h文件,添加LWIP_ROUTINE_TIMER,LWIP_ROUTINE_INTERVAL_MS宏定义.
	修改TimerConfigPrescaler(),添加TIM6,7的计数模式,这两个定时器只支持向上计数.
	TimerConfigPrescaler()对于APB1上的定时器,预分频值不得小于1099!
	否则寄存器值会溢出.最大为16位,65535.
	修改ROUTINE_TIMER分频为0.1ms.
3.	修改PutCharToInBuffer(),当接收完一个字符已经达到接收缓冲区满的条件时,禁用通信中断,置忙.
	修改ReadInBuffer(),当缓冲区解除满条件时,启用通信中断,解除忙.
	添加SetComInBufBusy()和ClearComInBufBusy()函数,目前包括串口和USB口的设置.
4.	修改CopyPrtDataToLineStruct(),复制时不再全部整体复制,
	而是根据放大倍数先计算数据起始地址,再调整相应指针位置,调整复制的数据长度来减少复制的数据量.
5.	修改PrepareNewLine(),清除打印编辑缓冲区时,根据放大倍数先计算数据起始地址,
	再调整相应指针位置,调整复制的数据长度来减少复制的数据量.
6.	修改SetGoLineSpace(),处理完毕走行间距后不再使用InitLinePrtBuf(),改为使用新添加函数.
	添加新函数ClearLinePrtBuf().不再全部清空,根据放大倍数及字符判断是否全部清空.
7.	修改GetMaxAccelerateSteps(),添加限速条件编译.
8.	修改后如果不限速会出现压缩.感觉电机速度太快停不住导致.
	使用1D 21指令设置放大倍数,结果死机无反应.修改之前可以正常工作.


程序版本:0.73
编写人员: 
编写日期:2012-9-21
1.	修改SetGoLineSpace(),恢复原程序.死机.
	修改PrepareNewLine(),恢复原程序.不打印.
	修改CopyPrtDataToLineStruct(),恢复原程序.修改后打印正常.
2.	要实现以上处理,需要处理缓冲区中最高字符设置,PrtCtrlData.LineHigh.
	需要修改字符汉字处理程序,添加以上处理,需要修改FillLinePrintBuf()等.
	涉及地方太多,暂时不考虑.留待以后处理.目前先实现正常打印及各种指令.
3.	下划线打印应该从一行的定义打印处开始,到取消打印处结束.
	下划线打印的规格应该可以在一行中多次修改,分别设置,不应该影响打印效果.
	PrtModeChar.Underline,PrtModeHZ.Underline标志下划线打印模式.
	修改print.h,c文件.添加下划线打印状态宏定义.
	添加一个下划线打印是否已经完成了的标志变量,UnderLinePrtOverFlag,	
	修改Command_1B2D(),Command_1C2D(),添加3点模式.
4.	编辑打印内容时,按照字符,汉字,图形,条形码,光栅位图,下载位图,上划线,下划线
	等混合交叉编辑的目的.最终编辑缓冲区的内容与最终打印内容实现1:1对等.
	目前将上划线,下划线单独处理,不能实现1:1对等.
	设置一个变量,标志编辑缓冲区中以最底部基点为基准,可打印内容的最高的行数.
	修改TypeDef_StructPrtCtrl,添加最高高度变量MaxPrtDotHigh,在编辑过程中,所有内容
	处理时都要实时更新该值.打印时根据该值确定打印高度点数.
	
	将上划线,下划线使用1个缓冲区实现,BIT7,2,1,0表示下划线,BIT6,5,4,3表示上划线.
	上下划线与纵向放大倍数无关,打印时高度上恒为1倍.
	编辑每个字符及汉字时,均需处理对应的上下划线缓冲区.
	设置一个变量,标志一行中上下划线最高的点数.
	修改TypeDef_StructPrtCtrl,添加下划线最高点数变量,UnderlineMaxPrtHigh.
	打印时,根据UnderlineMaxPrtHigh确定下划线取值循环次数.
5.	修改WaitToPrintLineBuf(),添加下划线打印是否完成标志.
6.	修改StartPrintLineBuf(),添加处理下划线打印,目前只添加了正向打印处理.
	添加新函数FillUnderLineToHeatElementBuf(),
	处理下划线数据填充,目前只写了正向打印处理程序.
7.	修改StartHeatAndRotateMotor(),添加处理下划线打印,目前只添加了正向打印处理.
8.	修改FillPrintBuff(),需要根据字符还是汉字进行下划线填充处理.
9.	修改SetLinePrtModeVariable(),添加下划线打印高度点数变量赋值.
10.	修改InitPrtCtrlDataParameter(),添加下划线打印高度点数变量赋值.
11.	修改PrepareNewLine(),添加下划线打印高度点数变量赋值.
12.	修改后只打印空白.
	修改WaitToPrintLineBuf()的判断空闲的条件错误.打印正常.
14.	汉字下划线打印错误,电机一直加电.
13.	添加条件编译下划线打印.
14.	修改以上各函数中的错误,添加相应变量的初始化和赋值.
	将UnderLinePrtOverFlag定义到行打印缓冲区控制结构变量中.
	修改后打印下划线正常.不过当前的程序流程实际效果为上划线.
15.	汉字如果设置为1点则打印不出来下划线,
	设置为2点则只打印一点行下划线.
16.	只要字符或者汉字有一个设置了,则打印时全部加了下划线.错误.
17.	修改FillPrintBuff(),修改下划线添加判断条件.
	修改Command_1D21().
	修改打印处理流程函数StartPrintLineBuf(),目前打印下划线正常.
	唯一错误为设置为2点则只打印一点行下划线.设置为1点则不打印.


程序版本:0.74
编写人员: 
编写日期:2012-9-24
1.	修改StartPrintLineBuf(),添加处理下划线打印,添加反向打印处理.
2.	修改FillUnderLineToHeatElementBuf(),改为两个正向和反向分别独立的函数.
	UnderLineBufToHeatElementNormalDir(),UnderLineBufToHeatElementReverseDir().
3.	修改StartHeatAndRotateMotor(),添加处理下划线打印,添加反向打印处理.
4.	测试对齐方式,左对齐可以正常打印.
	中间对齐时丢失打印内容,右对齐也丢失打印内容.颠倒打印效果不起作用.
	目前程序中无左右边界设置指令.
	添加TypeDef_StructPrtCtrl中PrtRightLimit为右边距.
5.	原行间距计算错误.修改GetMaxAccelerateSteps(),SetGoLineSpace()中行间距点数的计算.
6.	修改GetLinePrtBufStartColumnIndex(),原计算中间对齐及右对齐起始值错误.
7.	修改LineBufToHeatElementNormalDir(),UnderLineBufToHeatElementNormalDir(),
	修改打印内容结束判断条件.
	修改后正向打印左对齐,中间对齐,右对齐打印均正常.
	结合字符汉字下划线,左,右,中间三种对齐方式混合测试打印均正常.
8.	修改LineBufToHeatElementReverseDir(),UnderLineBufToHeatElementReverseDir(),
	修改打印内容结束判断条件.
	修改后反向打印左对齐,中间对齐,右对齐打印均正常.
	结合字符汉字下划线,左,右,中间三种对齐方式混合测试打印,下划线有的地方漏打.
	修改判断条件.出现漏打应该是加热时间过短.
9.	修改GetHeatTime(),将计算结果值变为计算值的3倍.
	打印效果清晰.
	基本上反向时三种情况的下划线都能准确打印出来.
10.	左边距为0时,三种对齐方式情况下正反两种打印反向时下划线及字符汉字打印正常.
	设置左边距不为0时出现错误,出现数据丢失.


程序版本:0.75
编写人员: 
编写日期:2012-9-25
1.	测试发现设置左边距为12,实际打印结果为左边距24.
	单步调试发现处理过程都是按照左边距12处理的,没有找到错误原因.
	问题可能出在SPI数据发送方面.
2.	反显指令测试通过.
3.	反显,三种对齐方式,下划线,字符/汉字,各种放大倍数混合指令测试通过.
4.	顺时针旋转90度指令测试通过.
5.	顺时针旋转90度,反显,三种对齐方式,下划线,字符/汉字,各种放大倍数混合指令测试通过.
6.	修改LineBufToHeatElementNormalDir(),UnderLineBufToHeatElementNormalDir(),	
	加快复制速度,减少不必要的复制.
	顺时针旋转90度,反显,三种对齐方式,下划线,字符/汉字,各种放大倍数混合指令测试通过.
7.	打印9*17字体正常.


程序版本:0.83
编写人员: 
编写日期:2012-9-27
以0.75版本修改.之前的版本修改为了实现一体式混合打印,
结果0.82之前版本除了旋转指令外都已经通过.整体式打印模式修改留待以后实现.现在暂时不做修改.
目前的程序在处理字符时,不论是17还是24点阵字符,一律按照24点阵进行填充处理,
包括其中的右间距填充,旋转,反显,加重打印等.
1.	FillLinePrintBuf()修改涉及到的程序,已经检查.
	FillDataPrintBuff()已检查,
	FillPrintBuff()已经检查,
2.	SetLinePrtModeVariable(),修改MaxLineHigh赋值,由24改为PrtCtrlData.LineHigh,
	PrepareNewLine()中有以上变量的赋值.
3.	PrtCtrlData.MaxPrtDotHigh初始化为0.在编辑过程中实时更新该值.
4.	WaitToPrintLineBuf(),反向打印起始改为MAX_FONT_HEIGHT * pstruLinePrtBuf->PrtMode.MaxRatioY,
	PrtCtrlData.MaxPrtDotHigh初始化为0,每行开始前也初始化为0,字符编辑过程中判断
	MAX_FONT_HEIGHT * MaxRatioY实时更新.
5.	修改后打印17及24点阵高字符汉字,17点阵旋转打印死机.
6.	将PrtCtrlData.LineHigh全部初始化为MAX_FONT_HEIGHT.
	修改后17和24点阵字体各种组合打印都不会死机.但是这种处理有待改进.因为17点时打出的高度为24点.
7.	将PrtCtrlData.LineHigh初始化为0,
	开始新行时初始化为PrtCtrlData.CharHigh,
	修改后17和24点阵字体各种组合打印都正常.17点打出的高度为17点.
8.	设置左边界后打印错误的原因在于填充时的地值计算与打印时一点行数据横向转换程序在计算地址时不匹配造成,
	FillPrintBuff()处理填充时地址处理时以PrtCtrlData.PrtDataDotIndex为基础开始计算,
	FillHeatElementBuf()处理点行数据转换时以一点行的首地址开始为基础进行转换.这样两种之间不匹配.
	需要修改FillHeatElementBuf()的错误.改以有实际打印内容的地方开始,即需要加上PrtCtrlData.PrtLeftLimit.
	StartPrintLineBuf()修改点行转换首地址计算,正反向及下划线首地址均 + pstruLinePrtBuf->PrtMode.PrtLeftLimit.
9.	修改后测试左边距设置从0到576,实际打印效果均符合预期.
10.	将 / 8的操作统一替换为 >> 3.
	修改后打印正常.


程序版本:0.84
编写人员: 
编写日期:2012-9-27
1.	Command_1B20()修改,添加最大右间距宏定义.
	页模式下的程序还有待完善.
2.	Command_1B21()修改,添加加粗模式对汉字同时有效.字符尺寸采用宏定义.
3.	Command_1B24()修改,修改参数计算方法.
	目前的程序只对本次打印有效,对下一个新行无效.
	页模式下的程序还有待完善.
4.	Command_1B25()无需修改,
5.	Command_1B26()修改,添加了指令参数合法性检查,修改了自定义字符数据接收存储方法.
	需要进行测试以验证何种程序处理方式正确.
6.	Command_1B3F()修改,字符尺寸采用宏定义.添加参数合法性检测.
	修改了字模数据指针的计算,修改了清空字模数据的判断条件.原程序错误.
	需要测试以验证.
7.	Command_1B2A()修改,采用Velo中程序替代,并修改该程序.
	该指令打印的图形不放大.高度上1:1打印.分为8点阵和24点阵分别处理.
	添加检查指令参数是否合法,编辑之前检查编辑行缓冲区是否已满,编辑过程中处理是否图形打印模式,
	调整行高等参数,如果编辑过程中满行则打印该行,然后继续编辑.修改完毕.
8.	修改SetGoLineSpace(),设置行间距时根据是否是图形打印模式确定是否走行间距.图形打印时不走行间距.
	修改新行开始变量的图形标志位清零.
9	测试打印9*17/12*24/24*24字符与1B2A混合或者单独打印正常.包括旋转,倒置,放大,下划线混合指令均正常.	
10.	图形和字符打印时的设计规则.
	字符打印时,行间距由PrtCtrlData.CodeLineHigh确定;图形打印时,行间距为0.
	字符打印时,纵向放大倍数由PrtCtrlData.MaxRatioY确定;图形打印时,纵向放大倍数为1.
	由PrtCtrlData.BitImageFlag标志是否图形模式.=1为图形模式.=0为字符模式.
	图形打印指令1B2A与字符混合打印时,如果1B2A指令出现的位置不在行首,认为不是图形模式;
	如果1B2A指令出现的位置在行首,认为是图形模式.打印时放大倍数=1,行间距=0.
	图形打印指令1B4B与字符混合打印时,如果1B4B指令出现的位置不在行首,认为不是图形模式;
	如果1B4B指令出现的位置在行首,认为是1B4B图形模式,
	添加标志PrtCtrlData.VariableBitImageFlag标志是否与放大倍数有关的图形模式.
	=1为图形模式.=0为字符模式.
	行高设置为8,纵向放大倍数由PrtCtrlData.MaxRatioY确定,行间距为0.
11.	TypeDef_StructPrtCtrl,TypeDef_StructPrtMode修改定义,添加VariableBitImageFlag.
12.	Init_Parameter()修改,添加BitImageFlag,VariableBitImageFlag,初始化.
13.	SetLinePrtModeVariable()修改,添加VariableBitImageFlag赋值.
14.	Command_1B2D()修改,已修改,添加三行点数的情况定义.
15.	Command_1B32()修改,添加默认行高宏定义.
16.	Command_1B33()修改,添加最大横向和纵向计算行间距,修改程序,将最大值比较直接与宏定义比较.
17.	Command_1B3D()修改,无需修改.
18.	Command_1B40()修改,修改InitParameter(),根据参数清除打印缓冲区.
	去除行打印缓冲区的清空.在InitParameter()中已经清除过了.


程序版本:0.85
编写人员: 
编写日期:2012-9-28
1.	计算最大横向跳格数目时使用打印点数/字符宽度.标准程序中需要*横向放大倍数,
	设置最大跳格数目宏定义MAX_HT_INDEX_NUM,设置为固定值32.
	修改跳格变量TabIndex[]定义,	
	增加跳格最大值和默认值宏定义,
	修改TypeDef_StructTab定义;
2.	InitTabStructParameter()修改,增加最大索引值比较判断以防止内存越界;
	Command_1B44()重新编写,读取跳格设置数目判断参数及清零剩余TAB设置值数组判断参数均改为MAX_HT_SET_NUM.
3.	Command_1B45()修改,无需修改.
4.	Command_1B47()修改,无需修改.
5.	Command_1B4A()修改,最大走纸间距改为判断宏定义.注意行间距实现方式.
	添加新函数GetPrintStatus().	
	修改WaitToPrintLineBuf(),先检查行间距或者加热是否处理完毕再开始本行处理.
	测试该指令.实际打印效果与预期不符.只有设置行间距大于0x90时才走行间距,否则走不出行间距.
	TypeDef_StructPrtMode定义中CodeLineHigh数据类型改为u16,原来为u8,会溢出.
	修改StartHeatAndRotateMotor(),其中设置在加热未完成及走电机未完成时会关闭打印检查定时器.错误.
	修改完毕,测试打印符合预期.
6.	Command_1B4C()修改,无需修改.
7.	Command_1B4D()修改,改用宏定义设置长宽数值.添加字符控制变量的数值赋值.原程序错误.
	修改后测试该指令正常.
8*.	Command_1B52()修改,无需修改.
	添加国际字符集索引宏定义定义.
	InitSystemCtrlStructParameter()修改,国际字符默认设置与语言选择有关.
	中文机型如果选择了中文,默认值为15,否则为0.
	目前版本打印乱码.暂时恢复为默认值均为0.
	此指令无问题,是字库及字符解码处程序有问题.
9.	Command_1B53()修改,无需修改.
10.	Command_1B54()修改,无需修改.
11.	Command_1B56()修改,修改参数判断和变量赋值.
12.	Command_1B5C()修改,无需修改.已经修改过.
	目前按照只在本行有效方式使用.
13.	Command_1B61()修改,修改参数合法性检查.
14.	Command_1B63()修改,无需修改.
15.	Command_1B64()修改,最大走纸间距改为判断宏定义.注意行间距实现方式.
	修改后测试该指令正常.
16.	Command_1B69()修改,无需修改.
17.	Command_1B70()修改,无需修改.
	

程序版本:0.86
编写人员: 
编写日期:2012-9-28
1.	Command_1B74()修改,添加最大选择项宏定义.
2.	Command_1B7B()修改,无需修改.
3.	Command_1B6D()修改,无需修改.
4.	Command_1B75()修改,无需修改.
5.	Command_1B76()修改,无需修改.
6*.	二维条码相关的暂不处理.
7.	1B指令全部检查完毕.
8.	Command_09()修改,添加检查是否下标越界.
9.	Command_0A()修改,行内倍宽清除放到初始化新行中处理,此处无需再处理.
10.	Command_0C()修改,将其处理改为标准模式下打印当前行,然后再找黑标.
11.	Command_0D()修改,行内倍宽清除放到初始化新行中处理,此处无需再处理.
	将其改为与指令手册中说明一致.
12.	Command_15()修改,无需修改
	GoDotLine()修改,修改电机步数赋值,需要根据电机驱动模式修改.
13*.Command_16()修改,添加宏定义,使用系统内存函数初始化缓冲区.
	目前处理方式为逐点行发送并加热,需进行修改.目前暂时不修改.
14.	Command_18()修改,无需修改.
15*.Command_1004()修改,无需修改.暂时没有与说明书比较细节.
16*.Command_1005n()修改,原程序错误.添加清除缓冲区和停止加热走电机及打印的控制.修改完毕.
	添加头文件包含.
	将giLineEditBufStatus定义放在文件头部.
	PrepareNewLine()修改,将giLineEditBufStatus状态修改放在函数内.
17*.Command_1014fnmt()修改,需要添加关机等操作.暂未添加.
	添加清除编辑和打印缓冲区操作,传送清除响应暂未添加.
18.	单字节指令及实时指令检查完毕.
	需要测试.


程序版本:0.87
编写人员: 
编写日期:2012-9-29
1.	Command_1C21()修改,无需修改.
	目前0D指令被禁用.改用0A指令实现换行.
2.	Command_1C26()修改,无需修改.
3.	Command_1C2D()修改,无需修改.
4.	Command_1C2E()修改,无需修改.
5*.	Command_1C50()修改,打印预下载位图,没有找到指令说明书.暂时屏蔽.
6.	Command_1C32()修改,改用宏定义替代常量.改变变量命名.
7.	Command_1C43()修改,已经修改.
8.	Command_1C53()修改,无需修改.
9.	Command_1C57()修改,修改参数计算式,拆分计算.
10*.Command_1C67()修改,未写.
11.	1C指令修改完毕.

12*.Command_1D21()修改,无需修改.
	目前程序中处理纵向放大倍数有个漏洞,凡是设置新放大倍数的指令,都会实时更新
	PrtCtrlData.MaxRatioY,而编辑缓冲区中存储的内容是按照之前的
	PrtCtrlData.MaxRatioY值进行编辑的,如果之前编辑的内容放大倍数与新设置后的不同,
	而如果此时打印,则打印缓冲区控制放大倍数的变量会按照新的PrtCtrlData.MaxRatioY
	值赋值,从而使得打印出的内容与编辑缓冲区的实际内容不符.
	实际测试发现确实会出现这种现象.
	修改方法为:涉及到放大的指令只设置字符或者汉字的放大倍数,不调整PrtCtrlData.MaxRatioY.
	而在编辑打印内容的过程中,在编辑字符之前实时调整PrtCtrlData.MaxRatioY到最大值.
	检查完1D指令后再修改.
13.	Command_1D42()修改,无需修改.
14.	Command_1D44()修改,无需修改.
15.	Command_1D45()修改,无需修改.
16.	Command_1D48()修改,修改参数检查判断.
17.	Command_1D66()修改,无需修改.
18.	Command_1D68()修改,无需修改.
19*.Command_1D6B()修改,打印条码的处理.有错误,需要调整.
	在解决了一体式打印后再修改.
20*.Command_1D77()修改,修改为按照机芯横向纵向最小移动单元计数的值.
	目前程序中使用是按照POS885定义,与EPSON定义不一致.
	使用中还是换算成横向最小移动单位的倍数来使用更方便.
	暂时不做更改.
21.	Command_56()修改,修改走纸函数,添加条件编译自动上纸.
	添加新函数WaitFeedPaperFinish(),将延时等待上纸结束的地方调用修改.
	去除无用的break.修改完毕.
22.	Command_1D4C()修改,修改参数计算方法,将其*横向移动单位.
23.	Command_1D57()修改,修改参数计算方法,将其*横向移动单位.
24*.Command_1D50()修改,无需修改.
	不过目前的有些指令使用了横向纵向移动单位进行计算.可能会出现配合错误的问题.
	还需要逐条复查.
25.	Command_1D2A()修改,原程序错误.
	添加下载位图的最大宽度,最大高度,最大数据量的宏定义.
	添加参数合法性判断,不合法退出.
	修改读取数据时长度的判断条件,改为最大值.
	原宏定义BMPLENGTH是错误的,定义的数据缓冲区小于该指令的参数.
	添加下载位图数量的宏定义.
	修改下载位图相关宏定义.
	目前程序是按照只有1幅下载位图设计的.如果要同时下载多幅位图,需要添加标志位图索引的新变量.
	改用指针实现数据存储,目前程序修改完毕.
26*.Command_1D2F()修改,
	目前处理是按照点行进行,还需要进行修改.改为先编辑缓冲区,全部编辑完毕再作为一整行进行打印.
	在解决了一体式打印后再修改.
27*.Command_1D5A()修改,无需修改.
	没有找到编程说明书中对该指令的解释.
28.	Command_1D72()修改,原程序错误.
	修改输入参数合法性检查,修改参数错误.
29.	Command_1D49()修改,
	原程序中指针p使用会有问题.将其修改为指向固定声明的地址,防止出现异常.	
30.	Command_1D61()修改,无需修改.
	需要检查程序其他地方对于状态自动返回的处理.


程序版本:0.89
编写人员: 
编写日期:2012-9-30
以0.87版本为基础修改.
字符打印作为一种处理,图形作为一种处理.
条形码作为图形方式打印,条形码的HRI字符作为字符方式打印.
1.	添加新函数,将打印开始前全局变量设置分到两种状况处理.
2.	添加新函数,将开始打印的内容处理分到两种状况.
	图形模式的尚未编写.
3.	将加热和走电机处理中检查打印是否完成的功能放到一个新函数中.
	修改后打印字符正常.
4.	特殊打印效果组合指令中出现打印死机问题.
	除了旋转指令,其他指令都不会造成问题.
5*.	旋转指令处理留待以后修改错误.错误原因是编辑过程中产生的.
6.	图形指令包括
	1B13,1B2A,1B4B,1C2F,2C70,1C71,1C76,1D23,1D2A,1D2F,1D76,
	StartPrintLineBufGraphic()修改,按照原一体式处理方法处理首地址.
	CheckPrintContentFinishOfGraphic()修改,按照原一体式处理方法处理首地址.
	Command_1B2A()修改.
	测试除了旋转之外的字符各种设置打印正常.
	测试1B2A指令打印图形正常.
7.	修改放大指令中实时修改最高纵向放大倍数的错误,
	在设置放大倍数的命令中不调整打印控制放大倍数的修改,改为在编辑过程中调整.
	Command_1B21()修改PrtCtrlData.MaxRatioY设置错误,
	Command_1C21()修改PrtCtrlData.MaxRatioY设置错误,
	Command_1C57()修改PrtCtrlData.MaxRatioY设置错误,
	Command_1D21()修改PrtCtrlData.MaxRatioY设置错误,
	PrepareNewLine()修改,将放大倍数值改为1;
	FillLinePrintBuf()修改字符的高度宽度赋值;
	FillPrintBuff()修改,添加PrtCtrlData.MaxRatioY的实时更新,根据字符或者汉字分别判断;
		修改PrtCtrlData.MaxPrtDotHigh的实时更新判断条件,
		由MAX_FONT_HEIGHT * RatioY改为CharHigh * RatioY,
	测试除了旋转之外的字符各种设置打印正常.
	测试1B2A指令打印图形正向打印正常.但是倒置打印时无反应.
8.	FillPrintBuff()修改,PrtCtrlData.MaxPrtDotHigh判断赋值为CharHigh * RatioY.
	包括旋转指令在内所有特殊设置指令的组合打印正常.
9.	Command_1B2A()修改最大数据量计算,
10.	StartPrintLineBufGraphic()修改反向打印点行数计算,
	反向图形打印有错误.正向打印正常.
11.	GetMaxAccelerateSteps()修改,按照四种情况调整最高限速.
12.	InitCharMaskBufParameter()修改.
	图形打印时停顿感很强.字符指令组合字符打印都正常.
	图形打印正向打印正常,反向打印不正常.
13.	CodeRollCtrl()修改,/8改为>>3,
	字符指令组合字符打印都正常.
	图形打印正向打印正常,反向打印不正常.


程序版本:0.91
编写人员: 
编写日期:2012-10-5
以0.89版本为基础修改.
目前程序左对齐满行打印时会漏掉最右边的一列.
添加条形码打印处理.
1.	按照VELO一维条码修改的barcode.c修改.
	条形码打印指令除了反向打印外,其他设置对齐都应该不起作用.
	修改条形码处理程序,修改UPC-E的处理程序.
	FormatCodeUpc_E()修改,按照数据为8修改.
	修改ITF25条形码数据参数处理,如果为奇数,将数据长度-1.
	Command_1D6B()修改,添加条件编译修改UPC-E格式的参数设置.
	Command_1D6B()修改,添加条件编译维络城指令设置起始距离.
	Command_1D6B()修改,不同公司指令参数定义不一样.目前程序是SPRT定义.与荣达定义有不同.	
2.	PrintString()完成.将其放到charmaskbuf中.
3.	添加giCodebarPositionSpace,表示条码打印位置距离边沿的值.单位为横向点数.
	Command_1D51()添加,设置giCodebarPositionSpace.
4.	PrintBar()修改.将条形码内容从下划线缓冲区填充到编辑缓冲区.
5.	默认条码高度改为162点.
6.	PrtCtrlData.CodeLineHigh处理按照点行数计算,在走电机的时候再转换为电机步数.	
7.	可以打印条码,条码打印时行间距不正常.没有测试HRI字符打印效果.


程序版本:0.92
编写人员: 
编写日期:2012-10-6
1.	PrintString()修改,改为顺序填充式处理.
	目前条码打印正常打印全部正常,反向打印时高度与预期值不符.
	原因应该与图形打印异常相同.以后再处理.


程序版本:0.93
编写人员: 
编写日期:2012-10-6
1.	测试上电自检程序.
	CutPaperAfterPrint()修改,
	PrintInterfaceType()修改,
	PrintUsartParameter()修改,
	PrintASCIICharactor()修改,
	PrintBarCodeType()修改,
	PrintBlackBlock()修改,
	目前自检打印正常.
编写日期:2012-10-7
1.	测试16进制打印.
	HexMode()修改,添加打印前等待纸舱盖关闭,等待延时,FEED键检测.
	目前16进制打印正常.
2.	barcode2d.h和.c文件添加.修改排版和函数声明.
3.	pdf417lib.h和.c文件添加.修改排版和函数声明.
4.	允许二维条码打印相关程序,编译通过.
	二维条码打印的程序还需要修改.


程序版本:0.94
编写人员: 
编写日期:2012-10-7
1.	Command_1D77()修改,修改窄条宽度计算.
2.	Command_1B4B()添加,打印并反向走纸.
3.	Command_1B13()添加,炜煌公司使用该指令做为驱动打印指令.
	其参数与功能定义与微打指令1B4B相同.
	与放大指令一起组合,测试成功.
	与字符,放大指令一起组合,测试成功.
	倒置打印有问题.
4.	Command_1D2F()未修改.


程序版本:0.95
编写人员: 
编写日期:2012-10-8
以0.94版本修改.
添加0.88版本中修改的地方.
1.	Command_1D61()修改,无需修改.
2.	Command_1D3A()修改,无需修改.
3*.	Command_1D5E()修改,
	添加了调用ProcessCharMaskReadBuf()处理宏.有待测试.
4.	Command_1D2841()修改,基本修改.
	添加置忙.SetComInBufBusy().执行完毕清除忙.
5.	Command_1D2844()修改,修改参数名称和类型,修改数据读取循环实现方式.
	还有许多该系列指令等待添加.
6*.	Command_1D76()修改,需要修改.
	打印光栅位图指令.等待修改.
7.	Command_1D67()修改,需要修改.
	添加缓冲区的结束标志符号.
	1D6730修改初始化维护计数器参数程序,添加置忙,清忙操作.
	1D6732传输维护信息,添加置忙,清忙操作.该部分程序与说明书不完全符合,
	有待细化维护计数器的操作和定义.	
8.	1D指令检查完毕.
9.	Command_1B56()修改,微打指令集作为放大倍数,POS作为旋转.
10.	Command_1B57()添加,微打指令集作为放大倍数,POS作为定义打印区域范围.
	目前只写了微打放大处理.
11.	Command_1B55()添加,微打指令集作为放大倍数,POS作为双向打印.
12.	Command_1B4B()修改,添加根据指令集分别处理.


程序版本:0.96
编写人员: 
编写日期:2012-10-8
1.	修改自检打印,去掉串口参数的起始空格和条码后的换行.开始添加走纸一行.
2.	Command_1B13()修改,一行满的判断条件应该为 < PrtCtrlData.PrtLength而不是 <=.
	原设计会导致数组下标溢出.
	Command_1B2A()同样修改.
	JudgeLineBufFull()同样修改.
	JudgeLineFull()同样修改.
	图形正向打印正常,倒置打印时不正常.
	字符打印正向反向正常.
3.	修改CUT_OFFSET,NO_CUT_OFFSET宏定义值.
	修改FEED_BACK_MAX_STEPS等关于上纸距离的宏定义值.
	去掉与驱动步数有关的值.
	按键上纸等正常.
4.	图形指令1B13与字符混合打印时,正向打印正常,反向打印异常.
	反向打印或者正向打印加热浓度较高时有时出现电机转不动的异常.


程序版本:0.97
编写人员: 
编写日期:2012-10-8
1.	修改复制和清除编辑和打印缓冲区内容的函数,根据PrtCtrlData.MaxPrtDotHigh计算.
	CopyPrtDataToLineStruct()修改.复制编辑缓冲区到打印缓冲区.
	正常字符复制根据PrtCtrlData.MaxPrtDotHigh计算.
	下划线根据PrtCtrlData.PrtLeftLimit,PrtCtrlData.PrtDataDotIndex计算.
	测试正常.
	PrepareNewLine()修改.清除编辑缓冲区.
	正常字符清除根据PrtCtrlData.MaxPrtDotHigh计算.
	上划线,下划线根据PrtCtrlData.PrtLeftLimit,PrtCtrlData.PrtDataDotIndex计算.
	测试正常.
	InitLinePrtBuf()修改.清除编辑缓冲区.
	正常字符清除根据PrtCtrlData.MaxPrtDotHigh计算.
	上划线,下划线根据PrtCtrlData.PrtLeftLimit,PrtCtrlData.PrtDataDotIndex计算.
	测试正常.

	
程序版本:0.98
编写人员: 
编写日期:2012-10-8
1.	继续修改以上三个函数,添加复制,清除编辑缓冲区,清除打印缓冲区时根据左边距与打印宽度计算,
	以进一步减少数据操作量.
	InitLinePrtBuf()上一个版本程序有错误.
	测试正常.
2.	1B4B测试有误.改为直接调用1B13.
	测试正常.
3.	Command_1D23()添加,定义下载到RAM中的位图图号,下载位图和打印位图根据此图号进行.
	添加新变量gcDownloadBitMapNumber,标志该信息.目前的RAM最多只能下载1副位图.
	去掉不必要的变量定义.
4.	Command_1D2A()修改,按照最大内存1536*8字节编写.
	编写完毕.
	以后还需要考虑内存不足的问题.48K内存不足.需要56K以上才行.
5.	Command_1D2F()修改.未完成.
编写日期:2012-10-9
1.	Command_1D2F()一次打印修改完成.按照全部使用RAM编写.
	一次填充的测试完毕.使用8点高和64点高点阵图形测试四种打印方式正向打印均正常.
	反向打印时无反应,错误.
	W25Q32BV字库最小擦除单位为4K,保留了最后的64K作为系统参数区域.
	系统参数可以只使用其中的16K,其余48K作为RAM下载位图数据量超过预定最大值后的缓冲区.
	每8K作为一个使用单位.
2.	PrepareNewLine()修改,改正其中错误.
	WaitToPrintLineBufOfGraphic()修改,改正其中错误.
	修改后1D2F()反向打印正常.
	测试1B2A()正反向打印正常.
	测试条码打印正向打印正常,反向打印会出现死机.
	上电后只打印条码时,无论放大倍数多少,正反向打印都正常.
	再次上电后结合特殊设置指令,同时混合打印字符,下载位图,条码均正常.


程序版本:0.99
编写人员: 
编写日期:2012-10-9
1D2F()超过一次打印的程序还未编写.
从本版本开始添加新接口板的程序.
1.	添加宏定义,以区别控制板的硬件区别.
	SystemInit()修改时钟初始化,107控制使用25M,103控制使用12M.
	HSE_VALUE宏定义值改为12000000.
	SetSysClockTo72()修改.根据HSE_VALUE的值确定PLL倍频系数.
2.	PRTDOTNUMBER全部替换为PRT_DOT_NUMBERS.
	将所有与字符字体宽度和高度赋值操作的地方都改为宏定义的宽度和高度.
	MAX_RATIO_Y * 3全部替换为MAX_PRT_HEIGHT_BYTE.
	测试字符,图形,HRI打印正常.
3.	1D2F()超过一次打印的程序编写完毕.
	打印超过1次时死机.


程序版本:0.100
编写人员: 
编写日期:2012-10-10
1.	修改切刀相关管脚定义.
2.	修改上纸相关管脚定义.将相关函数和宏定义条件编译.
	新设计去掉了DECAY和SR控制,添加了USM0和USM1控制.
	InitFeedPort(),修改管脚初始化.
3.	修改外接端口检测管脚定义.
4.	修改加热控制端口管脚定义.无需修改.
5.	修改加热电源控制管脚定义.无需修改.
6.	修改钱箱检测和控制管脚定义.无需修改.
7.	修改胶辊检测管脚定义,无需修改.
8.	修改上纸按键检测管脚定义.无需修改.
	修改以太网复位按键检测管脚定义.将相关宏定义条件编译.
9.	修改指示灯控制管脚定义.将相关宏定义条件编译.
10.	修改蜂鸣器控制管脚定义.无需修改.
11.	修改ADC相关管脚定义.
	24v_in无需修改.
	temperature将相关宏定义条件编译.
	pe将相关宏定义条件编译.
	pne将相关宏定义条件编译.
	blackmark无需修改.
	将模拟量输入最高速度由50M都改为2M.
12.	字库SPI控制管脚定义.无需修改.
13.	机芯SPI控制管脚定义.无需修改.


程序版本:0.101
编写人员: 
编写日期:2012-10-10
1.	与PC端连接的串口管脚定义.
	原设计使用UART4,现在改用USART1.
	UART修改宏定义,USART_Config()修改串口时钟使能,
2.	USART1_IRQHandler(),UART4_IRQHandler(),修改为条件编译.
	以太网中断及USB中断处理改为条件编译.
3.	InitNVIC(),修改串口中断,以太网中断,改为条件编译.
4.	将下载到RAM的位图占用RAM空间改为条件编译,图形大小改为原来1/2.
5.	usb_hwconfig.h添加检测USB电源的条件编译,
	USB_Cable_Config()添加.
	SetUSBPort()修改,添加POWER_IN_CHECK管脚设置.
6.	使用HD的启动文件.修改栈为4K.
	编译通过.通过JTAG下载成功.
7.	使用外部8M晶振, DBG_INBUF_RCV开始初始化时钟死机.
	DBG_USART之前的都正常.
	ADC_ADC_DMA_Config(),修改时钟设置,修改后时钟初始化正常.
	测试AD正常.
8.	添加头文件包含,变量声明,去除不使用的变量定义.
	Command_1B44()修改,NUL用0x00替代.
9.	将二维条码中变量的定义放到对应的c文件中.
10.	测试上纸正常.
11.	测试切刀正常.


程序版本:0.102
编写人员: 
编写日期:2012-10-11
1.	修改1D2F处理方式,当超过1满页时,改为逐字节行打印.
	修改后超过1满页的正向打印正常,反向可以打印,但是打印结果与预期不符.
	修改取打印字符顺序后正常,噪声较大.
	除了同时倍高倍宽外,打印都正常.不满1页的可以同时倍高倍宽打印.
	修改后正向反向四种情况打印都正常.
2.	新设计板USB接口测试正常.


程序版本:0.103
编写人员: 
编写日期:2012-10-11
1.	1D2F()修改,超过1页时也可以分整页打印.
	逻辑太麻烦,不使用,还是使用102版本.


程序版本:0.104
编写人员: 
以102版本修改.
编写日期:2012-10-11
1.	temp.c中的函数检查,去掉无用的,修改能功能的.
	MemSet()去掉.
	DriveDrawer()编写,放到moneybox.
	FindMarkPoint()编写,放到feedpaper.
	StartNewLine()去掉.
	InitPrintBuff()去掉.
	SystemDelay1mS()编写,通过延时实现.放到timconfig.
	ClearInBuf()放到cominbuf.
2.	循环方式点行处理的程序暂时不处理.包括:
	Command_16(),Command_1C50(),Command_1D76().
3.	PrintBarCode_2D()中调用MoveLine(),MovDotLine()打印,需要处理.
4.	ReadFeedKey()添加,处理按键操作.包括16进制和正常模式,连续纸上纸和黑标纸寻的.
	上纸期间自动进入离线状态,上纸完毕恢复在线状态.
	WaitHeatAndFeedPaperFinish()添加.
5.	SystemSelfTest()修改,自检打印时为脱机状态,自检完毕,恢复在线状态.
6.	ErrorDetect()修改,缺纸或者纸将尽时,自动进入离线状态.
7.	InitRealTimeStatusSrtuctParameter()添加,加入初始化函数中.
8.	0D暂时功能同0C.
9.	1B13()分次发送,打印正常.


程序版本:0.105
编写人员: 
编写日期:2012-10-12
1.	FlashErrorLed()添加,实现指示灯和蜂鸣器指示.在systimfunc中.按照SPRT POS886的规则设置.
2.	SystemTimer2Func()修改.去掉不需要的,调整各操作顺序.
3.	DMA1_Channel1_ADFunc()中允许设置各个实时状态参数.
4.	LED_PEND_ON,LED_PEND_OFF,READ_FEED_KEY,READ_DRAWER_STATUS等都改为新函数.
	添加钱箱状态读取宏定义.
5.	去掉appgpio.h.
6.	修改ADC采样时间设置.
	DMA1_Channel1_ADFunc()修改温度判断计算,原判断条件相反.
7.	PutCharToInBuffer(),修改,添加行缓冲区操作,添加实时指令填充.
8.	ReadInBuffer()修改,去掉按键检查.
9.	MAXCODELENGTH改为4K.
10.	最大最小接收缓冲区判断宏定义改为一致.


程序版本:0.106
编写人员: 
编写日期:2012-10-12
1.	维护计数器相关程序添加maintain文件.
2.	GetConfigData(),添加读取内部FLASH参数.
	WriteSPI_FlashParameter()放到spiflash.
3.	HardFault_Handler(),添加安全处理.
4.	PrintBar()修改.调整打印文字与条码的距离间隔.拆分成多个函数实现.
5.	PrintBarHRI()添加处理HRI文字打印.
6.	PrintBarBitmap()添加处理一维条码图形打印.
7.	条码打印正常.
	正向,反向打印都正常.结合放大指令测试,打印正常.
	条码文字打印正常.


程序版本:0.107
编写人员: 
编写日期:2012-10-13
1.	自检打印和16进制打印.
2.	ReadInBuffer()修改.其中包含死循环,所以在某些需要调用的地方需要注意.
	去掉图形打印中PCDriverMode的设置.
	添加新函数处理字符转换.
	测试打印正常.


程序版本:0.108
编写人员: 
编写日期:2012-10-13
1.	16进制打印处理字符数目等改为宏定义.
	剩余字节处理改为临时变量标志剩余字节数.否则最后一个字节不会被处理.
	添加对齐方式设置,修改打印提示内容.
	16进制打印测试没有缺陷了.


程序版本:0.109
编写人员: 
编写日期:2012-10-13
1.	添加升级程序处理.
	添加update文件.
2.	assert_failed()修改,添加错误提示处理.
3.	mode修改,添加升级模式和解锁模式.
	检测模式函数需要修改,暂未修改完毕.


程序版本:0.110
编写人员: 
编写日期:2012-10-15
添加与网口有关的程序.U3,SPI3.
1.	添加ethusart文件.处理以太网接口U3程序.
2.	USART3_IRQHandler()程序添加,处理以太网串口接收.
3.	SetComInBufBusy()修改,添加以太网串口处理.
	ClearComInBufBusy()修改,添加以太网串口处理.
	ReceiveInterrupt()修改,添加以太网串口处理,修改串口处理.
4.	InitNVIC()修改,根据检测到的端口初始化外接口中断.
5.	单独打印字符,正反向,各种放大倍数,下划线,对齐方式组合循环发送批量打印正常.
6.	单独打印条形码,正反向,各种放大倍数,批量发送打印不会死机,
	打印量太大时电机会走不动,正常.
7.	打印字符和条码混合批量打印时会出现死机.有时不会出现.暂不处理.


程序版本:0.111
编写人员: 
编写日期:2012-10-15
添加与网口有关的程序.U3,SPI3.
1.	添加ethspi文件.具体程序需要根据LM6537文档进行修改.


程序版本:0.112
编写人员: 
编写日期:2012-10-16
添加升级处理程序.
, BOOTLOAD
1.	USART3_IRQHandler()修改,以太网口标志改为ETHERNET,以免与驱动库ETH定义混淆.
	修改其中清忙的错误.
2.	UpLoadData()修改,添加以太网的数据发送.
3.	GetModeType()修改,包含所有模式.
4.	添加升级处理,解锁JTAG处理.
5.	正常程序测试正常.
6.	改写为两个项目,待BOOTLAOD和不带BOOTLAOD.
7.	有待与BOOT程序结合测试.
8.	修改测纸传感器灵敏度值设置.
9.	测试发现下划线处理程序有错误.
	UNDER_LINE_MAX_BIT改为2.
	字符下划线打印会出现漏打死机现象.
	此时正向打印下划线及字符后,换行,打印带HRI的条码时出现不再处理的现象.
10.	测试BOOTLOAD无反应.
11.	StartPrintLineBufChar()修改.添加字符内容打印完毕,下划线也打印完毕,但是DMA传送出错时候的处理.
	StartPrintLineBufGraphic()修改.添加打印内容完毕,但是DMA传送出错时候的处理.
	ProcessHeatAndMotor()修改,如果行间距为0,不关闭TIM3.
	此时正向打印下划线及字符后,换行,打印带HRI的条码时出现不停上纸现象.
	此时正向打印下划线和字符及换行均完成,上面的HRI条码文字打印完毕,此时开始不停上纸.
12.	FillPrintBuff(),修改下划线打印标记赋值及最高打印点数赋值.
	CopyPrtDataToLineStruct(),修改函数声明错误.
	PrintBarHRI(),添加PrtCtrlData.DoUnderlineFlag,PrtModeHz.Underline的保护和修改.
	此时正向打印下划线和字符及换行均完成,上面的HRI条码文字打印完毕,此时开始不停上纸.
	修改后打印1点行和2点行的程序正常.
13.	ProcessCharMaskReadBuf()修改.处理CHAR_MASK_READ_BUF_STATUS_WAIT_TO_DEAL时,
	如果编辑缓冲区已经满了,则先等待当前行打印完毕,再复制并开始当前编辑缓冲区打印,再继续处理本字符.
	否则PrintString()函数会出现漏打的问题.
	此时正向打印下划线和字符及换行均完成,上面的HRI条码文字打印完毕,此时开始不停上纸.
14.	ProcessHeatAndMotor()修改,加热走完电机后,如果打印缓冲区状态为
	LINE_PRT_BUF_STATUS_SPI_SEND_OVER,启动PRT_CHKECK定时器后退出,不处理下一句.
	StartHeatAndRotateMotor()中进入后如果正在加热,计算完加热时间后退出前启动打印检查定时器.
	修改后打印字符的下划线不会有遗漏和死机.
	此时正向打印下划线及字符后,换行,打印带HRI的条码时出现一直上纸的现象.
	如果不打印HRI字符或者在下方打印HRI字符,都不会出现一直上纸的现象.


程序版本:0.113
编写人员: 
编写日期:2012-10-17
1.	SetLinePrtModeVariable(),去掉下划线打印完成状态变量的赋值.修改最高打印下划线点数值的赋值.
	修改后打印字符的下划线不会有遗漏和死机.
	此时正向打印下划线及字符后,换行,打印带HRI的条码时正常.
2.	StartHeatAndRotateMotor()中进入后如果正在加热,计算完加热时间后退出前不启动打印检查定时器,
	则打印批量数据时可能会出现死机现象.
3.	NVIC_SetVectorTable根据BOOTLOAD修改.
4.	配合0.06版本BOOT程序,经过T6加解密后,可以升级,APP工作正常.
5.	PrintBlackBlock()修改,修改打印长度计算,调整打印内容.
6.	CUT_OFFSET,NO_CUT_OFFSET值修改.
7.	HexMode(),修改,每行打印字符数改为8个.


程序版本:0.114
编写人员: 
编写日期:2012-10-17
1.	hd引导文件采用3.5版本库文件.
	去掉ConfigOptionFlash().
2.	NVIC_VectTab_FLASH修改.根据BOOTLOAD修改.
	无法升级程序.


程序版本:0.115
编写人员: 
编写日期:2012-10-19
以版本0.113修改.
1.	hd引导文件采用3.5版本库文件.
	去掉ConfigOptionFlash().
2.	可以配合0.07版本bootload程序通过T6加密下载工具实现升级.无法通过超级终端升级.
	可以通过USB升级.


程序版本:0.116
编写人员: 
编写日期:2012-10-19
以版本0.113修改.
1.	ErrorDetect()使能.出现错误时停止打印和走纸,关闭控制定时器;
	错误消除后从上一次未完成的任务处继续开始.
	使能原上纸和加热1点行前对该程序的使用.
	修改后出现错误后,不再继续处理未完成任务的错误.
2.	Command_1B76()修改,上传数据与通信接口无关.
	Command_1004()修改,不需要清零的操作.
3.	RealTimeStatusSrtuct改为RealTimeStatusStruct.
4.	DMA1_Channel1_ADFunc()修改.PNE改为条件编译.	
5.	FlashErrorLed(),GetprinterStatus()修改,判断是否有错误改为||.
6.	ADC_SampleTime_28Cycles5改为ADC_SampleTime_13Cycles5.AD采集值较真值大.
	改为ADC_SampleTime_55Cycles5,AD采集值较真值大.
	改为ADC_SampleTime_55Cycles5,AD采集值较真值大.
	改为ADC_SampleTime_7Cycles5,AD采集值较真值大.
	改为ADC_SampleTime_239Cycles5,AD采集值较真值大.
7.	DMA1_Channel1_ADFunc(),修改各路ADC值循环加和计算处理.
	ADC缓冲区长度改为ADC_BUF_LEN.
8.	UpLoadData(),SetComInBufBusy(),ClearComInBufBusy(),ethusart.c文件修改,条件编译.
9.	DMA1_Channel1_ADFunc()计算各路值错误.循环条件应该是ADC_CHANNEL_NUMBER.
10.	将打印时候的ErrorDetect()检查放到一整行打印开始之前进行.
	从StartPrintLineBuf()改为放到PrintOneLine().
	修改后可以正常打印.
	

程序版本:0.117
编写人员: 
编写日期:2012-10-19
1.	ErrorDetect()中关闭切刀函数改为CutMotorStandby().
2.	StartFeedMotor(),StepFeedMotor()中添加ErrorDetect()检查.
3.	TIM2_IRQn主优先级由2改为1,比加热和检查打印定时器优先级高一级.
	修改后有时会出现死机.电机一直维持电流.
4.	InitNVIC()修改ETH接口的错误.
	StartFeedMotor()不加ErrorDetect()检查.
	修改后有时电机一直维持电流.
5.	StepFeedMotor()中去掉ErrorDetect()检查.
	修改后有时电机一直维持电流.


程序版本:0.118
编写人员: 
编写日期:2012-10-22
1.	ErrorDetect()修改,改为返回值并由调用函数处理是否关闭定时器等操作.
	SetEmergencyProtect(),ReleaseEmergencyProtect()处理具体操作.
2.	ErrorDetect()修改各个调用的部分的处理.将其放入feedpaper文件.
	FeedMoveMinStep(),FeedMoveFast()中不检查.
	PrintOneLine(),GoDotLine(),StepFeedMotor()中检查.放到最开始.
	测试ADC值还是乱变.
3.	TIM2主优先级改为1,副优先级改为2.
	修改后打印混合指令等不会出现死机.


程序版本:0.119
编写人员: 
编写日期:2012-10-22
检查修改ADC设置及采样计算等处理.
1.	Tim2Flag改为RoutinFlag;
	OpenADC()中改为只打开1次ADC.
	还出现ADC值乱变现象.相邻通道值移位.
2.	OpenADC()修改,延长启动ADC间隔时间为5ms,还出现ADC值乱变现象.
3.	将循环采集次数改为1次,出现相邻通道值互换的情况反而减少.
4.	OpenADC()不延长启动ADC间隔时间,恢复原频率1ms.相邻通道值移位情况增加.
5.	OpenADC()增加延长启动ADC间隔时间为10ms,还出现ADC值移位现象.
6.	OpenADC()不延长启动ADC间隔时间,恢复原频率1ms.
	采样时间由ADC_SampleTime_28Cycles5改为ADC_SampleTime_239Cycles5.
	移位现象很频繁.
7.	OpenADC()为频率1ms,采样改为ADC_SampleTime_13Cycles5.
	修改后再也不出现移位现象.但是输入值为0V时,AD值为400左右,为3.31V时,AD值为3600左右.
8.	OpenADC()为频率1ms,采样改为ADC_SampleTime_7Cycles5.
	修改后再也不出现移位现象.但是输入值为0V时,AD值为700左右,为3.31V时,AD值为3300左右.
9.	OpenADC()改为频率2ms,采样时间改为ADC_SampleTime_28Cycles5.
	出现ADC值移位现象.输入值为0V时,AD值为100左右,为3.31V时,AD值为3900左右.
10.	OpenADC()改为频率2ms,采样时间改为ADC_SampleTime_13Cycles5.
	修改后再也不出现移位现象.但是输入值为0V时,AD值为400左右,为3.31V时,AD值为3600左右.
11.	OpenADC()改为频率0.5ms,采样时间改为ADC_SampleTime_13Cycles5.
	情况同7.
12.	OpenADC()改为频率0.5ms,采样时间改为ADC_SampleTime_28Cycles5.
	情况同9.
13.	改为情况7.
14.	DMA1_Channel1_ADFunc()修改采样值计算赋值以尽量减少乘除运算.
15.	将所有/2的整数倍的地方全部用移位替代.
	将除运算尽量用乘运算替代.
	将执行时进行的参数的除运算改为参数宏定义替代.
16.	将涉及MIN_STEP_UNIT_X和MIN_STEP_UNIT_Y运算的地方的除运算改为参数宏定义替代,
	本版本程序无需修改,之前都修改过.
17.	Command_1D6B()修改,GoDotLine()设置走纸距离参数值修改.
18.	GoDotLine(),SetGoLineSpace()修改,修改走纸步计算.直接用宏定义参数.
19.	将该版本交付测试.

2012-12-30修改
20. 将串口回传程序去掉.将操作忙信号去掉,由PutCharToInBuffer()操作忙信号和关闭接收中断.
21. ReadInBuffer()修改.当缓冲区为无数据时,添加检查按键.16进制模式下处理与正常模式下不同.
22. GoDotLine()相关调用全部将参数进行强制转换.

编写日期:2012-10-31
1.	Command_1D56()修改,如果宏定义自动上纸,用GoDotLine()实现.
	检查所有与移动单位相关的指令实现,均处理了移动单位.



程序版本:0.121
编写人员: 
编写日期:2012-10-31
以0.119版本修改.
1.	将所有string相关程序的常量指针参数进行强制转换.转换为const类指针.
2.	Command_1D4C()修改.超出最大可打印区域则左边距设置为最大可打印区域.
	如果不超出最大可打印区域但是不足一个字符则设置为能放下一个字符.
编写日期:2012-11-01
1.	Command_1D4C()修改.如果不超出最大可打印区域但是不足一个字符则设置为能放下一个字符判断条件相反.
2.	Command_1D57()修改.判断修改为SystemCtrlStruct.LineWidth而不用PRT_DOT_NUMBERS.


程序版本:0.122
编写人员: 
编写日期:2012-11-01
1.	Command_1D50()修改,进行四舍五入处理.
2.	TypeDef_StructSystemCtrl修改,添加自检模式变量SelfTestMode.
	InitSystemCtrlStructParameter()修改,变量初始化时为0,
	SystemSelfTest()修改,进入自检打印前设置为1,自检打印完毕将其清零.
	ReadInBuffer()修改,自检模式时在检测到按键时不上纸.
3.	Command_1D6B()修改,UPE处理参数按照荣达定义处理.添加VELO_COMMAND宏定义.
4.	Command_1B21()修改,选择12*24和9*17字体后需要修改的变量为PrtModeChar的成员而不是PrtCtrlData成员.
	加粗模式对汉字字符都有效.
5.	测纸传感器灵敏度参数修改.PNE_ENABLE允许处理纸张检测.
	修改纸尽检测,添加纸将尽检测.
6.	FlashErrorLed()修改.添加缺纸告警处理.
7.	Command_1B3D()修改,按照EPOSN TM-88V参数修改.
8.	SystemSelfTest()修改.打印开始前置忙,关接收中断.打印结束清忙,开接收中断.
9.	ReadFeedKey()修改.自检模式时不走纸.
10. ReadInBuffer()走纸根据是否连续纸还是黑标纸分别处理.
11. 修改以太网按键状态高低信号宏定义.两种板的相反.


程序版本:0.123
编写人员: 
编写日期:2012-11-02
1.	Command_1B3D()修改处理判断条件.
	ProcessCharMaskReadBuf()修改数据处理流程,确保禁止打印机时不处理输入待打印内容.
2.	SetGoLineSpace()修改,添加清零加热缓冲区.每次烧写程序后会出现打印内容全部为黑的问题.(SWJ)
	修改后还出现该现象.应该是SWJ软复位导致.去掉.
3.	DecInBufferGetPoint(),ClearInBuf(),PutCharToInBuffer(),ReadInBuffer(),DecInBufferGetPoint()中
	ReceiveInterrupt()开关接收中断相关的函数全部去掉.除了实时指令处理函数.缓冲区满时先置忙再关中断.
	修改后不再出现丢数现象.
	0.121版本测试也有丢数现象.


程序版本:0.127
编写人员: 
编写日期:2012-11-05
以0.123版本修改.
1.	Command_1B13()修改,当读入数据不为零时进行全流程处理,如果为0,只进行点阵列计数调整.
编写日期:2012-11-07
1.	Command_1B13()修改,行高点数赋值只在最左端处理一次.
		驱动打印还会有中途丢数问题.串口会一直打印完毕,中间乱码.USB接口时会中途停止打印.
2.	Command_1B2A()修改,当读入数据不为零时进行全流程处理,如果为0,只进行点阵列计数调整.
		Command_1D2F()修改,当读入数据不为零时进行全流程处理,如果为0,只进行点阵列计数调整.
3.	FillPrintBuff()修改.当处理的字节值不为零时才进行纵向放大.
编写日期:2012-11-09
4.	测试发现通过串口发送时出现数据丢失.串口发送了数据而单片机没有收到.
5.	InitNVIC()修改.通信配置为最高优先级.
	其次为加热电机控制定时器,机芯数据发送SPI,ADC数据SPI;
	再次为检查控制定时器.
	测试不再丢数.
6.	驱动打印测试打印效果更差.速度更慢.
7.	调整中断优先级.
	主优先级0:通信
	主优先级1:电机控制,SPI3,SPI1
	主优先级2:打印检查控制
	主优先级3:常规定时,周期性定时
8.	修改后驱动打印死机.
9.	恢复0.123版本的中断优先级设置.
10.	LatchHeatData()中去掉1us延时.
	GetHeatTime()中去掉*3操作.改为<<1.
	ReadInBuffer()修改.去掉驱动打印时等待处理.按键上纸部分程序改为与button按键相同.
11.	修改后串口驱动打印效果同0.123版本基本相同.



程序版本:0.128
编写人员: 
编写日期:2012-11-09
以0.127版本修改.
1.	调整中断优先级.
	主优先级0:通信
	主优先级1:电机控制
	主优先级2:打印检查控制,SPI3DMA
	主优先级3:ADCDMA,周期性定时,其他调试时常规定时,可能的按键
2.	修改后不打印.按键上纸无效.
3.	调整中断优先级.
	主优先级0:通信
	主优先级1:SPI3DMA,ADCDMA,
	主优先级2:电机控制
	主优先级3:打印检查控制,周期性定时,其他调试时常规定时,可能的按键
4.	修改后出现缺纸误报.
5.	调整中断优先级.
	主优先级0:通信
	主优先级1:SPI3DMA,ADCDMA,周期性定时,
	主优先级2:电机控制
	主优先级3:打印检查控制,其他调试时常规定时,可能的按键
6.	修改后打印正常,但是错误和缺纸指示灯经常报警.
7.	需要将常规性定时优先级提高.需要比电机控制优先级高.待测试.	


程序版本:0.129
编写人员: 
编写日期:2012-11-12
1.	调整中断优先级.
	主优先级0:通信
	主优先级1:周期性定时
	主优先级2:电机控制
	主优先级3:ADCDMA,	打印检查控制,	SPI3DMA,	其他调试时常规定时,可能的按键
2.	修改测纸传感器灵敏度.
3.	ADC_SampleTime_13Cycles5改为ADC_SampleTime_28Cycles5.
	暂不检查PNE_ENABLE.
	ADC转换结果经常报错.暂时屏蔽ADC处理.
编写日期:2012-11-13
1.	可以正常打印,但是条码和图形打印时速度太低.
2.	查看芯片输出与程序统计是否同步.如果不同步,添加芯片重新初始化.
	添加FEED_MOTOR_MONITOR_ENABLE及其他宏定义.
	添加输出步数统计.添加全局变量gbyFeedMotorStepCount和局部变量mbyDriveCycleStepNumber.
	DRV8811芯片HOME管脚在初始位置时输出为低,在其他位置时输出为高.
	InitFeedPort()添加变量初始化.
	FeedMotorQuarterStepDrive()等添加变量初始化.
	StepFeedMotor()修改.启用方向控制.根据方向改变gbyFeedMotorStepCount.
	读取HOME管脚值,与gbyFeedMotorStepCount值比较是否一致.
	HOME管脚状态	gbyFeedMotorStepCount值
		低					0,8(到8后变为0)
		高					1~7
	StartFeedMotor(),StopFeedMotor()启用方向控制.
3.	打印可以正常进行.
4.	将加热时间改为固定式.24V时60us加热时间合适.暂时改为固定赋值.
5.	调整中断优先级.
	主优先级0:通信
	主优先级1:周期性定时,	ADCDMA,
	主优先级2:电机控制
	主优先级3:打印检查控制,	SPI3DMA,	其他调试时常规定时,可能的按键
	ADC的中断优先级必须比TIM3,TIM4高.因为在TIM3,4中断处理中如果出现错误会进入等待不退出.
	而ADC如果不再进入中断则会一直保持错误变量不能更新.
	修改后打印正常.
6.	下一版本开始添加编写新的打印流程,将条码和图形按照循环方式逐点行打印.


程序版本:0.130
编写人员: 
编写日期:2012-11-13
目前的模式字符,图形和条码可以混合打印.
先修改条码打印.
1.	添加BARCODE_PRT_AS_BITMAP_ENABLE.
	PrintBarBitmap(),未完成.
	还是做为图形处理合适.将来可以用在二维条码方式.
	条码宽度超过允许区域则不打印条码部分.
2.	Command_1D77()修改.修改窄条宽度设置.
3.	GetMaxAccelerateSteps()去掉检测图形模式.
4.	Command_1B13()修改.尽量减少不必要的计算处理.尽量减少乘法运算.
5.	修改后打印顺畅,图形打印颜色浅.其他打印颜色正常.
6.	自检打印,使用调试工具打印均正常,没有丢数.打印字没有丢笔画.
	使用调试工具串口,以太网端口可以正常发送接收数据.


(((u16)(ReadInBuffer())) << 8)
程序版本:0.131
编写人员: 
编写日期:2012-11-14
1.	Command_1D2F(),Command_1D4C(),Command_1D57(),Command_1D2844(),Command_1D76(),
	Command_1D67(),Command_1C50(),Command_1B13(),Command_1B24(),Command_1B2A(),
	Command_1B5C(),Command_1B70(),ProcessBarCode_2D()修改,将乘除运算改为移位.
	Command_1D72()修改,尽量减少不必要的初始化变量.
	修改前:Program Size: Code=72370 RO-data=14214 RW-data=1236 ZI-data=44724
	修改后:Program Size: Code=72338 RO-data=14214 RW-data=1236 ZI-data=44724
	修改后打印正常.
2.	ADC_CONVERT_NUMBER改为4次.允许ADC中判断各种信号.
	信号判断正常.打印正常.
3.	分析炜煌热敏打印指令.
4.	Command_1B31(),添加1B31指令.设置行间距为n点行.
	Command_1B57()修改,添加标准模式下放大倍数设置.页模式下未处理.
	RealTimeCommand()修改.修改回传信息的端口判断.
	数据接收处理时一律先放入接收缓冲区,然后再判断是否是实时指令并操作实时指令结构.在常规定时中处理实时指令.
5.	驱动打印还会打印乱码.


程序版本:0.132
编写人员: 
编写日期:2012-11-14
1.	Command_16()修改.添加逐点行处理程序.
2.	GetMaxAccelerateStepsOfDrivePrint(),新添加.
	GetMaxAccelerateSteps()修改,添加检查驱动模式.
	MAX_RUSH_STEPS_ON_DRV_PRT由最大值改为68.在图形和驱动模式下为此速度.
3.	修改后RME3驱动可以打印,但是打印噪声太大,速度太低.
	MAX_RUSH_STEPS_ON_DRV_PRT改为100.改后表现差别不大.
	MAX_RUSH_STEPS_ON_DRV_PRT改为最大值.改后表现差别不大.
4.	使用SPRT的POS88驱动打印,前后多行内容混在一起.
	如果分次发送则打印正常.串口115200.
	如果缓冲区满后不停止接收中断,则打印速度更慢.
5.	Command_16()修改.调整各个步骤先后.
6.	调试发现TIM4定时器一直被使能没有被关闭.
	需要进一步调整TIM4的自动延时值设置.


程序版本:0.133
编写人员: 
编写日期:2012-11-14
调整TIM4延时设置.
1.	PrintLineBuffer()修改.空闲状态时关闭TIM4.
	驱动打印速度提高了,但是中间出现死机.
2.	LINE_PRT_BUF_CHECK_INTERVAL_US改为10.
	SetTimerCounter(PRINT_CHECK_TIMER, 1);一律改为
	SetTimerCounter(PRINT_CHECK_TIMER, LINE_PRT_BUF_CHECK_INTERVAL_US);
	去掉空闲状态时关闭TIM4处理.
	驱动打印速度变得很慢.中间死机电机一直加电.
	条码和字符打印不受影响.
3.	恢复空闲状态时关闭TIM4处理.
	驱动打印速度变得很慢.中间死机电机一直加电.
	条码和字符打印不受影响.
4.	PrintOneLine()修改.复制结束后根据打印内容是否为空白来设置打印状态阶段值.
	如果编辑缓冲区为空白且不打印下划线,直接走行间距;否则从等待打印开始.
	修改后驱动打印大部分打印出来,中间出现死机.
5.	LINE_PRT_BUF_CHECK_INTERVAL_US改为1.
	SetTimerCounter()修改.当为TIM4时,延时设置为1,自动重载值设置为8倍值.
	修改后不理想.
6.	LINE_PRT_BUF_CHECK_INTERVAL_US改为5.
	SetTimerCounter()不修改.
	PrintOneLine()修改.当无打印内容时,不需要复制,直接设置走行间距.否则按原流程.
	空闲状态时关闭TIM4.
	字符条码打印正常,驱动打印死机.
7.	LINE_PRT_BUF_CHECK_INTERVAL_US改为5.
	空闲状态时不关闭TIM4.
	字符条码打印正常,驱动打印不死机,但是打印特别慢.
8.	LINE_PRT_BUF_CHECK_INTERVAL_US改为10.
	驱动打印不死机,但是打印特别慢.打印结果都是空白.
	还需要进一步调试.


程序版本:0.134
编写人员: 
编写日期:2012-11-15
ErrorDetect()调整
1.	LINE_PRT_BUF_CHECK_INTERVAL_US改为1.
2.	PrintOneLine(),GoDotLine()中去掉错误检测部分ErrorDetect()的处理.
	StepFeedMotor(),修改ErrorDetect()的处理,如果有错误,保护后直接退出.设置任务未完成标志.
	SystemTimer2Func(),添加ErrorDetect()的处理,如果错误解除且有未完成的任务,重新启动.
	只有在StepFeedMotor()中才调用ErrorDetect(),如果有错则停止TIM3,TIM4,置gbyFeedTaskFlag=1并退出;
	只有在TIM2中才调用ErrorDetect(),如果无错且gbyFeedTaskFlag==1则启动TIM3,TIM4并置gbyFeedTaskFlag=0.
	空闲状态时关闭TIM4.
	加热时间计算改为计算方式.
3.	修改后先打印字符和条码,打印正常.1B76指令返回值经常变化.
	再使用SPRT的POS88驱动可以打印,部分内容打印错误.打印过程中经常出现停顿.
	如果先打印驱动,中间出现死机.
4.	空闲状态时不关闭TIM4.
	驱动打印效果同133.
5.	测试过程中发现1B76返回值错误.有纸情况下回发缺纸.
	Command_1B76()修改,只有串口才回复.
	DMA1_Channel1_ADFunc()修改,每10次累加后取平均.
	空闲状态时关闭TIM4.
	修改后测试1B76,回复结果还是错误.
6.	ADC_CONVERT_NUMBER改为1.
	修改后测试1B76,回复结果还是错误.
7.	错误结构变量改为volatile.
	修改后测试1B76,回复结果还是错误.
8.	PutCharToInBuffer()关闭实时指令填充后,1B76回复全部正常.
9.	使用SPRT的POS88驱动可以打印,部分内容打印错误.打印过程中经常出现停顿.最后死机.
10.	StepFeedMotor(),SystemTimer2Func()关闭错误检测处理相关程序.
	打印驱动,中间出现死机.
11.	空闲状态时不关闭TIM4.
	打印驱动,中间出现死机.
12.	空闲状态时关闭TIM4.
	StepFeedMotor(),SystemTimer2Func()打开错误检测处理相关程序.
	PrintOneLine()修改.如果不需要走行间距,则无需考虑行打印缓冲区状态,直接退出.
	只有需要拷贝时才检查行打印缓冲区状态.
	修改后打印驱动,中间出现死机.大部分都打印正常.打印停顿.
13.	空闲状态时不关闭TIM4.
	修改后打印驱动速度特别慢.
14.	空闲状态时关闭TIM4.ReleaseEmergencyProtect()修改.根据标志判断是否需要启动TIM4.
	驱动打印无改善.
15.	StartPrintLineBuf()修改.关闭启动TIM4.因为在处理过程中会被启动.
	DMA1_Channel1_IRQHandler()修改.去掉多余的操作.全部操作在DMA1_Channel1_ADFunc()中实现.
	StartHeatAndRotateMotor()修改.无论何种情况先关闭TIM4.如果加热未完成,计算加热时间后不再启动TIM4.
	驱动打印无改善.条码打印中间有拉开现象.
16.	只有空闲状态时不关闭TIM4打印条码才不会出现断行.
17.	GetHeatTime()不使用双倍值.打印浓度稍淡.
18.	Command_16()修改.等待上一点行结束时调用WaitHeatAndFeedPaperFinish().
	PutCharToInBuffer()不处理实时指令.
	驱动打印无改善.


程序版本:0.135
编写人员: 
编写日期:2012-11-16
1.	DMA1_Channel1_ADFunc()关闭错误检测及错误信号更新.
	SystemTimer2Func()只处理打开ADC.
	PutCharToInBuffer()不处理实时指令.
	StepFeedMotor()不处理错误检测.
	修改后SPRT驱动打印效果还是不理想.
2.	Command_16()修改.添加处理一行时间检测.
	main()修改,添加定时器1初始化.
	TIM1中断优先级改为主1从2.
	main()添加RX_FLAG_TIM分频设置.
	InitNVIC()添加RX_FLAG_TIM优先级.
3.	测试发现每处理1点行需要时间平均为500us.


程序版本:0.136
编写人员: 
编写日期:2012-11-16
1.	测试16处理过程中是否会发生接收缓冲区满的情况.
	测试发现在处理第一条16指令之后接收缓冲区已经发生满溢出.早超过4096的范围了.
	在处理第一条15之后接收缓冲区已经发生满溢出,超出了3840的警戒值.
	在处理过程中远远超过接收缓冲区允许的范围.
2.	ReceiveInterrupt(),修改串口中断允许禁止函数.
	仿真发现还会溢出.
3.	ReadInBuffer()不处理打开接收;
	PutCharToInBuffer()存数前先判断位置指针是否超出再存储;
4.	ReadInBuffer()处理打开接收;
	修改后使用非虚拟串口115200带硬件判忙SPRT和WH驱动都可以打印.但是打印速度很慢.断断续续.
5.	自检打印,使用调试工具打印均正常,没有丢数.打印字没有丢笔画.
	使用调试工具串口,以太网端口可以正常发送接收数据.


程序版本:0.137
编写人员: 
编写日期:2012-11-19
1.	收完再打间隔设置为50ms,接收缓冲区变量长度改为2字节.
2.	JudgeLineBufFull()修改.字符时宽度计算添加左间距.
3.	FillPrintBuff()修改.处理右间距之前先判断是否可以放下右边距再处理,放不下则不处理.
4.	PrintBarHRI()修改,打印字符大小与放大倍数设置无关.
	测试通过.
5.	ReadInBuffer()中关闭驱动模式时等待50ms或者缓冲区满的处理.修改后打印效果同前.浓度稍淡.
	修改驱动打印时最高限速为68步.修改后打印效果同前.
	修改驱动打印时最高限速为28步.修改后打印效果同前.
编写日期:2012-11-20
1.	调整中断优先级.
	主优先级0:通信
	主优先级1:周期性定时,	ADCDMA,	SPI3DMA,
	主优先级2:电机控制
	主优先级3:打印检查控制,	其他调试时常规定时,可能的按键
2.	ReadInBuffer()中打开驱动模式时等待50ms或者缓冲区满的处理,等待时间增长到100ms.
	修改后打印过程中会完全停止.最终打印结果是预期的.最后的切刀没有执行.
	关闭该修改.
3.	编写测试程序,比较总接收字节数和总读取字节数,读取字节数比接收字节数少36.
	而此时标志剩余字节数的变量已经变为0.
4.	ReadInBuffer(),DecInBufferGetPoint(),PutCharToInBuffer()修改,
	修改gstructInBuf.BytesNumber时先关闭中断再打开中断.
	测试发现,比较总接收字节数和总读取字节数,读取字节数比接收字节数少26.
	而gstructInBuf中标志接收和读取数据的变量,读取字节数比接收字节数少27.
	而修改后打印等待的时间明显加长了.
5.	DecInBufferGetPoint()修改,修改前先置忙,关中断;修改后再清忙,开中断.
	ReadInBuffer(),PutCharToInBuffer()修改,修改gstructInBuf.BytesNumber时不处理中断.
	修改后出现的差距加大.
6.	DecInBufferGetPoint()修改,不处理忙信号和中断.
	测试发现,比较总接收字节数和总读取字节数,读取字节数比接收字节数少32.
7.	测试发现问题出在接收和处理字符上.
8.	自检打印,使用调试工具打印均正常,没有丢数.打印字没有丢笔画.
	使用调试工具串口,以太网端口可以正常发送接收数据.
9.	以太网接口串口波特率最高1M,2M,使用调试工具以太网发送少量数据
	(2000多字节)打印正常,数据量大时(4000多字节)不正常.


程序版本:0.144
编写人员: 
编写日期:2012-11-30
以0.137修改.从0.138版本开始实际打印不正常.0.143版本可以打印但是有缺失的地方.
1.	stm32f10x-conf.h中关闭USE_FULL_ASSERT.
2.	InitInbufParameter()修改.
3.	PutCharToInBuffer()中处理忙和关中断.实时指令有效.
4.	ReceiveInterrupt()修改.根据接收源关闭中断.
	SystemTimer2Func()中处理实时指令,自动返回,上盖检查等.
	DMA1_Channel1_ADFunc()恢复缺纸等信号的判断处理.
	网口驱动打印接收到字符和处理的字符数目不一致.


程序版本:0.145
编写人员: 
编写日期:2012-12-1
1.	修改ReadInBuffer()中取数和更新变量,处理开关中断和忙.
2.	以太网串口波特率设置为1M.
	使用打印调试程序,一次发送20,200,800,2000字节,
	通过串口,以太网三种方式1次发送2000字节内容,都没有出现接收和处理不一致.
	当缓冲区满时会停止接收.
3.	程序调试过程中死机,目前版本USB测试不正常.


程序版本:0.146
编写人员: 
编写日期:2012-12-3
以0.144版本修改.
1.	修改ReadInBuffer()中取数和更新变量,处理开关中断和忙.
2.	以太网串口波特率设置为1M.
	加热时间*1.5.
3.	使用打印调试程序,通过串口,USB,以太网三种方式1次发送2016字节内容,
	都没有出现接收和处理不一致.
4.	使用调试工具,串口115200循环发送驱动打印内容,中间会出现错误.
	使用SPRT驱动网口打印自检,除了刚开始的半个windows徽标外,其他内容一律不打印.
	不停地在接收打印数据.


程序版本:0.147
编写人员: 
编写日期:2012-12-3
1.	StepFeedMotor()恢复错误信号检查及任务未完成时出错标志设置.
2.	SetUSBPort()检查.HD的电源输入控制端口宏定义错误.
3.	PowerOn(),PowerOff()宏定义改为HeatPowerOn(),HeatPowerOff().修改对应调用的地方.
4.	使用USB驱动打印不正常.只打印一小部分.
	使用调试工具打印中间会有白道.
5.	去掉FEED_MOTOR_MONITOR_ENABLE.
	基本效果不变.打印时有突突突的感觉.
6.	StepFeedMotor()关闭错误信号检查及任务未完成时出错标志设置.
	打印效果同5.


程序版本:0.148
编写人员: 
编写日期:2012-12-3
以0.137版本修改.
1.	ReceiveInterrupt()修改.根据接收源关闭中断.
	加热时间*2.
	调试工具串口打印很流畅.
2.	PutCharToInBuffer()中实时指令有效.
	SystemTimer2Func()中处理实时指令,自动返回,上盖检查等.
	调试工具串口打印很流畅.
3.	DMA1_Channel1_ADFunc()恢复缺纸等信号的判断处理.
	调试工具串口打印很流畅.
	但是会出现接收和处理字节数目不一致的错误.
4.	ReadInBuffer()中修改取数和更新变量,处理开关中断和忙.
	以太网串口波特率设置为1M.	
	调试工具串口打印很流畅.不会出现接收和处理字节数目不一致的错误.
5.	StepFeedMotor()恢复错误信号检查及任务未完成时出错标志设置.
	SystemTimer2Func()中处理打印出错时的恢复.
	调试工具串口打印出现停顿现象.
6.	StepFeedMotor()关闭错误信号检查及任务未完成时出错标志设置.
	调试工具串口打印不再出现停顿现象.
7.	SetUSBPort()检查.HD的电源输入控制端口宏定义错误.
8.	PowerOn(),PowerOff()宏定义改为HeatPowerOn(),HeatPowerOff().修改对应调用的地方.
	调试工具串口打印很流畅.
9.	问题出在错误检查部分,打印中间出现错误停止打印,然后错误消除后又重启打印导致.


程序版本:0.149
编写人员: 
编写日期:2012-12-4
ErrorStruct.R_ErrorFlag恒为0,
ErrorStruct.PaperSensorFlag在DMA1_Channel1_ADFunc()中修改纸尽和纸将尽位.
ErrorStruct.UR_ErrorFlag在DMA1_Channel1_ADFunc()中修改过压,欠压,打印头温度位.
ErrorStruct.AR_ErrorFlag在DMA1_Channel1_ADFunc()中修改温度相关位,
	在SystemTimer2Func()中修改纸仓盖检测位.
1.	调试发现UR_ErrorFlag值为0x04时停止住.为欠电压错误.
	gstructAD.Power_ADC_Value = 2259,换算电压值为20V,实际为24V.
2.	将每通道转换次数从1改为10.
	修改后测试打印没有再出现以上问题.
3.	添加钱箱端口初始化,修改Command_1B70().开完之后等待一段时间就关闭.
	因没有接口符合的钱箱,暂时无法测试.
4.	目前程序USB和以太网口用测试工具可以正常打印,
	用驱动程序USB打印最开始一小段后不再打印,无反应;驱动接收到3968字节后死机.
	用驱动程序网口打印一直打印汉字"览",错误.


程序版本:0.150
编写人员: 
编写日期:2012-12-5
修改USB相关的程序.用POS58V的USB部分程序替代.
1.	USB驱动库换为2.20版本.
2.	Printer_USB文件换为POS58V的USB文件.
	USB库编译无法通过,头文件中宏定义各个库版本不同.
3.	USB驱动库换为3.30版本.
	USB库可以编译通过.
4.	添加一系列头文件包含,去除在头文件中定义变量,修改硬件管脚的不同.
	修改函数名称不同,添加新函数.
	编译通过.
5.	修改后USB驱动打印效果同0.149.调试工具打印正常.
6.	将USB忙和禁止中断接收关闭.
	驱动打印效果同之前.接收数据到3968字节即不再接收.
7.	使用调试工具发送驱动打印内容,接收到3904字节后就死机.
8.	将所有与USB相关处的置忙和开关中断都关闭.
	驱动打印效果同之前.接收数据到3968字节即不再接收.
编写日期:2012-12-6,7
9.	增加接收缓存,驱动打印还是会死机.
10.	修改接收函数和读数存数的流程处理.
11.	USB置忙改为SetEPRxStatus(ENDP2, EP_RX_NAK).
12.	修改后USB驱动打印没有丢数.


程序版本:0.151
编写人员: 
编写日期:2012-12-7
以版本0.149修改.
1.	PrintBarCodeType()只打印一维条码信息.
2.	USB置忙改为SetEPRxStatus(ENDP2, EP_RX_NAK).
3.	PRINTER_Out()修改存数完毕后判断缓冲区是否已满及其响应处理.
4.	InitInterfaceParameter()修改,只清零并口标志.
5.	PutCharToInBuffer()修改,存数前先判断下标是否越界,不越界才进行
	保存和处理数据数目.缓冲区如果已满则只进行置忙处理,不关闭中断和置忙.
6.	ReadInBuffer()修改.
7.	串口相关的中断处理程序处理.存完数后判断是否已满并决定是否置忙.
8.	通信中断始终不关闭.如果有需要时关闭后处理完毕立即打开.
9.	测试串口驱动打印无丢数,正常.
	测试USB口驱动打印无丢数,正常.


程序版本:0.152
编写人员: 
编写日期:2012-12-7,10
处理以太网打印问题.
1.	以太网使用调试工具,一次发送100,200,400,800字节测试接收和处理打印正常.
2.	以太网使用调试工具,一次发送1600,3200字节测试接收和处理打印正常.
3.	以太网使用调试工具,一次发送6400字节测试接收和处理正常.打印中间电机走不动.
4.	以太网使用调试工具,一次发送12800字节接收处理了9984字节.打印中间电机走不动.
	调试工具最多可读取的内容即为9984字节.
5.	以太网使用调试工具,一次发送7200字节测试接收和处理正常.打印中间电机走不动.
	非调试模式下打印正常,没有出现中间电机走不动的现象.
6.	以太网使用调试工具,连续两次发送7200字节测试接收和处理正常.
	非调试模式下打印正常,没有出现中间电机走不动的现象.
7.	使用SPRT POS886驱动打印死机,电机一直加电.
8.	ETH_USART_Config(),修改各个串口中断处理,合并处理各种模式下的共同操作.
9.	关闭实时指令填充.
	通信中断关闭打开根据端口判断.
	读数中按键检测放到一个本地函数中.
10.	使用与打印机端USART3接口打印,数量少时没问题,多时就会出现打印机端不停地接收的错误.
11.	改用与打印机端USART1接口打印,115200波特率打印正常,驱动打印正常,无丢数多数.
	改用1M波特率,发送数据量少时没有问题,驱动打印方式或者数据量多时打印乱码,数据接收和处理无问题.
12.	串口端口最高速度由10M改为50M.
	修改后1M波特率打印效果同上.误码率接近50%.
13.	钱箱使用实时指令实现.
	测试通过.
2013-1-18测试:
用USART1接NET端PC串口,使用115200确实可以打印SPRT网口驱动.
配合的NET软件是0.05版本.按照LM3S6432使用.NET使用微库编译.


程序版本:0.153
编写人员: 
编写日期:2012-12-11
1.	改用最高波特率500K测试驱动打印,误码率有所降低.误码率接近10%.
2.	改用最高波特率250K测试驱动打印,测试打印正常,无误码,无丢数.
3.	改用最高波特率400K测试驱动打印,误码率接近50%.
4.	改用最高波特率300K测试驱动打印,测试打印正常,无误码,无丢数.但是打印效果不如250K.
5.	确定选用最高波特率250K.
6.	串口最高速10M,调整文字布局.
7.	读数时驱动模式时添加等待50ms.
	驱动打印没有丢数,但是串口打印效果不佳,有压缩,USB口驱动打印效果良好.
8.	读数时驱动模式时等待150ms.
	驱动打印没有丢数,但是串口打印效果不佳,无压缩,USB口驱动打印效果良好.
9.	去掉延时,串口驱动打印效果不佳,中间空白点行增多.
10.	GetMaxAccelerateSteps()修改,根据不同的通信端口限制驱动打印最高速度.
	串口加速:2
	网口加速:4
	测试串口打印会乱码.
11.	串口加速:20
	打印无乱码,噪声大.
12.	串口加速:10
	打印无乱码,噪声有减少.
13.	读数时驱动模式时添加等待50ms.
	打印无乱码,中间有突突声,白道减少为只有几道.
14.	读数时驱动模式时添加等待200ms.并判断剩余字节数是否大于2400.
	打印时平稳,有一行乱码,有两行压缩.
15.	判断剩余字节数是否大于3000.
	打印时平稳,乱码增多,有错行.效果比14变差.
16.	判断剩余字节数是否大于1824.
	打印徽标部分错行乱码,其他部分正常.
17.	延时等待改为100.
	乱码增多,效果变差.
18.	延时等待改为300.
	打印平稳.打印徽标部分错行乱码,其他部分正常.
19.	判断剩余字节数是否大于2800.
	打印平稳.打印徽标部分错行乱码,其他部分正常.
20.	判断剩余字节数是否大于1024.
	打印有乱码.
21.	延时等待改为100.判断剩余字节数是否大于1024.
	徽标部分有两行乱码,其他正常.
22.	延时等待改为150.判断剩余字节数是否大于2048.
	效果不如21.
23.	延时等待改为150.不判断剩余字节数目.限速50mm/s.
	乱码太多.
24.	延时改为50.
	还是不行.
25.	去掉等待.
	有错行,有乱码.
26.	串口加速:20,等待50.
	无丢数,无错行,电机突突,中间白道多.
27.	串口加速:10,等待50.
	串口无丢数,无错行,中间白道减少.
	网口驱动不打印(USART3).
28.	串口加速:10,等待100.
	串口打印乱码.
29.	串口加速:10,等待20.
	串口打印正常,有一些白道.效果尚可.
30.	串口加速:6,等待20.
	打印平稳,但是乱码.
31.	去掉等待.
	打印平稳,但是乱码.
31.	串口加速:6,等待50.
	打印平稳,但是乱码.
32.	串口暂时选用串口加速:10,等待50.
33.	只有串口和网口才等待,U口不等待.
	U口限速108打印正常,电机突突.
	U口限速152,有轻微压缩.
	添加延时50ms,打印正常,电机噪声大.
	U口限速89.打印平稳,效果良好.
2013-1-15回归测试:
SPRT驱动U口接收字符数:	97610
SPRT驱动S口接收字符数:	96067
SPRT驱动E口接收字符数:	下标越界
2013-1-18回归测试:
使用USART1与NET端接PC串口,NET0.05版本SPRT驱动E口可以打印.


程序版本:0.154
编写人员: 
编写日期:2012-12-17
1.	修改外接口板检测定义及方法.
	根据CHECK_IN端外接电阻方法决定三种外接口板,CHECK_OUT端不焊接.
	只焊接对地下拉电阻时表示只有网口和USB口.
	只焊接对电源上拉电阻时表示只有串口和USB口.
	只焊接IN和OUT连接电阻时表示只有并口.
	按照新原则修改checkif.h和checkif.c的内容.已修改.
2.	端口初始化和中断初始化及中断处理程序中均根据端口类型进行.
	未修改.
3.	添加并口驱动模块.并口驱动需要实现的功能有:
	端口初始化:8位并口数据口,ACK,PE,BUSY,STB初始化;
	并口中断初始化;
	并口中断处理函数;
4.	添加并口中断处理函数.
	EXTI0_IRQHandler()处理.添加完毕.
5.	添加并口端口初始化处理.
	InitParallelDataPort(),InitParallelCtrlPort()添加完毕.
	添加ACK,PE,BUSY,读数等一系列处理函数.添加完毕.
6.	添加并口中断初始化处理.
	InitNVIC()修改完毕.
7.	修改初始化部分的程序.调整初始化流程.
	InitGPIO()修改.只包含所有共用的端口初始化内容.名称改为InitCommonGPIO().
	InitStdPeriph()修改.添加包括初始化.根据端口初始化.
	InitPrtCtrlResetEthernetPort()添加.
	SetComInBufBusy(),ClearComInBufBusy(),ReceiveInterrupt()添加并口处理.
8.	添加RELEASE版本正式处理程序.编译通过.
	测试发现有错误.
9.	修改机芯SPI初始化顺序,测试通过.
10.	将上电检测工作状态部分的程序放到新函数ProcessModeType()中.
11.	修改normal.c文件.正式程序与DEBUG的RELEASE版本相同.
	简化debug.c的头文件包含,去掉不必要的.
12.	目前程序测试COM,USB,ETH三种方式通过命令和驱动方式打印都正常.
13.	PrintModel()修改.
	基本型号P04,根据端口检测结果附加其他.
	PrintInterfaceType()修改.添加并口.
	SystemSelfTest()修改.根据端口检测结果打印端口信息.
	PrintParallelParameter(),PrintUSBParameter(),PrintEthParameter()添加.
	测试通过.自检时出现打印中间停顿,打印白道的错误.
从下一个版本开始添加下载位图等图形打印处理.


程序版本:0.155
编写人员: 
编写日期:2012-12-18
需要实现指令:打印光栅位图Command_1D76(),
1.	Command_1D76()修改.使用新函数实现.作为驱动打印.
2.	PrintOneDotLine(),CopyDotLineDataToHeatElementBuf(),
	SendHeatElementBufToCore()添加.
3.	测试通过.四种参数测试.
	结合左边距设置测试通过.
	测试图像内容从不满缓冲区到横向和纵向分别/同时超过缓冲区,全部通过.
4.	Command_16()打印点行改为使用PrintOneDotLine().
	测试SPRT驱动打印通过.
	炜煌驱动打印没有通过.乱码.



程序版本:0.156
编写人员: 
编写日期:2012-12-18
1.	添加打印可变高度位图指令1D5130.
	基本测试通过.有待进一步测试.
编写日期:2012-12-19
2.	1D5130指令添加修改倒置模式对齐无效.
	测试高度字节小于12的测试通过.
	目前程序为处理高度小于13的,高度大于12的还需要添加处理.


程序版本:0.157
编写人员: 
编写日期:2012-12-19
1.	1D5130指令高度字节数最大值改为12.
	因为数据是连续的一次性的,目前的打印缓冲区最大为24字节高,
	所以在放大两倍的情况下超过12的无法处理.
	如果最大值为16,那么只能限制纵向放大倍数.
	测试通过.
下面处理预下载位图存储和打印指令.
2.	spiflash.h修改,添加命令和参数宏定义.
	spiflash.c,添加扇区擦除,块擦除和全片擦除函数.一次擦除4K,64K,4M.
	sFLASH_EraseSector(),sFLASH_EraseBlock(),sFLASH_EraseAllChip().
3.	Command_1C71()添加.定义NV位图.
	添加NV位图相关的宏定义.添加类型定义.
	有待测试.
4.	TypeDef_StructRealTime修改.添加使能标志.
	SystemTimer2Func()修改.添加实时指令是否处理根据是否使能判断.
	InitRealTimeStructParameter()修改.添加实时指令使能初始化.
5.	有待测试.



程序版本:0.158
编写人员: 
编写日期:2012-12-20
1.	Command_1C70()添加.打印预定义NV位图.
2.	Command_1C71()修改错误.
3.	Command_1D51()变量定义数据类型修改.
4.	测试打印无反应.
5.	编写测试程序.测试擦除及写入效果.
	UpLoadData()修改,串口回传时添加延时.
	测试发现写入控制参数值读回均为0.写入错误.
	测试发现NV图形数据读出全部为FF.与写入时的值不一致.
6.	DMA2_Channel2_IRQHandler()修改,先等待上一点行数据完全发送完毕.
	打印效果无改善.最右边一个字符还是有些缺笔.
7.	temp.h中去掉外部函数声明.
	相关的setcommand.c,esc.c,gs.c,selftest.c中添加缺少的头文件包含.


程序版本:0.159
编写人员: 
编写日期:2012-12-21
1.	添加1E系列测试函数.自定义函数.
	1E01()添加,测试扇区擦除,4K,单字节写入,随后单字节读回回传,一致.
	测试扇区擦除,4K,单字节写入,所有全部写完后再单字节读回回传,一致.
2.	1E03(0,1E04()添加.
	测试扇区删除,再读回发现没有真正删除.
3.	测试扇区删除,读回发现工作正常.
4.	测试1C70(),1C71()通过.
	原1C71()写入位图数据时地址变量引用错误.
	另外使用页擦除实现时,可能会将最后一页的内容擦除掉.
5.	测试数据存储正确.但是打印内容高度超过1列时乱码.


程序版本:0.160
编写人员: 
编写日期:2012-12-21
1.	1C71()擦除改用块擦除.
2.	1C70()修改读数的地址计算.原计算错误.
	测试通过.
	单独定义一副位图和同时定义两幅位图均测试通过.


程序版本:0.161
编写人员: 
编写日期:2012-12-21
1.	GetAscIIFlashDotData()修改国际字符读取的地址错误.
	国际字符12*24点阵测试通过.
	国际字符9*24点阵测试通过.
	字库中国际字符0的第2个字符点阵错误.应该为$,字库中为￥.需要修改字库.
2.	测试代码页.
	两种点阵测试通过.
	还缺少某些国家语言.需要填充.


程序版本:0.162
编写人员: 
编写日期:2012-12-24
编写可靠性测试相关的程序.
1.	测试debug/normal/reliability三种情况下的编译,均通过.
2.	添加reliabe.h文件.添加宏定义,文件声明.
3.	PrintReliabilityTitle(),修改可靠性打印部分.
	PrintBarCodeType(),二维码打印信息条件编译.
	SystemSelfTest(),添加可靠性测试打印内容.最后是否切纸改为条件编译.
	InitNVIC(),添加可靠性定时器中断优先级条件编译.使用BACKUP_TIMER.
	InitStdPeriph(),修改BACKUP_TIMER预分频的条件编译.
	TIM5中断处理函数修改,添加可靠性打印的条件编译.
	PrintReliabilityTitle()放到reliable.c.不再放到自检公共程序中.
4.	reliable.h和.c文件中添加可靠性2,5,20分钟测试相关的宏定义和函数.
	测试通过.


程序版本:0.163
编写人员: 
编写日期:2012-12-24
编写可靠性测试相关的程序.
1.	编写50KM测试相关程序.
	目前程序在处理存储参数的Index时算法有待调整.目前的有问题.
编写日期:2012-12-25
2.	修改mReliableStoreIndex定义含义.返回值代表有效参数个数.
	实际最后一个有效值存储地址计算时按照mReliableStoreIndex-1计算地址.
	当为1024时表示已满,擦除空白后从0位置存储,mReliableStoreIndex变为1.
	mReliableStoreIndex总是代表可以直接存储的第一个空白可写入的地址序列号.
	GetReliableTestParaStoreIndex(),GetReliableTestStoreValue()均修改.
3.	测试50Km通过.


程序版本:0.164
编写人员: 
编写日期:2012-12-25
编写可靠性测试相关的程序.
1.	编写切刀可靠性测试程序.
	测试通过.


程序版本:0.165
编写人员: 
编写日期:2012-12-25
编写可靠性测试相关的程序.
1.	将打印内容提取成公共函数.
	添加快速测试程序.
	逐个测试所有2,5,20分钟,50Km,切刀程序.
	测试全部通过.


程序版本:0.166
编写人员: 
编写日期:2012-12-25
测试杜德强转换的字体.
1.	GetAscIIFlashDotData()修改.
	添加测试代码页相关的程序.
	添加新文件codepage.c,添加两种字体的变量定义.
	innerFLASH_ReadBuffer()添加,从内部FLASH中读数.
	GetAscIIFlashDotData()修改.
2.	Command_1B4D()修改.去掉PrtCtrlData的修改.
	测试成功.


程序版本:0.167
编写人员: 
编写日期:2012-12-25
1.	DMA2_Channel2_IRQHandler(),sHeat_Init()修改.
	修改SPI_CPHA=SPI_CPHA_1Edge,测试打印效果无改善.
	修改默认空闲电平为低,测试打印效果无改善.
	SPI_CPOL=H,SPI_CPHA=2Edge,测试打印效果无改善.
2.	SPI_CPOL=H,SPI_CPHA=2Edge,根据手册看,该种组合是合适的.
	sHeat_Init()初始化时送出80个0字节,
	DMA中送出81个字符.
	测试打印效果无改善.
3.	BYTES_OF_LEFT_EMPTY_HEAT_ELEMENT改为3.
	测试打印效果无改善.
4.	DMA中送出80个字符.
	BYTES_OF_LEFT_EMPTY_HEAT_ELEMENT改为0.
	测试打印效果无改善.
	从最左边第一点可以打印.
5.	BYTES_OF_HEAT_ELEMENT改为80.
	BYTES_OF_RIGHT_EMPTY_HEAT_ELEMENT改为0.
	测试打印效果无改善.
	从最左边第一点可以打印.但是只打印了47个字符.
	看来问题不是SPI发送的原因.而是处理过程中只处理到此处就认为本行已满.
6.	JudgeLineBufFull()有问题.
	修改一行满的判断条件.
	修改之后一行满处理正确了.但是还会有最右端几列的内容没有被打印出来的错误.
7.	再处理打印中间会断行的问题.
	添加测试检查错误处理的宏定义.对应修改电机和TIM2中断的错误处理程序.
	打印时不再出现中间拉开的现象,但是感觉电机突突突跳动.打印一行过程中出现了电机停止的问题.
8.	DMA2_Channel2_IRQHandler()去掉检查是否传输完毕的处理.
9.	ProcessMotor()添加统计打印中停止次数的程序.
	测试发现,每打印一行过程中都停止了一次.相当于每行都是重新开始.
10.	CheckHeatAndFeedFinish()改为WaitHeatAndFeedFinish().
11.	Command_1D56()修改,去掉切纸前的检测上纸是否结束的操作WaitFeedPaperFinish().
	CheckFeedButton(),ReadFeedKey(),CutPaperAfterPrint()修改,
	去掉上纸前的检测上纸是否结束的操作WaitFeedPaperFinish().
	因为上纸用的GoDotLine(),切纸用的DriveCutPaper()中都有检测上纸是否结束的操作.
12.	GoDotLine(),DriveCutPaper()修改,之前判断走纸是否完成时还需要判断打印缓冲区状态是否为空闲,
	改为只判断走纸和加热是否完成.
	添加WaitPreviousPrintFinish().
13.	CheckFeedButton(),ReadFeedKey(),PrintOneDotLine(),
	修改WaitHeatAndFeedPaperFinish()改为WaitHeatAndFeedFinish().
	SystemSelfTest(),去掉WaitHeatAndFeedPaperFinish().
13.	while (GetPrintStatus() != LINE_PRT_BUF_STATUS_ILDE);全部改为
	WaitPreviousPrintFinish();
14.	结果还是会停止5次.
15.	130版本可以顺畅打印.
16.	StartPrintLineBuf()修改,最后退出前启动打印检查定时器.
	结果还是会停止5次.
	打印定时器处理,检查打印和加热上纸定时器处理,内容与130版本相同.
17.	测试发现从154版本开始出现该问题.153版本之前正常.
18.	2012-12-26回归调试154版本:
	当编译时选用microLIB时,编译出来的程序打印中间有白道,去掉则正常!
	154版本以下全部存在该现象.所以不能使用microlib.
	153版本不使用微库,表现正常.


程序版本:0.168
编写人员: 
编写日期:2012-12-26
1.	PrintString("\r\n")全部改为PrintString("\n").
	\r\n改为\n.
编写日期:2012-12-27
2.	添加测试上纸电机停止次数的测试.
	CUT_OFFSET改为21mm,NO_CUT_OFFSET改为24mm.
3.	回归测试.
	测试串口115200发送汉字,发送ASCII字符打印均正常.
4.	打印方向测试:
正向打印+纵横放大1倍+下划线2点+左中右对齐 : 
	汉字 + ASCII 12*24字符测试正常.
倒置打印+纵横放大1倍+下划线2点+左中右对齐 : 
	汉字 + ASCII 12*24字符测试正常.
5.	反显测试:
正向打印+纵横放大1倍+下划线2点+左对齐+反显打印 : 
	汉字 + ASCII 12*24字符测试正常.可以考虑反显打印时降低打印速度.
倒置打印+纵横放大1倍+下划线2点+右对齐+反显打印 : 
	汉字 + ASCII 12*24字符测试正常.可以考虑反显打印时降低打印速度.
6.	放大指令测试:
1B 55 n测试正常.
1B 56 n测试正常.
1B 57 n测试正常.
1B 58 m  n测试正常.目前无此条指令.
7.	Command_1B55(),Command_1B56(),Command_1B57()修改.
	当参数为0或者超过最大范围时不处理.
8.	混合测试:
正向打印+纵横放大1倍+下划线2点+右对齐+正常打印+条形码(设置宽度,高度,打印字符内容位置) : 
	汉字 + ASCII 12*24字符 + 条码 + HRI 测试正常.
倒置打印+纵横放大1倍+下划线2点+右对齐+正常打印+条形码(设置宽度,高度,打印字符内容位置) : 
	汉字 + ASCII 12*24字符 + 条码 + HRI 测试正常.
9.	测试国际字符:
正向打印+纵横放大8倍+下划线2点+左对齐+正常打印+选择国际字符:
	全部国际字符打印正常.
10.	设置左边界:
	测试有问题.
	Command_1D4C()修改.添加对PrtCtrlData.PrtWidth的修改.
	当设置左边距剩余空间不足1个字符时,打印1个字符.
	当设置左边距超过最大空间时,打印时本不该继续打印,但是实际打印出1个字符的乱码.
	有待修改字符满判断及填充处理处的程序.
11.	CutPaperAfterPrint()前增加等待加热上纸结束再切纸.
	MaxPrintSpeed[]全部改为220.
12.	16进制打印测试通过.
13.	自检打印测试通过.
14.	条码打印测试.有问题.需要修改.有时压缩,有时漏打HRI.有时多虚点行.
15.	字符打印特效组合测试:
旋转90°+黑白反显+设置左边距48点+选择9*17字体+纵横放大倍数4 : 
	打印字符正常.
取消旋转+取消黑白反显+设置左边距0点+选择12*24字体+纵横放大倍数1 :
	打印字符正常.
黑白反显+设置左边距48点+选择9*17字体+纵横放大倍数3 :
	打印字符正常.
16.	其他设置指令测试通过:
设置定位,下划线,反白,自定义字符,设置绝对位置,左边距,右边距,行间距,
字间距,左对齐,全切,半切.
17.	图形打印指令:
1B4B测试小图像通过.
1B2A图形打印,M横向放大2倍,测试通过.
1B2A图形打印,M不放大,测试通过.
1B2A图形打印,黑条块横向放大2倍,测试打印中间出现错误.
1B2A图形打印,黑条块不放大,测试打印中间出现错误.
测试图像打印指令1B 2A,打印"北京银行"图片,横向放大2倍,错误,打印乱码.
图像处理指令修改调整.


程序版本:0.169
编写人员: 
编写日期:2012-12-27
1.	GoDotLine(),DriveCutPaper()修改,
	恢复为之前判断走纸是否完成时还需要判断打印缓冲区状态是否为空闲,
2.	PrintOneDotLine(),恢复修改WaitHeatAndFeedPaperFinish().
3.	自检打印测试通过.
4.	条码打印测试通过.
5.	图形及下载位图指令有待测试.
6.	ProcessCharMaskReadBufIlde(),ProcessCharMaskReadBufEdit()添加.
	ProcessCharMaskReadBuf()改用以上两个函数实现.
	DealOneLineTimeCountFlag定义放到函数外.
	修改后工作正常.
7.	JudgeLineBufFull()修改.添加处理行首时确保能放下至少1个字符的处理.
	修改此时的左边距及打印控制列数变量调整.
	测试通过.
8.	1D2F打印下载RAM位图测试:
	未下载位图时打印无反应.正常.
	三种参数测试正常.
	倒置打印测试正常.
9.	1D2A定义下载RAM位图:
	测试通过.
10.	Command_1D2A()修改.只判断总数据字节量,不单判断纵向高度.
	这样可以打印总数据量不超标,但是高度更高的情况.
11.	打印点阵图形1B13(1B4B)测试通过.
12.	1B2A()测试正常.
	但是打印后按上纸键无反应.因为行间距已经被设置为0了.
13.	CheckFeedButton(),ReadFeedKey()修改,
	上纸距离设置为宏定义值,以免每次上纸数量不一致.
14.	StartPrintLineBuf()修改,最后退出前关闭打印检查定时器.
	修改后打印正常.
15.	
预定义NV位图
1C 71 n[xL xH yL yH d1...dk]1...[xL xH yL yH  d1...dk]n
打印预定义NV位图
Hex 1C 70 n	m
	正常打印发现配合测试通过.
	但是倒置打印测试发现错误.目前程序还没有处理倒置打印.需要以后修改.
16.	打印可变高度位图,该指令为ESC/POS定义,1D5130
	测试正常.
17.	所有图形打印指令测试通过.
图形打印指令测试.
1D2F	:	测试通过
1D2A	:	测试通过
1B13(1B4B)	:	测试通过
1B2A	:		测试通过
1C71	:		测试通过
1C70	:		测试通过,需要完善倒置打印处理.
1D5130	:		测试通过
18.	按键上纸不灵敏.
	CheckFeedButton(),ReadFeedKey()修改,抖动延时缩短一半改为10ms.
	恢复原判断条件.


程序版本:0.170
编写人员: 
编写日期:2012-12-27
主要用来测试驱动打印.
1.	SPRT POS886驱动串口和U口均可正常打印.
2.	WHKJ	驱动串口打印乱码,U口可正常打印.
	原因是WHKJ驱动一开始就走很长一段距离的走纸,在此期间不停发送数据,
	导致数据溢出.而驱动在此期间没有根据忙信号停止发送数据.
3.	Command_1C70()修改.添加倒置打印处理.
	测试正向打印和倒置打印处理正常.修改两种情况下的取点行首地址及地址变化.
4.	1B76()测试,
	PutCharToInBuffer()修改,1B76不作为实时指令执行.只作为普通命令.
	RealTimeCommand()修改,只判断1B开头.
	Command_1B76()修改,不判断端口.
	修改后测试1B76表现正常.
5.	SystemTimer2Func()修改.
	自动状态是否返回根据ErrorStruct.ASBAllowFlag判断.
6.	Command_1B75(),Command_1D72()修改.
	钱箱开关状态只有最低位有效.
7.	TIM4_IRQHandler()修改,直接调用打印程序.
8.	PutCharToInBuffer()中实时指令填充10 14 n m t好像有问题.待检查.


程序版本:0.171
编写人员: 
编写日期:2012-12-28
SystemCtrlStruct.PaperType 确定纸张类型, 0=连续纸,1=黑标纸
SysConfigStruct.BlackMark 确定黑标使能设置, 0=关,1=开
SysConfigStruct.RightMark 确定黑标传感器位置, 0=右边,1=左边,默认右边
SysConfigStruct.BlackMarkSensor 确定黑标传感器灵敏度设置, 0=低,1=中,2=高
SysConfigStruct.PaperSensor 确定测纸传感器灵敏度设置, 0=低,1=中,2=高
SetCommand_1B22()设置黑标,
1.	添加纸张类型宏定义.
	修改按键上纸等根据纸张类型判断处的程序.
2.	InitSystemCtrlStructParameter()修改纸张类型赋值.
	根据黑标是否使能,赋值纸张类型宏定义.
3.	判断黑标时,根据 SysConfigStruct.BlackMarkSensor 的值判断.
	添加黑标,纸将尽,传感器灵敏度值变量定义BlackmarkADValue[],PneADValue[].
	修改各个AD信号宏定义的笔误VLAUE.
4.	添加黑标是否独立的宏定义BLACKMARK_ADC_USE_PE_ADC.
	ADC_Config(),修改对应ADC设置.
	ad.c修改头文件,添加外部变量声明.
	DMA1_Channel1_ADFunc(),修改黑标判断,修改纸将尽判断.
5.	
可打印区域是机器自身硬件最大能力限制的,用设置纸宽指令
	GS ( E fn = 5或者DIP开关来改变.
打印区域是指令设置的,只能小于等于可打印区域,标准模式下用指令 
	GS L and  GS W 设置;页模式下用指令 ESC W 设置.
6.	Command_1D2845()编写处理.EPSON标准的参数设置命令.
	非常复杂,添加了空函数,处理待日后完成.


程序版本:0.172
编写人员: 
编写日期:2012-12-28
解决打印时最右边有的列数没有打印完整的错误.
1.	LineBufToHeatElementNormalDir(),UnderLineBufToHeatElementNormalDir(),
	按列处理完后添加根据列数是否能被8整除来递增i;
	反向填充的不必处理,因为反向的复制了全部字符.
	修改后测试正常.


程序版本:0.173
编写人员: 
编写日期:2012-12-31
将按键改为中断检测处理.
1.	gstructFeedButton改为g_tFeedButton,
	gstructResetEthButton改为g_tResetEthButton,
	添加按键检测中断模式调试宏定义.
2.	先测试FEED,InitFeedButtonPort()修改.改为中断模式.
	InitNVIC()修改,添加按键中断.
	EXTI15_10_IRQHandler()修改,分别处理上纸和以太网按键.
	中断中处理按键次数统计,按键状态改变.
	初始化时按键次数=0,按键状态为无按键;
	中断中按键次数++,按键状态为有键按下.
	在程序中读取按键的地方,检查是否曾有键按下;
	如果有则检测按键次数,使用按键次数,而后将有键按下改为无按键.
3.	测试按键次数统计无错误.
4.	CheckFeedKey()添加以替代ReadFeedKey().
	测试按键上纸通过.
5.	cominbuf.c中static void	CheckFeedButton(void)去掉,
	其功能与CheckFeedKey()完全相同.用其替代.
6.	CheckFeedKey()改为CheckFeedButton().全部替换相应处.
7.	HexMode()修改.修改按键检查判断及处理.退出16进制前清空按键变量.
	CheckFeedButton()修改.16进制模式时不作处理.
	u8		ReadFeedKey(void)删掉.
8.	SystemSelfTest()修改,退出自检模式前等待打印完毕.
9.	测试自检打印,16进制打印,正常打印测试正常.



程序版本:0.174
编写人员: 
编写日期:2012-12-31
将库放到外面作为公共目录.
编译通过.允许2D条码编译通过.


程序版本:0.175
编写人员: 
编写日期:2013-1-4
测试字库.
1.	MAX_CODEPAGE_SET_NUM改为53,代码页设置程序中改为使用宏定义判断.
	去掉国际字符参数的判断.
2.	GetAscIIFlashDotData()修改.将其拆分成几个函数.
	GetUSACharacterStartAddress(),GetInternationalCharacterStartAddress(),
	GetCodepageCharacterStartAddress()添加.
	测试正常.
3.	添加测试025三个字符.
	添加相关变量,添加相关命令,修改读字符程序,
	测试发现打印出来效果与目前使用的字库还是不一致.
4.	测试新编字库.修改地址宏定义.
	修改可靠性测试程序参数存储地址定义.
	修改下载位图定义程序,改用扇区擦除实现.
	

程序版本:0.176
编写人员: 
编写日期:2013-1-5
禁用二维码,改用库作为非公共目录.编译通过.
添加测试GB18030字库测试程序.
1.	将字库中指定位置开始的指定数目的字符取出并打印出来.
	添加宏定义,添加新指令,Command_1E20().
	测试正常.
	需要修改GB18030的解码程序.字库中有部分错误需要调整.
2.	JudgePrintGB18030(),修改判断条件和处理方式.
	原程序在判断第2字节时判断条件多余;
	在判断第4字节时打印第3字节错误,有可能造成合法的双字节编码被误处理.
3.	PrintGB18030()修改.
	原双字节部分处理正确,四字节部分处理错误.修改完毕.待测试.
4.	PrintBIG5()修改,修改偏移字节计算判断.
	无其他错误.


程序版本:0.177
编写人员: 
编写日期:2013-1-6
处理维护计数相关的程序.
修改MAINTAIN_DATA_ADDR宏定义值,将其改为放到外部字库FLASH中.
根据ESC/POS手册,EPSON公司的维护计数器后续将不再支持.
1.	STD_HEAT_ENERGY值改为原值两倍.
	GetHeatTime()计算最终结果值不再人为加倍.
2.	编写maintain.c中程序.添加一系列函数.
	包括维护参数初始化,读取,保存.
	InitParameter()修改,添加maintain相关初始化.
	charmaskbuf.c文件添加rs.h头文件包含.
	Command_1D67(),DMA1_Channel1_ADFunc(),将其中的维护参数操作改为条件宏定义.
	SystemTimer2Func()中维护定时.
	DriveCutPaper()添加切刀次数维护统计.
	StepFeedMotor()添加上纸次数维护统计.
	ProcessHeatAndMotor()添加加热次数维护统计.
	全部处理完毕,有待检测.
3.	GB18030汉字编码测试通过.
4.	维护计数器测试通过.
	包括各项目的自动维护,参数初始化,自动写入等.
	Command_1D67()修改,传送行数目时按照点行计算.不按照行计算.


程序版本:0.178
编写人员: 
编写日期:2013-1-7
测试打印过程中的温度和加热时间值.
1.	添加测试宏定义.
	SetGoLineSpace()修改,添加测试程序.在走行间距时回传.
	UpLoadData()修改,串口发送前等待上一次发送缓冲器空.
2.	测试加热时间从最高120us到最低50us.
	打印到后来中间总是会停顿.造成一行中有空白.
3.	关闭电机步监视,关闭维护计数器相关程序,关闭二维条码,
	发现还会出现这种情况.打印开始时没有,打印长度较长时就会开始出现.
4.	打开维护计数器相关程序,
	主程序中添加检查是否到写入周期,如果到则将新数据写入.
	添加变量g_cMaintainRountinWriteFlag.
	添加写入周期分钟时间宏定义.
	WriteFlashParameter()修改.执行前无需判断.最后要更新备份时间.
	CheckMaintainRoutin()添加.
	SystemTimer2Func()修改.检查计时变量与备份变量判断是否执行维护计数.
	main()修改.添加维护计数器检查.
5.	周期性维护计数器相关程序测试通过.
6.	将周期性维护计数器保存检查程序添加到正常和可靠性测试程序中.


程序版本:0.179
编写人员: 
编写日期:2013-1-8
修改字库基地址值.适应新调整的字库.
1.	Command_0D()实现按照说明书修改.
2.	Command_1004()修改,修改缺纸判断.修改走纸键按下判断.
3.	Command_1005n()修改,修改清空接收缓冲区处理.修改根据机型处理.
4.	Command_1014fnmt()修改.
	实时开钱箱指令修改:添加执行该指令的条件处理.
5.	Command_1B21()修改.修改判断条件.颠倒处理.
6.	Command_1B26()修改.确保参数都正确且完全保存完毕数据再设置自定义字符有效标志位.
	添加判断是否超过最多可允许定义的字符数量,根据宏定义判断.
7.	Command_1B2D()修改,提高处理效率.
8.	Command_1B33()修改,去掉多余注释和程序.
	行间距 = 行高 + 行间空白.
9.	PrintOneLine(),SetGoLineSpace()修改.设置行间距值修改.
	减去最大行高.如果行间距比最大行高小,则行间距设置为0.
10.	InitPrtCtrlDataParameter()修改.
	PrtCtrlData.CharWidth,PrtCtrlData.CharHigh设置为0.
11.	Command_1B3F()修改,修改删除时的判断条件.原条件错误.
	修改处理流程.先读数,再判断当前是否有该字符已被定义.如果没被定义直接退出.
	如果被定义了才执行清除.
12.	新字库测试失败.恢复使用老字库.
13.	Command_1B4A()修改.修改行间距设置值适应之前9的修改.
14.	当前修改的打印效果变差.中间停顿感很强.自检打印中间停止了.出错了.
15.	恢复9的修改后效果依旧.恢复1的修改后效果依旧.
2013-1-14修改:
16.	PrintLineBuffer()空闲时,关闭定时器.
	修改以太网串口速度定义及初始化程序.
	恢复9的修改.
	Command_1B4A()恢复修改.
	Command_1B33()修改.设置为点行值.
	修改后行间距0,16,32都能正常打印字符.
	字符能够正常打印.
	行间距8时打印压缩.
	自检打印正常.



程序版本:0.180
编写人员: 
编写日期:2013-1-8
以0.178版本修改.0.179版本修改后有错误.
1.	PrintOneLine(),SetGoLineSpace()修改.设置行间距值修改.
	减去最大行高.如果行间距比最大行高小,则行间距设置为0.
	修改后出现自检打印死机.自检时打印到第一行黑块后,第二行黑块前时死机.
2.	PrintOneDotLine(),CheckFeedButton(),GoDotLine()中的
	WaitHeatAndFeedPaperFinish()改为WaitHeatAndFeedFinish().
	StartHeatAndRotateMotor()中进入后先关闭打印检查定时器.
	修改后打印效果同0.179的15.
3.	测试0.153打印效果同0.179的15.
编写日期:2013-1-9
4.	SetGoLineSpace()中设置行间距时以点行为标准设置.
	设置行间距值时判断>=改为>.
5.	Command_1B33()修改,设置为点行值.
6.	GetMaxAccelerateSteps()中只根据温度和动态加热调整最大加速步数.
	其余暂时不用.
	修改后打印效果无改善.直到行间距设置为64点行,还会每两行停顿一次.否则每行停顿1次.
7.	关闭PrintOneLine(),SetGoLineSpace()设置行间距值修改.
8.	pstruLinePrtBuf变量全部改为ptLPB.
	LINE_PRT_BUF相关宏定义改为LPB.
	编译通过.
9.	恢复调整电机速度限制,行间距减小时限制最高速度.
	行间距32点行时,字符打印顺畅.
	行间距16点行时,字符打印顺畅.
	行间距10点行时,开始出现打印乱码,整行压缩.
10.	打印缓冲区不清除,清除放到复制环节.
	SetGoLineSpace()修改.不清零打印缓冲区,只置状态值.
	CopyPrtDataToLineStruct()修改.有内容时根据两者之间列高为准进行复制.
	无内容时清空打印缓冲区.
11.	修改后行间距10点行时,有时打印有压缩,有乱码,有丢内容.
12.	CopyPrtDataToLineStruct()修改.不管如何,全部复制编辑缓冲区数据.
	修改后行间距10点行时,打印肯定整行压缩.
13.	ClearLinePrtBuf()内容除了最后不处理状态标志变量外,其他全部与InitLinePrtBuf()相同.	
	CopyPrtDataToLineStruct()修改.用ClearLinePrtBuf()替代InitLinePrtBuf().
14.	GetMaxAccelerateStepsOfLineSpace()修改.
	行间距(8~12],加速步数改为60;
	行间距(4~8],加速步数改为40;
	行间距(0~4],加速步数改为20;
15.	修改后行间距10,打印顺畅,但是打印乱码.
16.	InitNVIC()修改.机芯发送DMA中断优先级设置为与打印检查定时器主优先级相同.
	防止二者之间相互打断.
	修改后打印内容很多时还是出现了乱码.
17.	StartPrintLineBufGraphic(),()修改.
	去掉防止出现DMA传输意外处理.
	修改后打印内容很多时还是出现了乱码.
18.	行间距8,4,2,1点行,打印无压缩.
	行间距为0,不打印.之间死机.
	图形打印死机.
	行间距16点行,打印乱码.
2013-1-14修改:
19.	PrintLineBuffer()空闲时,关闭定时器.
	修改以太网串口速度定义及初始化程序.
	修改后行间距0,16,32都能正常打印字符.
	字符能够正常打印.
	行间距8时打印乱码.


程序版本:0.181
编写人员: 
编写日期:2013-1-10
调试找错:打印乱码,压缩,不打印图形,行间距0时死机.
1.	DMA2_Channel2_IRQHandler()添加等待传输结束.
		修改后还会打印乱码.
2.	添加切刀使用宏定义.DriveCutPaper()修改为根据该宏定义动作.
3.	DecInBufferGetPoint()修改.添加根据宏定义统计总读取字节数计算.
4.	StartHeatAndRotateMotor()修改.判断是否计算了加热时间后不需要再次启动打印检查控制定时器.
	SPI3_DMA修改中断优先级,设为与TIM4同级别.
	行间距0时还会死机.行间距1,2时打印平稳,乱码.
5.	GoDotLine()修改.距离为0时直接退出.
6.	PrintLineBuffer()修改.为空闲时关闭打印检查定时器.
	修改后行间距0,打印无压缩,无乱码,突突跳.
	行间距1,4,8,12,16,打印平稳,无压缩,无乱码.
	无论行间距是否为0,图形都能打印.
	SPRT驱动打印测试正确.
7.	SPI3_DMA修改中断优先级,恢复原优先级,比TIM4主优先级高1级.
	修改后行间距0,打印无压缩,无乱码,突突跳.
	行间距1,4,8,12,16,打印平稳,无压缩,无乱码.
	无论行间距是否为0,图形都能打印.
	SPRT驱动打印测试正确.


程序版本:0.182
编写人员: 
编写日期:2013-1-10
调试行间距限速值.以串口为标准进行调试.
1.	GetMaxAccelerateStepsOfLineSpace()修改:
限速原值:
	行间距>16,		不限速.
	行间距(12,16],限速100,
	行间距(8,12],	限速60,
	行间距(4,8],	限速40,
	行间距<4,			限速20.
去掉行间距限速.测试:
	行间距>=16,打印顺畅,无压缩.
	行间距15,出现首行压缩.有时整行压缩.
	行间距14,打印顺畅.出现乱码.
	行间距0,打印乱码.

修改限速区间:
	行间距>16,		不限速.
	行间距(14,16],限速120,
	行间距(12,14],限速100,
	行间距(10,12],限速80,
	行间距(8,10],	限速60,
	行间距(6,8],	限速40,
	行间距(4,6],	限速30,
	行间距(2,4],	限速20,
	行间距(1,2],	限速10,
	行间距<=1,		限速5.
修改后测试行间距为:
	0,打印平稳,无压缩,无乱码.
	1,打印平稳,无压缩,无乱码.
	2,打印平稳,无压缩,无乱码.
	3,打印平稳,无压缩,无乱码.
	4,打印平稳,无压缩,无乱码.
	5,打印平稳,无压缩,无乱码.
	7,打印平稳,无压缩,无乱码.
	9,打印平稳,无压缩,无乱码.
	11,打印平稳,有时出现几点行压缩或者拉伸,无乱码.
	13,打印平稳,无压缩,打印乱码.
	15,打印平稳,无压缩,打印乱码.

修改限速区间:
	行间距>16,		不限速.
	行间距(14,16],限速100,
	行间距(12,14],限速80,
	行间距(10,12],限速60,
	行间距(8,10],	限速50,
	行间距(6,8],	限速40,
	行间距(4,6],	限速30,
	行间距(2,4],	限速20,
	行间距(1,2],	限速10,
	行间距<=1,		限速5.
修改后测试行间距为:
	15,打印平稳,无压缩,打印乱码.

SPI3_DMA修改中断优先级,与TIM4主优先级相同,副优先级也相同.
修改后测试行间距为:
	15,打印平稳,无压缩,打印乱码.
	32,打印平稳,无压缩,无乱码.
	16,打印平稳,无压缩,打印乱码.
	13,打印平稳,无压缩,打印乱码.

修改为全部接收完毕再打印,如果打印过程中多次发送,还会出现乱码.

编写日期:2013-1-11
2.	打印乱码的几个可能原因:
	复制编辑缓冲区时错误,多复制或者少复制;
	编辑时点阵列数统计错误;
	SPI机芯数据发送时错误,提早或者落后;
	打印缓冲区状态变迁错误,上一行还未完全打印完毕即开始下一行打印;
	SPI字库读取数据错误;
3.	修改复制缓冲区操作,改为不管如何全部复制;
	改为边收边打;
	ResetEthernet()添加.管脚改为输出,复位以太网芯片.
	SystemDelay1mS()改为SystemDelayMS().
	以太网端口初始化时添加复位以太网.
修改后修改后测试行间距为13,打印平稳,无压缩,打印乱码.
4.	修改机芯数据发送.
	sHeat_Init()改为只发送不接收方式.
修改后修改后测试行间距为13,打印平稳,无压缩,打印乱码.
打印内容虽然是乱码,但是都是正确的字符.怀疑是字符分析,数据接收环节出现问题.
5.	调试发现,数据接收开始时多接收了一个字符C8.
6.	默认行高设置为13,使用16进制测试.
	HexMode()修改.修改填充默认格式.
	修改后行间距按照初始化时的值进行.打印效果与正常模式打印的才能相同.
7.	测试发现接收的数据流中间出现了问题.
	少接收了一个字节,导致后面的解码就全部错乱了.
8.	ReadInBuffer(),DecInBufferGetPoint()修改.
	处理接收字节数目时不禁止中断.处理完毕不处理开中断.
	USART3_IRQHandler()修改,满后只置忙,不禁止中断.
	TypeDef_StructInBuffer,和gstructInBuf定义成易变型.
	修改后默认行高设置为13,使用16进制测试,没有发现再出现打印乱码.
9.	DriveCutPaper()修改,切刀切纸成功后自动上纸8mm.使用宏定义.
10.	网口使用波特率250K测试成功,默认行间距13,无乱码.
11.	网口使用波特率500K测试成功,默认行间距13,无乱码.
12.	网口使用波特率1000K测试成功,默认行间距13,无乱码.
13.	网口使用波特率1M,发现接收无丢数,但是在处理过程中处理字节数比接收字节数要少.
14.	InitPrtCtrlDataParameter()修改.将字符PrtModeChar的设置放到
	InitPrintModeParameter(),去掉PrtCtrlData.CharWidth和CharHigh的设置.设置为0.
	InitPrtCtrlDataParameter()修改,按照定义时候的顺序进行赋值.
15.	将网口波特率降低为250K.
16.	将esc.c中的宏定义放到头文件中.将默认行高赋值使用宏定义,默认为32点行.
17.	数据接收没有丢失,数据处理过程中出现错误.处理的字节数少于接收的字节数.


程序版本:0.183
编写人员: 
编写日期:2013-1-11
1.	恢复修改机芯数据发送.sHeat_Init()恢复为同时发生和接收方式.
	恢复SendHeatElementBufToCore().
2.	CopyPrtDataToLineStruct()改为使用根据总行高赋值同时清空的模式处理.
3.	JudgePrintGB18030()可能有错误.
	使用网口测试.
	当为4字节时,如果第四个字节编码错误,前三个字节都当做ASCII字符打印处理.
	出现读取比接收少的概率降低了.
4.	JudgePrintGB18030()继续修改.
	当为4字节时,如果第四个字节编码错误,全部4个字节都当做ASCII字符打印处理.
	使用网口测试.
	出现读取比接收少的概率降低了.但是还会出现.
5.	使用U口测试.
	分别使用行间距32和行间距10,前后共发送12330字节,接收和处理的相同.打印结果正常.
6.	使用串口115200测试.
	使用行间距10,一次发送1372字节,周期性发送8232字节,打印结果正常.
7.	使用网口测试.波特率1M.
	使用行间距10,一次发送1372字节,有时有遗漏.
	有的电路板没有出现遗漏.


程序版本:0.184
编写人员: 
编写日期:2013-1-14
1.	PrintBlackBlock()去掉控制打印控制字符高度和宽度设置.
	PrintSelfTestOver()添加打印两个空行.否则切纸位置过高.
	去掉打印黑块部分的自检程序.
	测试自检打印182,183,184版本打印不正常.
2.	添加黑标检测相关程序.
	AD转换中静态变量类型改为u16,
	测量黑标纸时输出电压为1.5~2.0V之间.
	黑标位置时输出1.5~2.0,空白位置时输出0.2V以下.
	修改三种黑标灵敏度.
3.	测试找黑标正常.
	但是找到黑标的位置与检测是否有纸二者之间结果正好相反,还需要调整.
	当保存参数设置为黑标使能时,初始化时纸张类型设置为黑标纸,否则设置为连续纸.
	即黑标模式与纸张类型是捆绑使用的.
	SysConfigStruct.BlackMark改为SysConfigStruct.BlackMarkEnable定义黑标是否使能,
	SystemCtrlStruct.MarkFlag改为SystemCtrlStruct.MarkPositionFlag,标志是否在黑标位置.
4.	Command_1B63()修改.添加1B 63 30 n设置纸张类型指令.
5.	将黑标传感器灵敏度值设置为与PE值范围相同.
	OpenADC()改为同时启动两次.
	ADC_COUNT由10改为4.
	关闭欠电压维护计数器写入.
	此时找黑标成功率100%.但是当无纸时,无法确认是否无纸.
6.	添加检测黑标时判断是否为胶辊压下而无纸的情况,添加宏定义PE_ADC_VALUE_ONLY_PLATEN,
	修改后判断缺纸和黑标同时正确.
7.	维护计数器写入时时间很长,有问题.暂时屏蔽.


程序版本:0.185
编写人员: 
编写日期:2013-1-14
以0.179版本修改.已找出0.179版本测试时发现的错误原因.
将0.180版本以后添加的内容逐步添加并测试.
1.	pstruLinePrtBuf变量全部改为ptLPB.
	LINE_PRT_BUF相关宏定义改为LPB.
	编译通过.
2.	打印缓冲区不清除,清除放到复制环节.
	ClearLinePrtBuf()修改.除了最后不处理状态标志变量外,其他全部与InitLinePrtBuf()相同.
	SetGoLineSpace()修改.不清零打印缓冲区,只置状态值.
	CopyPrtDataToLineStruct()修改.有内容时根据两者之间列高为准进行复制.
	无内容时清空打印缓冲区.用ClearLinePrtBuf()替代InitLinePrtBuf().
	修改后行间距10点行时,有时打印有压缩,突突跳.
3.	GetMaxAccelerateStepsOfLineSpace()修改.
	修改限速区间:
	行间距>16,		不限速.
	行间距(14,16],限速100,
	行间距(12,14],限速80,
	行间距(10,12],限速60,
	行间距(8,10],	限速50,
	行间距(6,8],	限速40,
	行间距(4,6],	限速30,
	行间距(2,4],	限速20,
	行间距(1,2],	限速10,
	行间距<=1,		限速5.
	修改后测试行间距为:
	10		:打印平稳,无压缩,无乱码.
	15,16	:打印平稳,无压缩,打印乱码.
4.	添加切刀使用宏定义.DriveCutPaper()修改为根据该宏定义动作.
	切刀切纸成功后自动上纸8mm.使用宏定义FEED_PAPER_MM_AFTER_CUT.
5.	DecInBufferGetPoint()修改.添加根据宏定义统计总读取字节数计算.
	GoDotLine()修改.距离为0时直接退出.
6.	ResetEthernet()添加.管脚改为输出,复位以太网芯片.
7.	SystemDelay1mS()改为SystemDelaymS().
8.	InitStdPeriph()修改.以太网端口初始化时添加复位以太网.
9.	HexMode()修改.修改填充默认格式.
	修改后行间距按照初始化时的值进行.打印效果与正常模式打印的才能相同.
10.	ReadInBuffer(),DecInBufferGetPoint()修改.
	处理接收字节数目时不禁止中断.处理完毕不处理开中断.
	USART3_IRQHandler()修改,满后只置忙,不禁止中断.
	TypeDef_StructInBuffer, gstructInBuf定义成易变型.
11.	将esc.c中的宏定义放到头文件中.将默认行高赋值使用宏定义,默认为32点行.
12.	数据接收没有丢失,数据处理过程中出现错误.处理的字节数少于接收的字节数.
13.	JudgePrintGB18030()可能有错误.
	当为4字节时,如果第四个字节编码错误,前三个字节都当做ASCII字符打印处理.
14.	测试串口发送,行间距2,4,8,16,20均可正常打印图形和字符.


程序版本:0.186
编写人员: 
编写日期:2013-1-14
1.	添加黑标检测相关程序.
	AD转换中静态变量类型改为u16,
	测量黑标纸时输出电压为1.5~2.0V之间.
	黑标位置时输出1.5~2.0,空白位置时输出0.2V以下.
	修改三种黑标灵敏度.
2.	测试找黑标正常.
	但是找到黑标的位置与检测是否有纸二者之间结果正好相反,还需要调整.
	当保存参数设置为黑标使能时,初始化时纸张类型设置为黑标纸,否则设置为连续纸.
	即黑标模式与纸张类型是捆绑使用的.
	SysConfigStruct.BlackMark改为SysConfigStruct.BlackMarkEnable定义黑标是否使能,
	SystemCtrlStruct.MarkFlag改为SystemCtrlStruct.MarkPositionFlag,标志是否在黑标位置.
4.	Command_1B63()修改.添加1B 63 30 n设置纸张类型指令.
5.	将黑标传感器灵敏度值设置为与PE值范围相同.
	OpenADC()改为同时启动两次.
	ADC_COUNT由10改为4.
	关闭欠电压维护计数器写入.
	此时找黑标成功率100%.但是当无纸时,无法确认是否无纸.
6.	添加检测黑标时判断是否为胶辊压下而无纸的情况,添加宏定义PE_ADC_VALUE_ONLY_PLATEN,
	修改后判断缺纸和黑标同时正确.
7.	维护计数器写入时时间很长,有问题.暂时屏蔽.
8.	WriteSPI_FlashParameter()修改.写之前将写标志变量置1.
9.	修改后打印黑块中间停止,行间距10时有停止拉伸现象.
10.	OpenADC()改为同时启动1次.ADC_COUNT由4改为10.
	修改后找黑标与测纸判断成功.
	自检打印成功.
13.	串口115200发送测试.
	发现接收无丢数,处理时少读数.
14.	Command_1B57()修改.判断变量是否合法.改变赋值方式.
15.	Command_1B13()修改.添加读取多余位图数据处理.
16.	gstruLinePrtBuf全部改为g_tLinePrtBuf,
//	gstructHeatCtrl全部改为g_tHeatCtrl,
17.	使用先接收再处理+模拟打印模式测试,串口115200发送1B13打印位图,
	共发送15484字节,接收和处理全部相等.
18.	使用边收边打+模拟打印模式测试,串口115200发送1B13打印位图,
	共发送2382字节,接收无丢数,处理比接收的少很多.
19.	DecInBufferGetPoint()修改.处理前先关闭中断,处理完毕再打开中断.
	共发送2382字节,接收无丢数,处理比接收的少1个字节.
20.	ReceiveInterrupt()修改,根据实际接收端口处理中断.
	共发送3574字节,接收无丢数,处理比接收的少40多个字节.
编写日期:2013-1-15
检查以下几部分:
接收缓冲区宏定义是否符合
是否频繁进入缺纸错误
SPI_HEAT与TIM4是否冲突
21.	将堆栈区由2K改为4K.
	接收缓冲区宏定义是否符合	:	符合
	是否频繁进入缺纸错误	:	从来没有进入
	还是出现接收与处理不一致.
22.	检查是否进入DecInBufferGetPoint():	从来没有进入
	还是出现接收与处理不一致.
23.	TypeDef_StructLinePrtBuf,TypeDef_StructHeatCtrl,
	TypeDef_StructSystemCtrl改为volatile型.
	SPI_HEAT优先级改为与TIM4相同.
	还是出现接收与处理不一致.
	使用字符测试情况相同.
24.	测试0.179版本,不但接收和处理数据不一致,连接收都错误.
	测试0.151版本,不但接收和处理数据不一致,连接收都错误.
	测试0.166版本,不但接收和处理数据不一致,连接收都错误.使用字符测试,也可能出现不一致.
25.	使用字符测试,很少出现不一致的时候.
	DecInBufferGetPoint()不处理开关中断.
	使用调试工具,USB测试图像打印命令,发送9529字节,接收和处理一直都一致.
	使用调试工具,网口测试图像打印命令,发送5955字节,接收没有错误,少处理2个字节.
26.	将串口管脚速度设置为50M.
27.	修改为只读取而不具体处理接收内容.
	串口发送11521,接收到11521,处理11497.
	接收缓冲区存数3329,读数3305,二者吻合.
	为什么少读取了呢?
28.	ReadInBuffer()修改,禁用实时指令.
	USART1_IRQHandler(),USART3_IRQHandler()修改,状态为满后关中断.
	发送9600,处理9574,少处理26字节.
29.	TypeDef_StructCharMaskReadBuf改为volatile型.
	还出现错误.
30.	收完再打时,接收和处理都一致.
	边收边打时,接收无丢数,处理丢数.
31.	ReadInBuffer()修改,允许实时指令,处理字节变化前先关闭中断,修改完毕开中断.
	DecInBufferGetPoint()修改,处理字节变化前先关闭中断,修改完毕开中断.
	修改后接收和处理的字节数相同,但是接收有漏数.
	怀疑是编译器的bug.
32.	gstructInBuf定义为volatile型.
	DecInBufferGetPoint(),ReadInBuffer()修改,处理字节变化前后不处理中断.
	这种情况下调试发现还会出现接收发送不一致的情况.
33.	USART1_IRQHandler(),USART3_IRQHandler()修改,状态为满后不关中断.
	ReadInBuffer()由满变不满后,不开中断.
	这种情况下调试发现还会出现接收发送不一致的情况.
34.	无计可施了.暂且如此.


程序版本:0.187
编写人员: 
编写日期:2013-1-15
继续检查所有的指令.
1.	InitSystemCtrlStructParameter()修改.默认国际字符集根据设置语言决定.
2.	Command_1B54()修改,添加读取参数.但是有待完善.
3.	Command_1B57()修改,添加页模式下读取参数.但是有待完善.
4.	Command_1B63()修改,1B6333处理纸传感器时添加只有并口才有效.
5.	esc.h中修改宏定义,距离值都改为按照点数计算.之前的计算错误.
6.	Command_1B7B()修改,添加是标准模式还是页模式.
7.	1C67_31,1C67_32存储和读取用户自定义NV数据指令暂时没有添加.
8.	Command_1D24()添加.页模式下设置纵向绝对位置.待完善.
9.	Command_1D28()系列目前还没有具体实现.
10.	Command_1D57()修改,添加是标准模式还是页模式.
11.	Command_1C32()修改,添加定义了汉字的标志变量.
	Command_1B26()修改,修改了定义了字符的标志变量赋值.
12.	GetAscIIDotData()修改,修改自定义字符判断条件.
	PrintChar()修改,修改自定义汉字判断条件.
13.	Command_1C50()定义预下载位图指令需要添加.
	找不到指令的规格说明.添加完毕.有待测试.
14.	SetCommand_1BFE()修改.
	修改位图序列号判断条件.修改页写程序调用,块擦除程序调用.
	添加参数数据量判断,添加读取多余数据处理.
	删除SPI_FLASH_PageWrite(),块擦除程序SPI_FLASH_BlockErase().
15.	使用调试工具,测试U口和网口打印图形和字符正常.
编写日期:2013-1-16
使用SPRT驱动USB口,网口打印,打印乱码.


程序版本:0.188
编写人员: 
编写日期:2013-1-16
修改点行式驱动打印电机加速度控制和宏指令.
1.	GetMaxAccelerateSteps()修改.
	目前的流程为电机速度确定一律按照g_tLinePrtBuf中控制变量决定控制模式,
	现在改为缓冲区打印时根据缓冲区结构g_tLinePrtBuf中控制变量决定控制模式,
	点行打印时根据PrtCtrlData中控制变量决定控制模式.
	GetMaxAccelerateStepsOfDrivePrint()修改.
2.	Command_1C50(),Command_1D76()修改.
	添加打印之前设置为驱动打印模式,等待打印结束,去除驱动打印模式.
3.	修改后无论是否修改驱动打印时的速度调整还是开启接收时的延时,
	都会打印乱码,而且接收和处理的字节数目不一致.
4.	按照0.181版本修改数据接收和读取处理.驱动打印死机.


程序版本:0.189
编写人员: 
编写日期:2013-1-16
以0.187版本修改.测试驱动打印.
1.	按照0.181版本修改数据接收和读取处理.
2.	修改后SPRT驱动U口测试打印正常.数据接收处理一致,共97610字节.
	修改后SPRT驱动串口测试打印不正常,中间打印乱码.数据接收处理一致,共91970字节.中间有丢数.
	驱动网口打印电机死机.
3.	修改SPI_HEAT主优先级比TIM4高.


程序版本:0.190
编写人员: 
编写日期:2013-1-16
以0.187版本修改.主要为了测试驱动打印.
1.	数据读取处理过程中恢复开关中断操作.
2.	SetGoLineSpace()修改.直接添加行间距.
	CopyPrtDataToLineStruct()中有错误.比较判断条件错误.
	需要与ptLPB->PrtMode.MaxPrtDotHigh比较.
	ClearLinePrtBuf()修改.添加初始化变量.清零以下两个变量
	ptLPB->PrtMode.MaxPrtDotHigh,ptLPB->PrtMode.DoUnderlineFlag.
	MAX_RUSH_STEPS_ON_DRV_PRT_COM改为15,
3.	MAX_RUSH_STEPS_ON_DRV_PRT改为68.
	ReadInBuffer()中不等待.
4.	修改后U口驱动打印都无丢数,打印平稳.
	但是串口有丢数且打印有噪声.
5.	串口和网口限速改为20,且ReadInBuffer()中为以上两种端口时添加等待.
	修改等待的判断条件,添加DriverFullFlag的值.
	修改SystemCtrlStruct.SleepCounter,在数据来源清零.
6.	修改后串口驱动打印乱码很多.
	U口打印噪声大.
7.	串口和网口限速改为10,U口改为20.ReadInBuffer()中不等待.
	SPRT驱动串口和U口可以打印.网口打印死机.


程序版本:0.191
编写人员: 
编写日期:2013-1-17
1.	SetGoLineSpace()修改,恢复之前处理方式.等待之前完成再设置.
2.	gstructHeatCtrl全部改为g_tHeatCtrl,
	ProcessHeatAndMotor()修改.加热完成后判断打印缓冲区状态处理修改.
	StartHeatAndRotateMotor()修改.计算加热完成直接退出不启动定时器;
	如果上次走纸未完成,直接退出不启动定时器;
	PrintLineBuffer()修改.编辑状态也关闭定时器.
	打印状态缓冲区状态之间相互转换及上纸加热定时器相互配合检查结束.
	逻辑检查没有问题.
3.	修改后驱动打印网口还是死机.命令模式正常.
	调试发现,PRT端串口置忙后NET端还在不停发送.
	调试NET端发现其并没有不停发送,而是发送到一定数据量后一直检测到BUSY而不发送.
	改用与PC端相连的两个串口连接.使用1M波特率.发现没有再出现以上问题.
	但是接收端少接收了2个字符.
	改用波特率250K.发送6104字节,接收与发送一致,没有出现丢数.
4.	改为设计使用PRT端USART1与NET端接PC串口互联.
	添加宏定义USE_USART1_AS_NET.
	CheckInterface()修改.INTERFACE_TYPE_A为U+E.
	ReceiveInterrupt()修改.ETH涉及的中断改为USART1.
	ethusart.h修改相关宏定义.
	ETH_USART_Config()修改时钟设置.
	InitNVIC()修改中断设置.
	USART1_IRQHandler()修改接收源及存储处理.
	全部使用宏定义编译.
5.	修改后测试又出现死机现象.
6.	将其按照原设计,波特率250K进行测试.


程序版本:0.192
编写人员: 
编写日期:2013-1-18
1.	GetMaxAccelerateSteps()中去掉检查行间距和位图打印模式的检查.
2.	使用USART1与NET端PC接串口测试,115200BPS,NET软件0.05版本,使用微库编译.
	使用SPRT POS886驱动打印正常.打印效果差点,中间多次停止的缘故.
3.	当使用打印缓冲区打印时,状态值不能为ILDE,除了走行间距时.
	当使用驱动打印模式时,行间距肯定为0.但是打印缓冲区的各种控制变量值无意义.
4.	GetMaxAccelerateSteps()修改.温度和动态加热调整为公共,
	根据是否为驱动模式使用驱动调整或者打印缓冲区中变量调整.
	修改后打印效果同上.
5.	将波特率改为250K,ReadInBuffer()中添加等待.
	又开始出现死机现象.
6.	BPS改为115200,网口驱动限速10,还会出现死机现象.
7.	ReadInBuffer()中去掉等待,不再出现死机现象.
8.	改用USART3与NET端正常串口连接,1MBPS,NET端使用0.07版本.
	又开始出现死机现象.
9.	同8,改用0.05版本.同样死机.
10.	恢复为2.驱动打印效果同2.
11.	PRT端不变,NET端使用0.07版本.115200BPS.驱动打印效果同2.
12.	同11,改为250KBPS.又开始出现死机现象.
13.	双方暂时使用115200BPS.


程序版本:0.193
编写人员: 
编写日期:2013-1-18
添加以太网SPI.作为SPI从模式只接收.
1.	ethspi.h,c文件修改,将其改为只接收的从模式.
	ETH_SPI_LowLevel_Init(),ETH_SPI_Init()修改.
2.	InitStdPeriph(),InitNVIC(),添加SPI2的端口和中断初始化.
3.	SPI2_IRQHandler()添加中断处理.
4.	SetComInBufBusy(),ClearComInBufBusy(),ReceiveInterrupt()修改.
	添加SPI2相关的宏定义处理程序.
5.	实际执行中会出现参数错误.
6.	关闭忙信号设置相关的地方还会出现该错误.
7.	禁用USE_FULL_ASSERT宏定义后工作不再出错.
	改为双线制.
	接收字节数比实际发送端要少.
	发送端BPS改为250K,还是少.
8.	将cominbuf.c中关于中断操作的地方全部去掉.
	接收没有丢数.但是处理数据比接收的数据要少.
编写人员: 
编写日期:2013-1-19
1.	SPI改为硬件控制.
2.	ReadInBuffer(),DecInBufferGetPoint()中
	处理字节数目变化的地方确实需要关闭中断.
	但是关闭中断前添加置忙信号.
3.	修改后发送和接收的数据量都是一致的.
	使用TCP调试工具一次发送3089字节的下载位图并打印无丢数.
	如果连续多次发送会出现丢数.
	使用SPRT驱动网口打印接收和处理数据量一致,但是打印乱码.


程序版本:0.194
编写人员: 
编写日期:2013-1-19
1.	网口驱动打印加速度提高到68.NET端波特率改为1M.
	修改后打印乱码.
2.	spi2相关的中断和处理程序中没有处理忙信号.
	修改后打印突突,乱码.
3.	将加速度改为20.
	调试发现发送端发送了3089字节,而接收端只接收到2355字节.
	将发送端速度降低为250K.
	调试发现发送端发送了3089字节,而接收端只接收到2822字节.
4.	将NET端发送前再次检查忙信号处理去除.
	可以连续发送.共发送18534下载位图打印无丢数和乱码.
	使用SPRT驱动网口打印正常.
5.	将NET端速度改为500K.
	修改后驱动打印开始打印乱码.
	将NET端速度改为312.5K.
	修改后驱动打印正常.
6.	将USB,网口驱动打印限速提高到30.
	修改后使用SPRT驱动USB,网口打印正常.
	发送位图打印正常.
	但是打印速度没有感觉到有提升.而且二者都有突突感.
7.	将USB,网口驱动打印限速都设置到20.
	网口连续驱动打印会出现乱码.
8.	将NET端速度改为250K.
	网口连续驱动打印正常,无乱码.
	连续发送下载位图正常.
9.	修改字符处理.当一行满之后就打印.
	JudgeLineBufFull()修改.修改左限确保能放下一个字符时添加条件判断.
	FillPrintBuff()修改.填充方式改为按照左间距,字符,右间距,下划线顺序处理.
	修改右间距确保能够放下该字符.修改下划线添加计算.
	测试通过.


程序版本:0.195
编写人员: 
编写日期:2013-1-19
添加丢单打印功能.
1.	添加USE_FULL_ASSERT,修改assert_failed(),添加状态值回传.
	修改SPI2_IRQHandler().原清除函数调用赋值参数错误.
	修改后正确.
2.	修改后还得使用250K.测试500K还会丢数.
	使用250K周期性发送3089字节共发送194607字节没有丢数.
3.	丢单打印处理方法:
	当打印内容不超过1次接收缓冲区的范围内时,如果打印过程中发生了缺纸,
	重新换上新纸后,打印机放弃当前打印内容,从上一次打印开始的地方重新打印.
	当遇到切刀指令后,认为上一单打印结束,重置单据统计参数值.
4.	ClearInBuf()修改.处理忙和中断.
	Command_1B69(),Command_1B6D(),Command_1D56()修改.添加ClearInBuf()处理.
	根据宏定义及是否允许丢单打印处理.
	Command_0D()按照说明书修改.
	PaperOutDetect()添加.处理丢单打印.
5.	cominbuf.h,c文件修改.添加相关宏定义及函数声明及实现.
	main(),PutCharToInBuffer(),ReadInBuffer()中添加根据宏定义的相关修改.
6.	测试丢单重打通过.
7.	目前可以同时运行串口,U口,网口使用.
	与网络端回传测试通过.


程序版本:0.196
编写人员: 
编写日期:2013-1-19
添加宏相关程序.
	MacroStruct包含:
	u16	Number;						//宏字符个数
	u16	GetPointer;				//宏取数指针
	u8	DefinitionFlag;		//正定义宏标志
	u8	SetFlag;					//已定义宏的标志
	u8	RunFlag;					//正运行宏内容标志
	u8	Buffer[MACROSIZE];	//宏数据缓存区
1.	init.c中添加InitMacroStructParameter().
	InitParameter()中添加宏定义初始化.
	InitInbufParameter()修改.除掉宏定义处理.完善Inbuf处理.
2.	Command_1D3A()修改.添加减去2前先判断是否>=2.
	CheckFeedButton()修改.正在执行宏时,按键不上纸.
	其他与宏相关的所有指令都已经处理完毕.
3.	尚未测试.


程序版本:0.197
编写人员: 
编写日期:2013-1-22
1.	HexMode()修改,正常打印的行末尾添加0A作为换行.否则前后行会连到一起.
	修改后测试正常.
	DBG_RCV_DATA_LOSE放到debug.h中.
2.	Command_1B24()修改.
	添加打印控制全局变量,标志决定打印位置设置值AbsolutePrtPosition.	
	初始化为0,1B24()中设置其值.在一行编辑结束处理打印后开始下一行前,
	按照PrtDataDotIndex = PrtLeftLimit + AbsolutePrtPosition;赋值.
	
	InitPrtCtrlDataParameter()中添加初始化.
	PrepareNewLine(),InitVariableToStartNewLine()中修改PrtDataDotIndex赋值.
	Command_1B24()设置AbsolutePrtPosition,并修改PrtDataDotIndex值.
	修改后测试通过.
3.	编写测试用例,同时测试1D4C(),1D57(),测试通过.
4.	编写测试用例,水平造表测试通过.
5.	1D2A(),1D2F()测试通过.
6.	测试条码打印正常.
7.	测试1B2A()打印乱码.
	测试过程中发现接收字节数比实际发送字节数要少.


程序版本:0.198
编写人员: 
编写日期:2013-1-22
1.	Command_1B24()修改.
	去掉打印控制全局变量,标志决定打印位置设置值AbsolutePrtPosition.
	InitPrtCtrlDataParameter()中去掉初始化.
	PrepareNewLine(),InitVariableToStartNewLine()中去掉PrtDataDotIndex赋值.
	Command_1B24()设置AbsolutePrtPosition,并修改PrtDataDotIndex值.
	修改PrtLeftLimit为新值.
	修改后测试通过.
2.	测试1B4B(),1B2A()打印乱码.
	测试过程中发现接收字节数比实际发送字节数要少.
	使用1D2A()打印下载RAM位图,不会出现接收少的现象.
3.	测试打印WHKJ驱动打印内容,共接收处理35601字节.中间打印乱码.
	实际字符数为35618字节.少接收17字节.
4.	GetMaxAccelerateSteps()中暂时去掉驱动模式,行间距,位图模式三种情况的处理.
	测试打印WHKJ驱动打印内容,共接收处理35307字节.中间打印乱码.
	实际字符数为35618字节.少接收311字节.
5.	SystemTimer2Func()修改.修改钱箱控制.钱箱定时变量减之前先判断是否为0.
	修改关闭钱箱条件,增加定时时间为0的情况.关闭钱箱同时关闭钱箱控制状态为禁止.
6.	使用USB测试WHKJ驱动打印内容,使用测试工具发送,共接收处理35618字节.
	实际应该发送35618字节.没有丢数和多数的现象.
7.	使用NET测试WHKJ驱动打印内容,使用测试工具发送,共接收处理35587字节.
	实际应该发送35618字节.有丢数的现象.
	调试NET端程序发现,NET端实际发送和接收数据量为35618字节.问题在PRT端.
	再次继续发送一次还是如此.
编写日期:2013-1-23
8.	InitSystemCtrlStructParameter()修改SystemCtrlStruct.LineWidth初始化值.
	只有两种宽度576或者512.根据SysConfigStruct.PrintWidth值调整,其值为0或者1.
	InitPrtCtrlDataParameter()修改PrtCtrlData.PrtWidth初始化值.
	根据纸张类型需要调整.
	InitPrtCtrlDataParameter()要安排在InitSystemCtrlStructParameter()之后.


程序版本:0.199
编写人员: 
编写日期:2013-1-23,24
修改一维条码打印处理方式.目前方式为根据高度填充到打印缓冲区然后按照位图打印.
修改为点行打印方式.只需要发送一次,其他时候只需要处理加热即可.
1.	添加一系列该模式的处理函数.
2.	PrintBar()修改.原打印方向控制变量使用判断错误.
3.	TypeDef_StructHeatCtrl修改.去掉方向控制变量.不需要.
	InitHeatCtrlStruct()修改.去掉方向控制变量初始化.
4.	修改后测试打印正向打印,右对齐时,字符的最右端会打印出不需要的乱码.
	反向打印时,三种对齐方式条码打印均为空白或者一点行,数据填充错误.
	CodebarBufToHeatElementReverseDir(),修改处理字符范围判断条件.
5.	暂时没有时间美化.不修改这些东西.放弃本版本.


程序版本:0.200
编写人员: 
编写日期:2013-1-24
测试正常工作中执行维护计数器保存.
钱箱电路在连接时,一端接24V,一端接OUT驱动控制.
添加函数判断打印机是否正忙.如果不忙时才执行写入.
1.	GetPrintBusyStatus()添加.判断打印机是否忙.
2.	CheckMaintainRoutin()修改.是否写入前判断打印机是否忙.不忙则写.
3.	PaperOutDetect()修改最后等待条件.应该为||.
	添加初始化加热控制变量,电机走纸点数值.
4.	调试发现当打印过程中出现缺纸时,程序停止在WaitPreviousPrintFinish(),
	而无法进入检测丢单打印的流程.所以在再次换纸后会继续打印.
	而此时的丢单打印的标志将丧失而无法进入.
	需要将丢单打印的处理放到中断中进行.
4.	PaperOutDetect()修改,去掉最后的缺纸和纸仓盖打开的等待.
	将其调用放到SystemTimer2Func()中,并去掉main(),ReadInBuffer()中的调用.
	PaperOutDetect()调用时修改接收缓冲区字符容量及读取指针位置.
	修改后实现了丢单打印功能.但是会出现多打印不需要的内容的现象.
5.	main()添加处理PaperOutDetect()调用.
	修改后效果同上.
6.	ReadInBuffer()添加处理PaperOutDetect()调用.
	修改后效果同上.
7.	去掉main(),ReadInBuffer()中的调用.
8.	缺纸可能发生在任何时候:
	打印一行过程中;
	编辑一行过程中;
	边打印边编辑过程中;
	处理某个命令过程中;
	按照目前的处理,单纯将其读数指针设置回某个值可能引起执行逻辑的混乱.
	有待调整.
9.	JudgeLineBufFull()时没有考虑旋转的情况,会造成填充的内容越界.
	JudgeLineBufFull()修改.添加考虑旋转的处理.
	修改后测试正确.
编写日期:2013-1-25
10.	Command_0C()修改.
	添加判断黑标设置为有效才继续找黑标.
11.	Command_1D72(),Command_1B76(),AutomaticStatusBack()修改.
	纸将尽和纸尽判断条件颠倒了.
12.	1B24指令按照只在本行有效设置.下一行开始即失效.
	Command_1B24()修改.修改PrtDataDotIndex赋值.
13.	暂时关闭丢单打印功能.


	每次出现缺纸时只需要设置一次即可.为了防止多次重复设置丢单打印,
	添加变量g_NoPaperRePrintSetFlag,初始化为0,表示已经设置;
	当在ADC()程序中检测到缺纸时,将其置为1,表示出现需要设置丢单打印的情况.
	SystemTimer2Func()中设置时检测g_NoPaperRePrintSetFlag的值.为1时设置.


程序版本:0.201
编写人员: 
编写日期:2013-1-28
1.	1D61()自动状态返回处理修改.
	AutomaticStatusBack()修改.
	修改默认纸传感器值为0x00.
	添加字节2检测按键是否按下的处理.
	修改得到离线状态变量的计算.只需要其中任何一个满足即可进入离线状态.
	修改是否返回的判断,简化判断.调用AutomaticStatusBack()前肯定已经满足
	ErrorStruct.ASBAllowFlag != 0了.
2.	PrintBarHRI()修改.添加处理字符打印时反显,旋转无效处理.
3.	FillPrintBuff()修改.去掉处理右间距前的宽度判断.
	字符宽度,左间距,右间距改变变量类型为u16.原u8会出现溢出.
4.	Command_1B44()修改.添加判断跳格最大列数值.防止出现溢出.
5.	Command_1B24().
	李宏测试发现只设置绝对打印位置后换行,再打印其他内容会出现一点行乱码.
	自测试未发现该现象.
6.	PrintBarHRI()修改.计算字符的右间距时先判断是否字符宽度防止出现负数.
7.	Command_1014fnmt()修改.修改判断条件,修改接口为并口时检查是否忙的处理.


程序版本:0.202
编写人员: 
编写日期:2013-1-30
使用该版本测试升级.
1.	使能丢单打印,只在定时器2中处理.其他地方都去掉.
2.	MAINTAIN_WRITE_ROUNTIN_MINUTE改为60分钟.
	debug.c中添加升级模式时的函数声明ConfigOptionFlash().
	ReadInBuffer()中DriverFullFlag去掉.
	ProcessModeType()中解锁时为全功能.
	CheckInterface()中设置接口A类型时串口无效,只有U口和网口.
	正式版本的main()中维护计数器处理改为根据宏定义处理.
	周期性测试版本的main()中维护计数器处理改为根据宏定义处理.
3.	gstructInBuf变量名称改为g_tInBuf.
	各种情况下全部编译通过.
4.	去掉USE_FULL_ASSERT.
	将栈区由4K改为5K.可以实现最大160层的调用深度.编译通过.
5.	将栈区由5K改为6K.使用2级优化编译,编译无法通过.
	Command_1B26(),Command_1B3F()修改.
	添加处理参数错误时候的情况,防止指针操作失误.
	Command_1C71()修改.变量iAddress擦除地址忘记赋值.改4K为64K擦除.
6.	将栈区由6K改为5.5K.使用2级优化编译,编译无法通过.
	使用3级优化编译,编译无法通过.
	以下修改的都是告警为变量使用前可能未必初始化的问题.
	Command_1D6B()修改.添加第一个输入参数错误,直接退出处理.
	Command_1D5E()修改.添加j变量的初始化.
	GetCode128Str()修改.添加Temp变量的初始化.在每个循环开始之前赋值.
	barcode2d.c,pdf417lib.c中的暂时不处理.
	GetUSACharacterStartAddress(),GetCodepageCharacterStartAddress(),
	GetInternationalCharacterStartAddress()修改.添加输入参数不正确时
	AsciiCodeAddr变量有可能没有被初始化的处理.
	GetAscIIFlashDotData()修改.添加输入参数不正确时len变量有可能
	没有被正确赋值的处理.
	TimerConfigPrescaler()修改.添加输入参数不正确时TimerClockHz变量
	有可能没有被正确赋值的处理.
	Update()修改.添加输入参数不正确时Interface_Type变量有可能没有被正确赋值的处理.
	ProcessBarCode_2D()修改.添加res,datalen初始化的处理.
	GetLinePrtBufStartColumnIndex()修改.添加ColumnIndex初始化的处理.
7.	将栈区改为4K.可以实现最大128层的调用深度.编译通过.	
	将栈区改为5K.可以实现最大160层的调用深度.编译通过.
	使能二维码,栈区使用4K,编译通过.
	目前按照栈区使用4K使用,二级优化编译.测试升级正常程序可以烧写但是无反应.
	配合使用升级程序版本号0.08.
8.	去掉ConfigOptionFlash().
	测试升级正常程序可以烧写但是无反应.
9.	编译为非BOOTLOAD程序,下载程序后依然无反应.读取下载程序内容发现应用程序部分的
	内容与预期不符.
	使用0.201版本程序不带BOOTLOAD版本工作正常,编译为带BOOTLOAD版本后,不工作.


程序版本:0.203
编写人员: 
编写日期:2013-1-30
使用0.201版本为基础修改.
1.	BOOTLOAD时禁用ConfigOptionFlash().
	配合0.08版本升级程序测试.
	通过T6加密程序加密BIN文件后再生成DFU文件.使用DFUSE升级成功.
	升级完毕能够正常工作.
2.	使能丢单打印,只在定时器2中处理PaperOutDetect().其他地方都去掉.
3.	MAINTAIN_WRITE_ROUNTIN_MINUTE改为60分钟.
	ReadInBuffer()中DriverFullFlag去掉.
	ProcessModeType()中解锁时为全功能.
	CheckInterface()中设置接口A类型时串口无效,只有U口和网口.
	正式版本的main()中维护计数器处理改为根据宏定义处理.
	周期性测试版本的main()中维护计数器处理改为根据宏定义处理.
4.	去掉USE_FULL_ASSERT.优化等级0编译.
	通过T6加密程序加密BIN文件后再生成DFU文件.使用DFUSE升级成功.
	升级完毕能够正常工作.
5.	修改可靠性测试程序的自检打印长度值为230,附加信息长度为33.
6.	以下修改的都是告警为变量使用前可能未必初始化的问题.
	Command_1B26(),Command_1B3F()修改.添加处理参数错误时候的情况,防止指针操作失误.
	Command_1C71()修改.变量iAddress擦除地址忘记赋值.改4K为64K擦除.
	Command_1D6B()修改.添加第一个输入参数错误,直接退出处理.
	Command_1D5E()修改.添加j变量的初始化.
	GetCode128Str()修改.添加Temp变量的初始化.在每个循环开始之前赋值.
	barcode2d.c,pdf417lib.c中的暂时不处理.
	GetUSACharacterStartAddress(),GetCodepageCharacterStartAddress(),
	GetInternationalCharacterStartAddress()修改.添加输入参数不正确时
	AsciiCodeAddr变量有可能没有被初始化的处理.
	GetAscIIFlashDotData()修改.添加输入参数不正确时len变量有可能
	没有被正确赋值的处理.
	TimerConfigPrescaler()修改.添加输入参数不正确时TimerClockHz变量
	有可能没有被正确赋值的处理.
	Update()修改.添加输入参数不正确时Interface_Type变量有可能没有被正确赋值的处理.
	ProcessBarCode_2D()修改.添加res,datalen初始化的处理.
	GetLinePrtBufStartColumnIndex()修改.添加ColumnIndex初始化的处理.
7.	PrintReliabitityResultTotalLen()修改.应该为厘米而不是分米.
	50KM程序不使用BOOTLOAD可以正常工作.上电即开始打印.
	使用BOOTLOAD的不能正常工作.
编写日期:2013-1-31
8.	其他2/20/20分钟周期打印程序可以在BOOTLOAD工作,但是不能打印自检.
	7,8的问题出在6的修改之后.
9.	TimerConfigPrescaler()恢复修改.
	GetLinePrtBufStartColumnIndex()恢复修改.
	恢复后还是有问题.
10.	以上编译为优化等级3,改为优化等级0.
	此时2分钟带BOOTLOAD程序能够正常工作.
11.	去掉9的修改.
	此时50KM带BOOTLOAD程序能够正常工作.
	但是工作有错误,当缺纸无法打印时,统计次数依然递增.
	修改程序,在所有可靠性测试的程序中m_iReliableTestNumber++前面都添加
	WaitHeatAndFeedPaperFinish()确保打印结束.
	栈区空间由4K改为2K.
12.	修改后50KM带BOOTLOAD程序不能够正常工作,显示进入升级状态.
	找不出错误原因.
	0.201版本50KM带BOOTLOAD程序能够正常工作.


程序版本:0.204
编写人员: 
编写日期:2013-1-31
使用0.201版本为基础修改.
1.	BOOTLOAD时禁用ConfigOptionFlash().
	配合0.08版本升级程序测试.
	通过T6加密程序加密BIN文件后再生成DFU文件.使用DFUSE升级成功.
	升级完毕能够正常工作.
2.	使能丢单打印,只在定时器2中处理PaperOutDetect().其他地方都去掉.
3.	MAINTAIN_WRITE_ROUNTIN_MINUTE改为60分钟.
	ReadInBuffer()中DriverFullFlag去掉.
	ProcessModeType()中解锁时为全功能,添加解锁FLASH.
	CheckInterface()中设置接口A类型时串口无效,只有U口和网口.
	正式版本的main()中维护计数器处理改为根据宏定义处理.
	周期性测试版本的main()中维护计数器处理改为根据宏定义处理.
4.	去掉USE_FULL_ASSERT.优化等级0编译.
	通过T6加密程序加密BIN文件后再生成DFU文件.使用DFUSE升级成功.
	升级完毕能够正常工作.
5.	修改可靠性测试程序的自检打印长度值为230,附加信息长度为33.
6.	50KM可靠性测试程序能够带BOOTLOAD升级正常工作.	
	但是工作有错误,当缺纸无法打印时,统计次数依然递增.
	修改程序,在所有可靠性测试的程序中m_iReliableTestNumber++前面都添加
	WaitHeatAndFeedPaperFinish()确保打印结束.
	栈区空间由4K改为2K.
7.	6修改后50KM升级后又进入之前的情况,进入BOOTLOAD状态.
	栈区空间由2K改为4K.升级后还是如此情况.
	去掉WaitHeatAndFeedPaperFinish(),升级后还是如此情况.


程序版本:0.205
编写人员: 
编写日期:2013-1-31
使用0.201版本为基础修改.
1.	BOOTLOAD时禁用ConfigOptionFlash().
	配合0.08版本升级程序测试.
	通过T6加密程序加密BIN文件后再生成DFU文件.使用DFUSE升级成功.
	升级完毕能够正常工作.
2.	MAINTAIN_WRITE_ROUNTIN_MINUTE改为60分钟.
	ReadInBuffer()中DriverFullFlag去掉.
	ProcessModeType()中解锁时为全功能,添加解锁FLASH.
	CheckInterface()中设置接口A类型时串口无效,只有U口和网口.
	有可能是该处修改造成的问题.
	正式版本的main()中维护计数器处理改为根据宏定义处理.
	周期性测试版本的main()中维护计数器处理改为根据宏定义处理.
4.	去掉USE_FULL_ASSERT.优化等级0编译.
5.	修改可靠性测试程序的自检打印长度值为230,附加信息长度为33.
6.	50KM可靠性测试程序能够带BOOTLOAD升级正常工作.	
	但是工作有错误,当缺纸无法打印时,统计次数依然递增.
	修改程序,在所有可靠性测试的程序中m_iReliableTestNumber++前面都添加
	WaitHeatAndFeedPaperFinish()确保打印结束.
7.	50KM可靠性测试程序能够带BOOTLOAD升级正常工作.缺纸时会一直等待
	有纸再打印,统计次数不会累计堆积在一起.
8.	ReliabilityTestCutterLife()打印长度计算错误.修改计算方法.
	改为每隔2s切一次.每隔100切保存参数.
9.	正常功能程序可以带BOOTLOAD升级,可以工作,但是打印内容多时
	打印速度突然变慢,一点点的打印,纸张会被粘住.
	而不带BOOTLOAD的程序打印同样的内容没有出现任何问题.


程序版本:0.206
编写人员: 
编写日期:2013-1-31
1.	使能ConfigOptionFlash().
	配合BOOT端失败.不使用.修改startup,去掉Tamper_Detection相关部分.
2.	配合BOOT端0.08版本测试.工作完全正常.
3.	使能丢单打印,只在定时器2中处理PaperOutDetect().其他地方都去掉.
		配合BOOT端0.08版本测试.又出现之前的异常情况.
4.	BOOT端V0.09,修改startup的password后,配合正常.
	不检查ConfigOptionFlash().
5.	BuzzerDrive()待修改.
	SysConfigStruct.BuzzerEnable;
	//蜂鸣器使能,=0禁止;=1,缺纸,错误时允许;=2,切纸时允许;=3,缺纸,错误,切纸时允许
	目前程序已经全部实现,无需修改.


程序版本:0.207
编写人员: 
编写日期:2013-2-1
1.	修改PNE.使能PNE_ENABLE.
	pne.h修改相关宏定义值.
	DMA1_Channel1_ADFunc()中修改pne的判断.
2.	DMA1_Channel1_ADFunc()修改计算方法.使用数组实现.
	修改后的计算过程中有错误.使用之前的计算方式无错误.


程序版本:0.208
编写人员: 
编写日期:2013-2-16,17,18
1.	DMA1_Channel1_ADFunc()修改计算方法.提高实现效率.
2.	添加pdf417.h,c,将头文件中的数据类型定义去掉.
	将c的头文件包含放到h中.去掉重复的常量定义及静态变量定义.
3.	ProcessBarCode_2D()修改.添加判断数据量最大值,防止下标越界.
	修改pdf结构成员的命名,使之更具可读性.
4.	u32	Pdf417_Print(u8 *pBuf, u8 Width, u8 CorID, u16 CharLen)
			->	void pdf417_encode(pdf417 *p)
						->	void encode(PDF417_EN *pdf, pdf417 *p);				//编码
						->	void struct_make(PDF417_EN *pdf, pdf417 *p);	//排版
						->	void correct_append(PDF417_EN *pdf);					//添加纠错
						->	void bitmap_make(pdf417 *p, PDF417_EN *pdf);	//生成位图
5.	encode()函数处理好像有错误.与PDF417标准中所说的有错误.
6.	添加三个读取分析原始数据流中数字,文本,字节个数的函数.
编写日期:2013-2-19
1.	测试DMA1修改后的效果.
	测试发现ADC值一直为0.中间计算有错误.
	修改后的计算过程中有错误.使用之前的计算方式无错误.
2.	添加新函数,使用快速方式读取字库FLASH中的数据内容.
	sFLASH_ReadBuffer()使用正常速度读取,sFLASH_FastReadBuffer()使用快速读取.
	用快速读取替代正常读取测试.
	测试打印正常.
3.	修改机芯SPI的时钟分频系数,将时钟速度提高1倍,最快9M.
	测试打印正常.
4.	下一步可以继续修改不同行间距时限速的值,测试提高打印速度的效果.


程序版本:0.209
编写人员: 
编写日期:2013-2-19
1.	GetMaxAccelerateStepsOfLineSpace()修改.
	实际测试结果:
	//测试时使用标准1:1汉字整行批量打印,内容相同,只修改行间距,电压24V
	//所有测试效果都是以每个区间的下限进行的结果,数值表示加速步数
	if (LineSpaceDotNumber >= 14)
	{	//126(220mm/s)时打印正常,纵向横向放大8倍打印测试顺畅,偶尔会出现白道
		maxstep = MAX_RUSH_STEPS;		//100
	}
	else
	{
		if ((LineSpaceDotNumber >= 12) && (LineSpaceDotNumber < 14))
		{	//126(220mm/s)时有整行压缩,
			//100(196mm/s)时打印正常,纵向横向放大8倍打印测试顺畅
			//110(206mm/s)时打印正常,几乎没有停顿感觉,行间距为13时打印顺畅
			maxstep = 110;		//80,100
		}
		else if ((LineSpaceDotNumber >= 10) && (LineSpaceDotNumber < 12))
		{	//126(220mm/s)时有整行压缩,
			//80(176mm/s)时打印正常,纵向横向放大8倍打印测试顺畅
			//100(196mm/s)时打印正常,几乎没有停顿感觉,行间距为11时打印顺畅
			maxstep = 100;		//60,80
		}
		else if ((LineSpaceDotNumber >= 8) && (LineSpaceDotNumber < 10))
		{	//126(220mm/s)时有整行压缩,
			//70(164mm/s)时打印正常,纵向横向放大8倍打印测试顺畅
			//90(186mm/s)时打印正常,稍微出现一点停顿感觉,行间距为9时打印顺畅
			maxstep = 90;		//50,70
		}
		else if ((LineSpaceDotNumber >= 6) && (LineSpaceDotNumber < 8))
		{	//60(152mm/s)时打印正常,纵向横向放大8倍打印测试顺畅
			//80(176mm/s)时打印正常,电机有突突启停,行间距为7时打印顺畅
			maxstep = 80;		//40,60
		}
		else if ((LineSpaceDotNumber >= 4) && (LineSpaceDotNumber < 6))
		{	//50(139mm/s)时打印正常,纵向横向放大8倍打印测试顺畅
			//70(164mm/s)时打印正常,电机有突突启停,行间距为5时打印顺畅
			maxstep = 70;		//30,50
		}
		else if ((LineSpaceDotNumber >= 2) && (LineSpaceDotNumber < 4))
		{	//40(125mm/s)时打印正常,纵向横向放大8倍打印测试顺畅
			//60(152mm/s)时打印正常,电机有突突启停,行间距为3时打印顺畅
			maxstep = 60;		//20,40
		}
		else if ((LineSpaceDotNumber >= 1) && (LineSpaceDotNumber < 2))
		{	//20(89mm/s)时打印正常,纵向横向放大8倍打印测试顺畅
			//50(139mm/s)时打印正常
			maxstep = 50;		//10,20,50
		}
		else
		{	//15(78mm/s)时打印正常,纵向横向放大8倍打印测试顺畅
			//40(78mm/s)时打印正常,电机有突突启停,纵向横向放大8倍打印测试顺畅	
			//30(108mm/s)时打印正常,电机有突突启停
			//20(89mm/s)时打印正常,电机有突突启停
			maxstep = 15;		//5,15,40
		}
	}
	
	根据实际测试效果,将行间距15以上都使用最高速度,其他的使用变化的速度.
	实测行间距8点行时,满行汉字打印速度为150mm/s左右.
2.	当出现缺纸错误后,重新装纸后再打印之前等待一段时间.
	ReleaseEmergencyProtect()中添加延时.目前为等待2秒钟.
	测试通过.
3.	SystemTimer2Func()修改.将ReleaseEmergencyProtect()检测处理放到任务的最后.
	当打印内容少时直接打印,但是当一次发送内容较多(10K)时,电机先动一下,
	再停止一会才重新开始打印.打印内容无丢失.
4.	SystemTimer2Func()修改.将ReleaseEmergencyProtect()检测处理放到缺纸重打
	任务的前面,缺纸重打处理放到最后.
	表现同上.
5.	去掉2秒钟的等待.以上问题不出现.
	暂时不添加该延时.


程序版本:0.210
编写人员: 
编写日期:2013-2-20,21
目前程序编辑和打印处理方式为:
设置两个缓冲区,一个用来编辑打印内容的PrtDataBuf[]和下划线内容的UnderlineBuf[],
一个用来打印的g_tLinePrtBuf,其中包含一个与PrtDataBuf[]+UnderlineBuf[]大小相同的缓冲区Buf[].
在编辑时,直接操作PrtDataBuf[]和UnderlineBuf[].
在打印时,直接操作g_tLinePrtBuf.
编辑完毕开始打印之前,先将PrtDataBuf[]和UnderlineBuf[]的内容复制到g_tLinePrtBuf.Buf[]中,
再将打印控制变量PrtCtrlData的内容复制到g_tLinePrtBuf.PrtMode结构中,
然后在清除PrtDataBuf[]和UnderlineBuf[]的内容,将PrtCtrlData的内容赋值默认值.
打印时只操作g_tLinePrtBuf结构体.
1.	gstructInBuf全部改为g_tInBuf.
2.	gstructCharMaskReadBuf全部改为g_tCharMaskReadBuf.
	修改后测试通过.
标准ESC/P指令中对于pdf417的设置指令的设置项目:
nColumns			//设置数据区内容的宽度,=0,自动选择;最大不超过30
nRows					//设置行数,=0,自动选择;最大不超过90
nModuleWidth	//设置模块宽度,默认=3点宽,最大不超过8点
nRowHeight		//设置行高,=设置值*nModuleWidth,默认=3,最大不超过8,推荐值为3~5
ErrorCorrectLevel	//设置错误纠正等级,范围0~8,
ErrorCorrectRatio	//设置错误纠正比率,范围1~40,原始数据量*n*0.10=A,根据计算所得的A查表换算成错误纠正等级
Options				//设置编码选项:=0,标准PDF417;=1,截短PDF417

65 Function 065 PDF417: Set the number of columns in the data region
66 Function 066 PDF417: Set the number of rows
67 Function 067 PDF417: Set the width of the module
68 Function 068 PDF417: Set the row height
69 Function 069 PDF417: Set the error correction level
70 Function 070 PDF417: Select the options
80 Function 080 PDF417: Store the data in the symbol storage area
81 Function 081 PDF417: Print the symbol data in the symbol storage area
82 Function 082 PDF417: Transmit the size information of the symbol data in the symbol storage area
65 Function 165 QR Code: Select the model
67 Function 167 QR Code: Set the size of module
69 Function 169 QR Code: Select the error correction level
80 Function 180 QR Code: Store the data in the symbol storage area
81 Function 181 QR Code: Print the symbol data in the symbol storage area
82 Function 182 QR Code: Transmit the size information of the symbol data in the symbol storage area
65 Function 265 MaxiCode: Select the mode
80 Function 280 MaxiCode: Store the data in the symbol storage area
81 Function 281 MaxiCode: Print the symbol data in the symbol storage area
82 Function 282 MaxiCode: Transmit the size information of the symbol data in the symbol storage area
67 Function 367 2-dimensional RSS: Module width setting
71 Function 371 2-dimensional RSS: RSS Expanded Stacked maximum width setting
80 Function 380 2-dimensional RSS: Store data in the symbol archive area
81 Function 381 2-dimensional RSS: Print symbol archive area symbol data
82 Function 382 2-dimensional RSS: Send symbol archiv e area symbol data size information
67 Function 467 Composite symbol: Module width setting
71 Function 471 Composite symbol: RSS Expanded St acked maximum  width setting
72 Function 472 Composite symbol: Sele ct HRS character font
80 Function 480 Composite symbol: Store data in the symbol archive area
81 Function 481 Composite symbol: Print symbol archive area symbol data
82 Function 482 Composite symbol: Send symbol archive area symbol data size information

准备重新编写测试各个环节耗时的程序.
添加待检测环节的宏定义.

#ifdef	DBG_PROCESS_TIME_WAIT_LPB_ILDE	//打印一行开始前等待状态变为空闲的耗时
	u32	iTemp;
#endif
#ifdef	DBG_PROCESS_TIME_WAIT_LPB_ILDE	//打印一行开始前等待状态变为空闲的耗时
	StartProcessTimeCounter();
#endif
#ifdef	DBG_PROCESS_TIME_WAIT_LPB_ILDE	//打印一行开始前等待状态变为空闲的耗时
	StopProcessTimeCounter();
	iTemp = 0;
#endif

程序版本:0.211
编写人员: 
编写日期:2013-2-22
1.	添加2.0.3版本的systick设置相关的h和c文件.
	并修改其内容防止与3.5版本的头文件和宏定义冲突.编译通过.
2.	DMA1_Channel1_ADFunc()修改.修改纸将尽测量方法.静止时才处理.
	GetFeedPaperStatus()添加.
3.	InitStdPeriph()修改.添加Systick的初始化.Systick定时间隔10us.
4.	GetAscIIFlashDotData()修改.添加读取ASCII字符字库点阵的耗时测试.
	测试读取一个ASCII字符的耗时为120~140us之间.
5.	PrintGB18030()修改.添加读取汉字字库点阵的耗时测试.
	测试读取一个汉字的耗时为210~230us之间.
6.	ProcessCharMaskReadBufEdit()修改.添加编辑满一行的缓冲区处理时间测试程序.
	只测试填充完一个字符或者汉字的处理时间.总时间根据数量可以推测.
	默认设置选项时处理填充一个汉字耗时:110~130us.
	纵向横向放大8倍,旋转90°,反显,下划线2点,	1D 21 77 1B 56 01 1D 42 01 1B 2D 02 :
	处理一个汉字耗时:3800~3080us,平均3400us.
	加粗打印,纵向横向放大8倍,旋转90°,反显,下划线2点,1B 21 08 1D 21 77 1B 56 01 1D 42 01 1B 2D 02:
	处理一个汉字耗时:3800~3080us,平均3400us.
7.	CopyPrtDataToLineStruct()修改.添加耗时测试程序.
C3 AB D4 F3 B6 AB CD F2 CB EA C3 AB D4 F3 B6 AB CD F2 CB EA C3 AB D4 F3 B6 AB CD F2 CB EA C3 AB D4 F3 B6 AB CD F2 CB EA C3 AB D4 F3 B6 AB CD F2 CB EA 
1B 21 08 1D 21 77 1B 56 01 1D 42 01 1B 2D 02 C3 AB D4 F3 B6 AB CD F2 CB EA C3 AB D4 F3 B6 AB CD F2 CB EA C3 AB D4 F3 B6 AB CD F2 CB EA C3 AB D4 F3 B6 AB CD F2 CB EA C3 AB D4 F3 B6 AB CD F2 CB EA 
	测试程序为复制的同时即清空缓冲区的处理模式的程序.
	默认设置选项时处理复制并清空编辑缓冲区(不包括下划线)共耗时:60us.
	加粗打印,纵向横向放大8倍,旋转90°,反显,下划线2点,1B 21 08 1D 21 77 1B 56 01 1D 42 01 1B 2D 02:
	共耗时:460~480us,平均470us.
8.	PrepareNewLine()修改.添加耗时测试程序.
	默认设置选项时处理复制并清空编辑缓冲区(不包括下划线)共耗时:10us.
	加粗打印,纵向横向放大8倍,旋转90°,反显,下划线2点,1B 21 08 1D 21 77 1B 56 01 1D 42 01 1B 2D 02:
	共耗时:120~150us,平均140us.
9.	StartPrintLineBufChar(),StartPrintLineBufGraphic()修改.
	添加耗时测试程序.启动DMA后启动定时.
	DMA2_Channel2_IRQHandler()修改.添加耗时测试程序.DMA传输结束后停止定时.
	测试耗时:50~60us,平均60us.
10.	PrintOneLine()修改.添加耗时测试程序.测试打印一行耗时.Systick定时间隔10us.
	默认设置选项时(不包括下划线)打印(包括走行间距)共耗时:22500~22850us.平均22700us.
	Systick定时间隔改为100us.
	100us延时时耗时:25000~28200us.
	加粗打印,纵向横向放大8倍,旋转90°,反显,下划线2点,1B 21 08 1D 21 77 1B 56 01 1D 42 01 1B 2D 02:
	100us延时时耗时:156200~188000us,平均176000us.
11.	PrintOneLine()修改.添加耗时测试程序.
	测试打印一行开始前等待状态变为空闲的耗时.Systick定时间隔100us.
	默认设置选项时(不包括下划线,行间距32点行)共耗时:15200~16200us.平均15800us.
12.	根据以上测试结果,按照流程看完全可以实现超高速打印.
	条件同11,设置行间距为8点行,测试.第一次打印前等待15300us,从第2次开始,延时时间为0.
	条件同11,设置行间距为4点行,测试.第一次打印前等待15900us,从第2次开始,延时时间为0.
	根据测量结果数据计算可知,估计目前程序遇到的问题在于:
	编辑完缓冲区需要时间8200,走行间距最高速度568,8200/568=14.5.
	只有当行间距设置为15以上时才能达到最高速不停歇.其他的都会停下.
	根本原因在于在开始打印一点行后,再也没有能够去处理编辑下一行缓冲区的工作,
	所以编辑缓冲区一直为空,在走行间距的时间里才去继续编辑.
13.	PrintLineBuffer()修改.添加测试程序.
	测试进入打印控制中断的次数.打印汉字一行,32点行行间距共进入中断123次.
	除了开始和最后设置行间距各一次外,中间阶段每点行都会进入5次,合计24*5+2+1=123次.很正常.
14.	需要检查在开始打印一行后,是否还会去处理下一行的编辑.
15.	ADC正常工作,各个行间距下正常工作.


程序版本:0.212
编写人员: 
编写日期:2013-2-25
1.	添加测试程序,测试打印过程中编辑字符的个数g_iEditCountWhilePrt.
	PrintOneLine()修改.在打印一行开始时初始化统计个数为0,
	ProcessCharMaskReadBufEdit()修改,编辑过程中不断增加.
2.	统计参数程序,测试打印过程中SPI机芯发送数据的次数g_iSPISendCount.
	PrintOneLine()修改.在打印一行开始时初始化统计个数为0,
	StartPrintLineBufGraphic(),StartPrintLineBufChar()修改.每次DMA启动发送后增加.
	修改后测试发现,第一次打印,SPI发送完7次后,下一行即已经编辑完成等待打印.
	第二次打印,SPI发送完1次后,发送第2次之前,下一行会连续编辑完全部24个字符.
	因为中间走32点行间距的时间里面完全可以编辑完成全部24个字符.
3.	通过测试看,边打印边编辑的流程确实实现了.
	giLineEditBufStatus状态为ILDE和WAIT_TO_PRT看来没有必要区分.
	因为一旦编辑行缓冲区满后,就会等待直到打印该缓冲区为止,打印完毕立即清除为ILDE.
	实际上不会再有机会判断该变量为WAIT_TO_PRT的时候.所以没有意义.
4.	设置行间距为4点.继续测试.
	第一行打印结果同2.第一行从第1次到第7次发送SPI处理过程中共耗时:16549us
	在此期间处理完毕24字符内容.每字符平均耗时690us.
	第二行打印时,SPI开始发送第1次时,字符处理完毕5个,发送2/3次时,字符处理完毕6个,
	以后都是每发送2次SPI的时间里处理完毕2个字符,即每走两点行高的时间内处理2个字符.
	发送23次时,处理完毕16个字符.没有完全处理完毕24个字符.此时最高速度789us/点行高.
	处理每个字符平均耗时789*2=1578us.
	按照之前的测试平均每读取并编辑一个字符的耗时为220+120=340us.
5.	测试过程中发现有时SPI发送统计计数值总是维持在某个值不变,
	好似中间停止进入处理打印流程了.
	StartPrintLineBufChar()修改打印处理程序,将SPI发送改为正常循环处理程序实现测试.
	设置行间距为4点.继续测试.测试发现SPI发送过程中下一行的24个字符总是能够提前完成.
	设置行间距为0点.继续测试.测试发现SPI发送过程中下一行的24个字符总是能够提前完成.
6.	GetMaxAccelerateStepsOfLineSpace()修改.不限速.
	设置行间距为0点.继续测试.测试发现SPI发送过程中下一行的24个字符总是能够提前完成.
7.	实际打印测试.
	行间距从0开始直到32点,打印过程中都不会出现压缩等现象.内容打印都正确,只是电机出现突突的现象.
8.	PrintLineBuffer()修改.除了状态ILDE外,其他状态WRITING和SPI_SENDING都不关闭定时器.
	修改后打印效果同上.
9.	SPI发送以DMA实现,效果基本同上.
10.	CutPaper()修改.添加虚拟切纸操作.
	在走行间距时设置断点,当程序进入设置走行间距时,出现下一行未编辑完成的现象.
11.	调试发现,编辑过程中出现打印控制定时器不再进入的现象,SPI_SENDING的次数统计小于24,
	并维持某个数值一直不变.实际应该一直增长为24.
	PrintLineBuffer()修改.将ILDE时停止定时器的处理去掉.调试效果同上.
12.	ADC使能.一次同时启动两次ADC.
	行间距大时会出现压缩和打印中途停止.
	一次启动1次ADC.效果不变.
13.	禁止判断ADC各个状态变量的处理后测试正常.不禁止工作不正常.



程序版本:0.213
编写人员: 
编写日期:2013-2-25
1.	DBG_DUMMY_CUT去掉.
	SystemTimer2Func()添加额外开启打印控制定时器的启动操作.
	测试发现出现测量外部电压值错误的现象.
2.	关闭ADC的设置.SystemTimer2Func()恢复修改.
	测试发现,打印发送SPI数量已经完成24,而编辑字符一般只完成6~7左右.
	编辑处理的效率过低.
	打印控制处理中断最后将不断进入.
	PrintLineBuffer()中ILDE时关闭定时器.
3.	机芯SPI发送恢复使用DMA方式测试.2使用循环程序发送.
	测试发现,打印发送SPI数量已经完成24,而编辑字符一般只完成14~17左右.
4.	giLineEditBufStatus相关的赋值和判断都去掉.
	ProcessCharMaskReadBufIlde()修改.将接收缓冲区数据量判断放到前面.
	ProcessCharMaskReadBufEdit()修改.
5.	修改后测试,打印发送SPI数量已经完成24,而编辑字符一般只完成19~20左右.
	实际打印测试无论行间距多少都压缩,电机突突.
6.	恢复根据行间距判断最高速度的处理后,行间距从0开始打印都正常.
7.	使用微库,优化等级2,速度优先选项设置后编译,测试.
	测试打印会出现压缩.
	不使用微库,优化等级2,速度优先选项设置后编译,测试.
	测试打印会出现压缩.
	不使用微库,优化等级0,速度优先选项设置后编译,测试.
	测试行间距从0开始打印都正常.
8.	将SPI1的发送由循环改为DMA模式,接收由查询改为中断实现.
	sFLASH_Init()修改.
	sFLASH_DMAInit()修改.
	只有读字库时才采用DMA发送,中断接收模式处理.
	其他时候使用循环发送,查询接收处理.注意修改程序添加禁止中断接收.
	初始化时按照循环发送,查询接收处理.
	设置一个标志变量g_cZikuDMATxStartFlag.DMA传输开始时置为1,DMA传输完毕后清0.
	在读字库时,先设置DMA的起始内存地址和传输的字节长度,置g_cZikuDMATxStartFlag = 1,
	设置SPI1接收中断允许,然后启动DMA发送,主程序中一直等待其变为0.
	变为0表示DMA传输全部完成.接收中断中一直接收.
	sFLASH_EraseSector(),sFLASH_WriteBuffer(),sFLASH_FastReadBuffer(),
	sFLASH_EraseBlock(),sFLASH_WritePage()修改,开始部分添加禁止接收中断.
	sFLASH_StartDMATx()添加.设置传输的起始地址和数据字节长度.
	ZIKU_SPI_SEND_BY_DMA添加.
9.	InitStdPeriph()修改,添加sFLASH_DMAInit().
	InitNVIC()修改,添加DMA1_Channel3_IRQn,SPI1_IRQn的处理.
	SPI1_IRQHandler(),DMA1_Channel3_IRQHandler()修改.添加中断处理.
10.	测试程序有问题.打印错误.
11.	禁止判断ADC各个状态变量的处理后测试正常.
	ADC采集处理的程序还是有问题.


程序版本:0.214
编写人员: 
编写日期:2013-2-26
以0.211版本修改.0.211版本工作正常.
1.	添加测试程序,测试打印过程中编辑字符的个数g_iEditCountWhilePrt.
	PrintOneLine()修改.在打印一行开始时初始化统计个数为0,
	ProcessCharMaskReadBufEdit()修改,编辑过程中不断增加.
2.	添加测试程序,测试打印过程中SPI机芯发送数据的次数g_iSPISendCount.
	PrintOneLine()修改.在打印一行开始时初始化统计个数为0,
	StartPrintLineBufGraphic(),StartPrintLineBufChar()修改.每次DMA启动发送后增加.
	修改后测试发现,第一次打印,SPI发送完7次后,下一行即已经编辑完成等待打印.
	第二次打印,SPI发送完1次后,发送第2次之前,下一行会连续编辑完全部24个字符.
	因为中间走32点行间距的时间里面完全可以编辑完成全部24个字符.
3.	CutPaper()修改.添加虚拟切纸操作.
	修改后实际测试打印各个行间距都工作正常.
4.	0.213和0.214版本的其他修改不再添加.
	0.214版本修改是为了实现字库读取时采用DMA发送,中断接收方式实现.
5.	添加测试ADC采集的效果.DBG_ADC_PRECISION添加.
	ADC转换次数原为8次,改为1次.gstructAD改为g_tADC.
	设置一个全局数组g_u16DbgADCBuf[],存储每次ADC的结果.到达设定次数,观察其值的一致性.
	累计10取平均.测量结果显示10组数据的一致性非常好,各组值也没有错位的现象.
	ADC_COUNT由10改为8.
	当间隔1ms采集一次AD时,如果以最高速度计算,走纸距离1*8/0.568/*0.125=2.2mm
	为间隔更新一次ADC的纸尽,温度,电压,黑标等标志.
6.	全部接收完毕再处理测试.
	行间距设置为0,打印发送SPI数量已经完成24,而编辑字符一般只完成19~20左右.
	有时候也能与其同步完成.大部分时候编辑速度要落后于打印速度.
	这样行间距小时就无法保证在打印完成之前编辑完成下一点行的内容了.
7.	通过测试看,边打印边编辑的流程确实实现了.
	giLineEditBufStatus状态为ILDE和WAIT_TO_PRT看来没有必要区分.
	因为一旦编辑行缓冲区满后,就会等待直到打印该缓冲区为止,打印完毕立即清除为ILDE.
	实际上不会再有机会判断该变量为WAIT_TO_PRT的时候.所以没有意义.
	下一版本开始修改此问题,不再分开,而保持为一次完成以提高编辑效率.
	本版本各种行间距打印正常.
8.	StartPrintLineBufChar()修改,往机芯发送数据数据的DMA启动后,
	添加一个发送次数的判断,定位再次检查已编辑的字符数.
	限速.行间距0点行.测试发现,上一行发送24点完毕,下一行编辑完成的汉字为24个.
	不限速.行间距0点行.测试发现,上一行发送24点完毕,下一行编辑完成的汉字为5到7个,一般为6个.
9.	添加测试读字库编辑填充字符满一行的时间检测程序.
	PrintOneLine()修改,打印一行开始,清空编辑缓冲区后开始定时,
	ProcessCharMaskReadBufEdit()修改,一行编辑满后停止定时.
	不限速.行间距0点行.测试处理1行字符最少12400us(处理第一行),最多时17100us.
	一般耗时在12400到16500us之间来回切换.按照最高速度计算17100/568=29点行高.
	12400/568=22点高.
	处理每个汉字速度最快12400/24=517us,最慢17100/24=713us.


程序版本:0.215
编写人员: 
编写日期:2013-2-26
将CharMaskBuf的处理流程改为ReadInBuf的处理流程.
while (1)
{
	CheckFeedButton()
	CheckMaintainRoutin()
	ProcessCharMaskReadBuf()
		->ProcessCharMaskReadBufIlde()
				->if (SystemCtrlStruct.PrtDevOe) 	//打印机被禁止
					{
						Command_1B3D();
					}
					else
					{
						ReadChar = ReadInBuffer();	//读取接收缓冲区
						DataProcess(ReadChar);			

//处理该字符,可能是命令或者可打印字符,如果是可打印字符则启动SPI读取
					}
		->ProcessCharMaskReadBufEdit()
				->JudgeLineBufFull()
						->IF FULL->PrintOneLine()
						->FillLinePrintBuf()
						->InitCharMaskBufParameter()
}
修改为
while (1)
{
	if (SystemCtrlStruct.PrtDevOe) 	//打印机被禁止
	{
		Command_1B3D();
	}
	else
	{
		ReadChar = ReadInBuffer();	//读取接收缓冲区
									->CheckFeedButton()
									->CheckMaintainRoutin()
		DataProcess(ReadChar);			//处理该字符,可能是命令或者可打印字符,如果是可打印字符则启动SPI读取
			->IF CMD->ProcessCMD
			->IF PRTABLE->PrintChar()
										->JudgeType
										->GetDot
										->JudgeLineBufFull()
										->IF FULL->PrintOneLine()
										->FillLinePrintBuf()
										->InitCharMaskBufParameter()
	}
}
1.	ProcessInBuf()添加.
	ReadInBuffer()修改.添加处理CheckMaintainRoutin().
	PrintChar()修改.修改判断处理.具体执行不受影响.效果同之前.

	ProcessInBuf()的处理如下:
		->ReadInBuffer()
		->DataProcess()

	DataProcess()的处理如下:
		->PrintChar()
		->ESC_Command()
		->FS_Command()
		->GS_Command()
		->RS_Command()
		->MonoByte_Command()

	PrintChar()的处理如下:
		->PrintAscII()
				->GetAscIIDotData()
						->GetAscIIUserDefDotData()
						->GetAscIIFlashDotData()
		->JudgePrintSelfDefChinese()
				->PrintUserHZ()
				->PrintGB18030()
				->PrintAscII()
		->JudgePrintGB18030()
				->PrintGB18030()
				->PrintAscII()
		->JudgePrintBIG5()
				->PrintBIG5()
				->PrintAscII()
		->EditCharMaskReadBuf()
				->JudgeLineBufFull()
				->PrintOneLine()
				->FillLinePrintBuf()
				->InitCharMaskBufParameter()
	最后的程序都是读取点阵内容放到全局变量里面.
2.	PrintChar()修改.添加判断编辑缓冲区是否满,
	根据结果处理是否打印当前行,填充当前字符的点阵的处理.
	EditCharMaskReadBuf()新函数添加处理以上事务.
	其工作与ProcessCharMaskReadBufEdit()基本相同.
3.	main()修改为新流程.
4.	Command_1D5E()修改,ProcessCharMaskReadBuf()调用的地方改为ProcessInBuf().
	PrintASCIICharactor(),PrintString()修改,
	ProcessCharMaskReadBuf()调用的地方改为EditCharMaskReadBuf().
5.	修改流程后新流程可以正常打印.各种点数行间距的效果同0.214.
	仿真测试编辑速度基本同0.214.
	SPRT网络接口驱动打印测试效果比0.213稍差.可能需要调整驱动接收等待时间.
	关闭限速,行间距小于9时可以打印,无压缩,但是电机突突.行间距打印16,打印正常.
	在此之间会出现压缩.
	仿真没有发现在打印结束之前没有编辑完的现象.
6.StartPrintLineBufChar()修改,往机芯发送数据数据的DMA启动后,
	添加一个发送次数的判断,定位再次检查已编辑的字符数.
	限速,行间距0点行.测试发现,
	上一行发送24点完毕,下一行编辑完成的汉字为23到24个,一般为24个.
	不限速.行间距0点行.
	测试发现,上一行发送24点完毕,下一行编辑完成的汉字为5到7个,一般为6个.
7.	SetGoLineSpace()中添加进入该部分程序次数的统计修改.
8.	通过以上测试可见,修改为0.215的流程并没有提高编辑处理的效率.
	与0.214版本的相比,编辑的速度没有区别.
9.	添加测试读字库编辑填充字符满一行的时间检测程序.
	PrintChar()修改,启动开始定时,
	EditCharMaskReadBuf()修改,结束定时.
	不限速.行间距0点行.测试处理1个字符一般耗时700us.最多时1200us.
10.	修改以上测试程序,
	PrintChar()修改,去掉启动开始定时,
	PrintOneLine()修改,打印一行开始,清空编辑缓冲区后开始定时,
	EditCharMaskReadBuf()修改,一行编辑满后停止定时.
	不限速.行间距0点行.测试处理1行字符最少9700us,最多时28200us.
	一般耗时18600us.按照最高速度计算18600/568=32点行高.
	测试效果与0.214版本基本相同.
	自检打印缺纸时会死机,16进制打印会出现错误的换行.待修改.


程序版本:0.216
编写人员: 
编写日期:2013-2-26
以0.214版本修改.
0.214,0.215版本工作都正常.
根据行间距限制速度.设置行间距0点行.
1.	定时器间隔10us下测试.
	JudgePrintGB18030()修改.添加测试分析字符种类,首地址等信息耗时程序.
	分析+字库读取共耗时340~390us,一般为360us.
	读汉字字库耗时320~400us,一般为350us.
	处理填充汉字耗时110~150us,一般为130us.
	分析,读取,编辑填充一个字符至少需要550us.
	目前字库读取采用快速读取指令实现.
2.	定时器间隔100us下测试.
	读汉字字库耗时300~600us,一般为300us.
	由此可见滴答定时器时间间隔对测量结果影响较小.
	滴答定时器中断修改,计数值直接加10.
3.	字库读取时间过长,只有压缩了字库读取时间才有可能提高速度.
	一个汉字字模共72字节,576位.
	机芯发送数据量为640位,DMA发送耗时60us(有待再次测试一遍).
	机芯SPI的时钟速度为9M,而字库SPI的时钟速度为36M,完全有可能做到高速读取.
	将字库读取改用DMA接收方式实现,其他的读写使用查询方式.DMA的主优先级设置为2.
	字库读之前先设置DMA,初始化DMA的数量等信息,先发送快速读命令,地址,
	然后启动DMA接收,使能DMA中断,设置一个标志变量,然后一直等待该标志变量改变.
	在DMA接收中断中完成全部接收后清除该标志变量.
	主程序检测到标志变量清除后,禁止DMA,防止冲突.

	
程序版本:0.221
编写人员: 
编写日期:2013-3-1
以0.216版本修改.0.217~0.220版本为修改字库接收用DMA方式的程序.
1.	优化快速读取函数进行测试.sFLASH_SendByte()改写.优化效率.
	while (!(SPI1->SR & SPI_I2S_FLAG_TXE));	//等待TXE=1
	SPI1->DR = ;	//写入第一个字符,开始发送,同时清除TXE
	while (!(SPI1->SR & SPI_I2S_FLAG_RXNE));	//等待RXNE=1
	 = SPI1->DR;	//读SPI接收到的数据,同时清除了RXNE
	//重复以上步骤,每次都发送并接收到一个数据
	while (!(SPI1->SR & SPI_I2S_FLAG_RXNE));	//等待RXNE=1,接收最后一个数据
	 = SPI1->DR;	//读SPI接收到的数据,同时清除了RXNE
	while (!(SPI1->SR & SPI_I2S_FLAG_TXE));	//等待TXE=1,在BSY=0后关闭SPI.
2.	StartProcessTimeCounter()修改,只启动使能.
	StopProcessTimeCounter()修改,只停止和清计数器值为初始值.
	InitSystick()修改,添加g_iDbgProcessTimeUs定义时设置为0;在中断中只累加;
	StopProcessTimeCounter()执行后主程序中需要重新将其设置为0.
3.	使用查询方式读取,2分频.禁用行间距调整最高速度处理.行间距4点.
	测试判断行满,编辑填充1个汉字,清空点阵缓冲区共耗时	:110~140us.一般为110us.
	测试分析汉字地址及读取汉字点阵需要时间为	:110~130us,一般为110us.
	测试填满一行的编辑缓冲区耗时,包括读字库和编辑填充时间	:6000~7300us,一般为6000us.
	根据该值,填满一行需要的时间比打印一行需要的少一半.
4.	实际打印测试,行间距0,行间距4及以上时不会压缩.
	行间距1,2,3时会出现行压缩.
	行间距8一次打印数量多时也会出现压缩.
5.	关闭ADC处理各测试状态变化的处理测试.
	行间距8一次打印数量多时还会出现压缩,只是压缩的次数减少.
6.	恢复ADC处理.
	FEED_MOTOR_ILDE_NUMBER由3改为1.相当于电机维持高速时只等待1次上一次电机的时间.
	修改后效果同上.将26行内容压缩成了一行.
	压缩时电机嗡嗡叫但是不转.相当于电机憋住.
9.	FEED_MOTOR_MONITOR_ENABLE去掉.
	修改后电机压缩的次数更多.
	行间距8点时打印速度看来能达到最高值.只需要处理好电机速度调整就可以了.
10.	FEED_MOTOR_MONITOR_ENABLE使能.
	改用1/8步驱动测试.STEPNUMBER改为8.
	行间距8点时,一次打印数量多也不再压缩,但是感觉速度低.
	行间距4点时,压缩.
	行间距0点,不压缩.
	行间距5点及以上时,基本不会出现停顿现象,打印处理连贯.
	行间距4点时,会出现停顿现象.
11.	GetMaxAccelerateStepsOfLineSpace()修改.
	5点及以下时才限速,5点以上不限速.限速设置:
	行间距0,加速 30;
	行间距1~5,加速 30+LineSpaceDotNumber * 5;
	实际测试效果良好.
	
	继续修改为:
	行间距0,加速 50;
	行间距1~5,加速 50+LineSpaceDotNumber * 10;
	实际测试:
	行间距0:电机突突.
	行间距1及以上均正常.
	
	继续修改为:
	行间距0,加速 40;
	行间距1~5,加速 60+LineSpaceDotNumber * 10;
	实际测试:
	行间距0:电机突突.
	行间距1及以上均正常.
	
	继续修改为:
	行间距0,加速 30;
	行间距1~5,加速 70+LineSpaceDotNumber * 10;
	实际测试:
	行间距0,5:电机突突.
	行间距1,2,3,4均正常.

	继续修改为:
	行间距0,加速 20;
	行间距5,加速 110;
	行间距1~4,加速 70+LineSpaceDotNumber * 10;
	实际测试:
	行间距0:电机突突.
	行间距1,2,3,4,5均正常.

	继续修改为:行间距0时设置为15.
	行间距0:电机突突.
	继续修改为:行间距0时设置为10.
	行间距0:电机正常.
	其他行间距均正常.


程序版本:0.222
编写人员: 
编写日期:2013-3-1
1.	SPI_HeatSendByte()修改.改成循环方式发送,与SPI1优化后的方式相同.
	添加查询方式发送一点行数据的测试程序.
	测试PrintOneDotLine()中SendHeatElementBufToCore()的执行时间.
	SP驱动程序测试,耗时190~210us,一般耗时200us.
2.	继续修改机芯发送一点行数据的处理.改成用DMA方式.
	添加全局变量g_cPrtSPIDMATxStatusFlag.发送前置为1,发送结束在中断中清零.
	主程序中只需要检测等待该值变为0即可.
	添加全局变量g_cPrtSPIDMAIntForDriveMode,用来区分DMA中断是为了什么情况.
	当使用打印缓冲区处理时,该值为0.当驱动模式下循环逐点行处理时,该值为1.
	初始化为0,表示中断为处理打印缓冲区.
	驱动打印或者图形模式下逐点行打印时,DMA发送前设置为1,DMA发送完毕清零.
3.	SendHeatElementBufToCore()修改.添加为条件编译程序.
	DMA2_Channel2_IRQHandler()修改.添加按两种情况的处理.
	SendHeatElementBufToCore()只在PrintBarBitmap()和PrintOneDotLine()中调用.
		PrintBarBitmap()只在PrintBar()中调用.
		PrintOneDotLine()只在Command_1C50(),Command_1D76(),Command_16()中调用.
	以上所有涉及调用均是按照逐点行使用方式,所以只修改SendHeatElementBufToCore()即可.
4.	修改后测试.
	SP驱动程序测试,耗时60~70us,一般耗时70us.完全为高速.
5.	因以上调用的地方打印之前已经将待加热数据提取处理好,所以速度可以设置的较高.
	MAX_RUSH_STEPS_ON_DRV_PRT由28改为68.其他分端口的也全部改为28和68.
6.	修改后测试.
	SP驱动程序测试,网口和U口都可以打印.网口打印停顿多,U口打印有一次拉开.
	字符指令模式打印正常.
7.	ReadInBuffer()修改.添加驱动时的延时等待.ETH和COM的等待时间改为20.
	修改后ETH打印效果有好转.需要将速度降低一下.
8.	COM延时改为150.速度调整COM: 28,	ETH/USB: 58.
	修改后测试:COM打印效果尚可,延时150过多.ETH/USB有待继续降速.
9.	COM延时改为50.ETH延时改为10.速度调整COM: 28,	ETH/USB: 48.
	修改后测试:效果同上.
10.	取消延时,速度调整COM: 20,	ETH/USB: 38.
	修改后测试:COM 115200打印效果改善,可适当降速.
	ETH效果基本可以,USB需要适当降速.
11.	速度调整COM: 15,	ETH/USB: 30.
	修改后效果均可接受.还可以往下调整.
	SP驱动打印正常.WH驱动打印乱码.
	分别使用之前的测试用例测试,全部正常.包括1B13图形指令.
	打印条码时打印浓度有些浅.
12.	ETH/USB改为25.MAX_RUSH_STEPS_ON_DRV_PRT由68改为38.
	SP驱动打印正常,效果合适.
	条码打印效果很好.
13.	以上测试为机芯数据使用非DMA发送方式进行的.
14.	改用DMA发送方式测试效果同12.


程序版本:0.223
编写人员: 
编写日期:2013-3-1
将行间距相关的程序按照EPSON编程手册为标准修改.
行间距 > 行高,走间距值(行间距 - 行高).否则走行间距0.
PrtCtrlData.CodeLineHigh
PrtCtrlData.LineHigh
ptLPB->PrtMode.CodeLineHigh
ptLPB->PrtMode.MaxLineHigh
1.	PrintBlackBlock()修改.行高设置修改.
	PrintBarHRI()修改.行高设置修改.
	PrintOneLine(),GetMaxAccelerateStepsOfLineSpace(),SetGoLineSpace()修改.
	将行间距相关的程序按照EPSON编程手册为标准修改.
	修改完毕.
	测试行间距从0到32,字符打印与预期符合.条码打印正常.
2.	纵向横向移动单位设置指令及相关指令有待检查并一致起来.
编写日期:2013-3-5
3.	ITF输入数据为奇数时,打印的HRI里会将最后一个字符换行打印.实际应该不打印该字符.
	应该将最后一个字符忽略.
	Command_1D6B()修改.处理ITF时,数据个数为奇数时,处理完毕额外多读取一个字节并丢弃.
	修改后测试正常.
4.	组装一台测试.
	SP驱动打印时U口正常,网口ERROR一直闪烁报错,打印效果差.
	在未组装的机器上测试无此现象.
5.	PrintOneLine()修改.0A指令按照新手册定义执行.
	如果缓冲区为空,直接走行间距.
6.	0D指令按照新手册定义执行.
7.	RealTimeStatusStruct全部改为g_tRealTimeStatus.
	Command_1004()按照新规定检查.


程序版本:0.224
编写人员: 
编写日期:2013-3-5
1.	RealTimeStruct全部改为g_tRealTime.
	ErrorStruct全部改为g_tError
	Drawer全部改为g_tDrawer
	MacroStruct全部改为g_tMacro
	BarCtrlStruct全部改为g_tBarCodeCtrl.
	TabStruct全部改为g_tTab
	Interface全部改为g_tInterface
	RamBuffer全部改为g_tRamBuffer
	SystemCtrlStruct全部改为g_tSystemCtrl
	SysConfigStruct全部改为g_tSysConfig
	PrtModeChar全部改为g_tPrtModeChar
	PrtModeHZ全部改为g_tPrtModeHZ
	BarCode2DStruct全部改为g_tBarCode2D
	UnderlineBuf改为g_tUnderlineBuf
	PrtCtrlData改为g_tPrtCtrlData
	PrtDataBuf改为g_tPrtDataBuf
	PageModeStruct改为g_tPageModeStruct
	SysDefaultValue改为g_ctSysDefaultValue


程序版本:0.225
编写人员: 
编写日期:2013-3-5
1.	
	Command_1004()按照新规定检查.
		修改打印机状态和脱机状态的计算,添加因为按下上纸键因而走纸的处理.
	Command_1005n()按照新规定检查.
	Command_1014fnmt()按照新规定检查开钱箱处理.
	1B20设置字符右间距指令检查.
	1B21设置字符打印模式指令检查.
	1B24设置绝对打印位置指令检查.
	1B25选择/取消用户自定义字符指令检查.
	1B26用户自定义字符指令检查.
	1B2A设置位图修改.
		修改位图数据的最大值参数.原接收最大数据值计算顺序错误.
		修改打印控制变量的赋值.中途打印一行后重新赋值防止下次打印剩余图形时控制变量错误.
编写日期:2013-3-6	
2.	1B2D打开关闭下划线指令检查.
	1B31设置n点行间距检查.
	1B32设置默认行间距检查.
	1B33设置n点行间距检查.
		修改程序,按照说明书执行,统一换算成点数值.
		g_tPrtCtrlData.StepHoriUnit计算结果为点数.
		g_tPrtCtrlData.StepVerUnit计算结果为电机微步数.
	1B3D选择/禁止打印机检查.
	1B3F取消用户自定义字符,
		添加参数错误情况的处理.修改字符范围判断.
	1B40初始化打印指令检查.InitParameter()修改.
		添加根据输入参数决定是否更新InitMaintainParameter().
	1B44设置横向跳格位置检查.
	1B45设置加重打印检查.
	1B47设置双重打印检查.
	1B4A打印并走指定行间距值检查.
		修改程序.根据指定行高和行间距设置.
	1B4D选择字符字体检查
	1B52选择国际字符检查.
		InitSystemCtrlStructParameter()按照说明书修改.
	1B56处理90°旋转检查.
	1B5C设置相对横向打印位置检查.
		修改移动值计算.原计算错误.
	1B61对齐方式设置检查.
	1B6333选择纸传感器输出缺纸信号检查.
		目前只进行赋值但是在停止打印条件方面未根据该值处理.改点待完善.
	1B6334选择纸传感器停止打印信号检查.按照新说明书修改,添加变量赋值.
		目前只进行赋值但是在停止打印条件方面未根据该值处理.改点待完善.
	1B6335禁止按键检查.
	1B64打印并走纸n行检查.
		修改程序.重新实现.
	1B70产生开钱箱脉冲检查.
	1B74选择代码页检查.
	1B7B选择倒置打印检查.
	1C50打印预下载位图检查.
	1D21选择字符纵向横向放大倍数检查.
	1D2841执行测试打印检查.
		HexMode()修改,进入16进制模式时打印提示信息前先置忙关闭接收主机信息,
		打印完毕提示信息后再开始接收.
	1D2844允许实时指令检查.
	1D2A定义下载RAM位图修改.修改宏定义.
		Command_1D2A()修改参数计算.
	1D2F打印下载位图检查.
	1D3A开始/结束宏定义检查.
	1D42黑白反显检查.
	1D49查询打印机 ID 号检查.
		修改回复信息.


程序版本:0.226
编写人员: 
编写日期:2013-3-7
1.	
	1D4C设置左边距检查.
		先判断是否符合条件再具体计算参数防止多余计算.设置左边距时确保能放下至少一个字符.
	1D50设置最小移动单位检查.
	1D56切刀指令检查.
	1D57设置打印区域宽度检查.
	1D5E执行宏指令检查.
		修改执行宏的判断条件.原条件错误.添加变量初始化.修改指示灯闪烁实现.
	1D61设定自动状态返回(ASB)检查.
		AutomaticStatusBack()修改.无需判断哪些状态有变化,一律回传.
	Command_1D67()修改.
		1D67的处理分别放到两个函数里面.
	1D6730初始化维护计数器检查.新添加.
		WriteFlashParameter()修改.关闭实时指令允许,关闭ASB状态返回允许.写入完毕再恢复.
	1D6732传送维护计数器检查.新添加.
	StepFeedMotor()修改.
		修改维护计数器值走纸行数的计算.每32点行作为1行.
	ProcessHeatAndMotor()修改,
		维护计数器加热次数统计移除,放到StartHeat()中处理.
	StartHeat()修改,
		维护计数器加热次数统计添加.
	1D72传送状态检查.
	1C21设置汉字字符模式检查.
		Command_1C21()修改判断条件.功能相同.
	1C26选择汉字模式检查.
	1C2D汉字下划线检查.
		Command_1C2D()修改,去掉3点厚度的设置.
	1C2E取消汉字模式检查.
	1C32定义用户自定义汉字检查.
	1C43选择汉字代码系统检查.
	1C53设置汉字字符左右间距检查.
		页模式下的处理有待完善.
	1C57选择/取消汉字倍宽倍高检查.
	1D48选择 HRI 字符的打印位置检查.
	1D66选择 HRI 使用字体检查.
	1D68选择条码高度检查.
	1D77设置条码宽度检查.
	1B69半切检查.
	1B6D半切检查.
	1B75传送外围设备状态检查.
	1B76传送纸传感器状态检查.
	1D7630打印光栅位图检查.
	除了条码打印指令外已经全部检查完毕.


程序版本:0.227
编写人员: 
编写日期:2013-3-8
2.	Command_1B13()修改.
	原程序有错误.添加判断数据量,为0直接退出.
	编辑之前先设置打印控制变量及指针,中途打印完一行后再设置打印控制变量和指针.
	这样无需每个字符都设置判断一次打印控制变量.
3.	SP网口驱动打印测试过程中告警灯经常告警.
	调试发现ADC测量结果错误.每次ADC采集到的值都错传输错位.
	0.211版本的测试打印正常.应该是DMA冲突导致.
	将ADC采集的次数ADC_CONVERT_NUMBER由1改为2,调试发现ADC测量值不再出现错位现象.
	修改后SP网口驱动打印测试正常.


程序版本:0.228
编写人员: 
编写日期:2013-3-11
1.	MIN_STEP_UNIT_X改为0.125,MIN_STEP_UNIT_Y改为0.125.
	g_tPrtCtrlData.StepHoriUnit,g_tPrtCtrlData.VerHoriUnit一律按点数计算.
2.	Command_0D()改为功能与0C相同.
	WHKJ的驱动使用0D作为换行.修改后WH驱动打印正常.
	使用该版本进行测试.
3.	按照P04P25最终使用的管脚修改程序.
	parallel.h文件中修改宏定义.c文件中设置管脚速度最高为50M.
	InitNVIC(),ReceiveInterrupt()修改并口中断源.
	stm32f1x_it.c修改并口中断处理程序.EXTI9_5_IRQHandler()替代EXTI0_IRQHandler().
4.	还需要添加根据缺纸停止打印和告警传感器选择输出PE缺纸信号和控制并口打印的停止的程序.
编写日期:2013-3-13
5.	Command_1B26()修改.将条件判断尽可能放到前面防止不必须的变量初始化处理.
	GetAscIIDotData()修改.修改自定义字符范围的判断条件,原条件多了一个字符.
	GetAscIIUserDefDotData()修改.添加防止参数错误的处理.
6.	Command_1D50()修改.添加默认值的宏定义.重写四舍五入的实现.
	InitPrtCtrlDataParameter()修改,修改默认移动单位,使用宏定义.


程序版本:0.229
编写人员: 
编写日期:2013-3-14
1.	使用4.50版本编译后测试还出现ADC各个通道串通的错误.
2.	采集次数改为1次.DMA1_Channel1_ADFunc()中处理完毕后调用ADC_DMA_Config(),目的是复位DMA.
	修改后调试没有发现ADC值通道串.
3.	Command_1D5E()修改.修改参数判断.MacroRunMode不需要检测.
4.	GetCodeBarStr()修改.修改1D6B第一条指令时的处理.
	将两种情况分别单独处理.先假定最大可能的参数值,再按照其进行读取数据,
	根据实际读取的情况判断输入的参数是否符合规定.
5.	字符汉字组合处理时还有错误.
	FillPrintBuff()修改.将横向放大倍数的读取放到函数中执行,而不是作为参数传入.
	FillLinePrintBuf()修改.配合FillPrintBuff()修改而修改调用函数.
编写日期:2013-3-15
6.	测试达不到最高速度,一般最高速度为150mm/s.去除限速也是如此.
7.	InitFeedPort()管脚速度由10M提高到50M.测试效果相同.
	如果只走纸,可以达到最高速度220.
8.	去掉根据行间距限速处理.改用1/4步驱动方式测试.
	测试行间距32点时整行压缩.
	改用半步驱动方式测试,整行压缩,电机不走动.
	改用整步驱动方式测试,速度150,无压缩,加热浓度过深.
9.	保持整步驱动不变,将计算加热时间人为减半.
	测试打印浓度正常,但是电机会出现走不动的现象.
10.	PaperCoefficent[]值改变.改用1/8驱动方式.
	测试打印浓度尚可,但是速度还是最高150.
11.	估计目前程序处理速度足够,但是电机的驱动能力不足导致.
当按下上纸键后在一直上纸过程中,出现纸将尽的现象,则纸将尽信号不能及时更新.LED也不出现告警.
当出现告警后PNE,再按下上纸键,则死机,一直维持PNE告警状态.


程序版本:0.230
编写人员: 
编写日期:2013-3-15
1.	使用1/8驱动,恢复限速调整,测试打印过程中电机停止的次数统计,
	发现电机批量打印过程中没有停止过.
	FEED_MOTOR_ILDE_NUMBER由3改为1.电机停止次数比为3时增多一点.24次.
2.	将加热时间改为固定值10,测试.
	打印同样内容,电机停止2754次.
	将加热时间改为固定值0,测试.死机,程序死等打印缓冲区状态变为ILDE.
3.	恢复加热时间正常计算,固定为一次加热测试.
	打印同样内容,电机停止24次.
	FEED_MOTOR_ILDE_NUMBER由1改为2.打印同样内容,电机停止9次.
	FEED_MOTOR_ILDE_NUMBER由2改为3.打印同样内容,电机停止9次.
4.	GetFeedPaperStatus()修改.
	目前判断打印机是否为静止的条件与PNE更新存在潜在冲突.
5.	EndFeedMotor()修改.将gStepCount = 0;gMotorRunFlag = 0;的处理都放在函数中.
	StartFeedMotor()修改.将gStepCount = 0;gMotorRunFlag = 1;的处理都放在函数中.
6.	常温下TEMPADC = 2057, 打印一段后为1719, 1587


程序版本:0.231
编写人员: 
编写日期:2013-3-18
1.	StartPrintLineBufChar()修改.修改判断字符打印结束判断.
	CheckPrintContentFinish()修改.无论判断状态如何都设置并启动定时器.
	SetGoLineSpace()修改.进入后无需判断加热和走电机是否完成,
	根据是否走行间距,直接修改行间距的值并启动电机控制定时器.
	ProcessHeatAndMotor()修改,加热完毕,只处理判断LPB_STATUS_SPI_SEND_OVER的情况.
	ProcessMotor()修改,走当前电机完毕,只处理判断LPB_STATUS_SPI_SEND_OVER的情况.
	修改后测试标准情况打印满行汉字,最高速度150mm/s,打印流畅.
	测试打印图形正常,条码正常,RAM位图正常.测试倒置打印以上均正常.
2.	MAX_RUSH_STEPS_ON_BITMAP_PRT添加.设置为68.
	GetMaxAccelerateStepsOfBitmapPrint()修改.改为MAX_RUSH_STEPS_ON_BITMAP_PRT.
	测试打印速度变化不大.
3.	MAX_RUSH_STEPS_ON_BITMAP_PRT设置为126.
	GetMaxAccelerateSteps()修改.直接判断图形或者字符模式,二者择一.
	测试图形打印可以正常进行,但是连续多个图形打印时会出现白道及拉长的空白.
	MAX_RUSH_STEPS_ON_BITMAP_PRT设置为68.测试不会出现该现象.
4.	CheckPrintContentFinishOfGraphic()可以进行优化.
	图形打印时不走行间距,所以判断图形打印结束后可直接设置ILDE,
	无需再经过LPB_STATUS_SET_GO_LINE_SPACE这个状态了.
	修改后测试1B2A,1B13及驱动打印正常.
5.	MAX_RUSH_STEPS_ON_DRV_PRT由38改为30,
	MAX_RUSH_STEPS_ON_DRV_PRT_ETHERNET由25改为20.
	MAX_RUSH_STEPS_ON_DRV_PRT_LPT由38改为25.使用SP驱动测试.
	修改后测试驱动打印效果改善不大.
	改为68或者126,测试噪声大.
	启用驱动模式下接收数据的延时,68下测试效果同不启用时速度38.
6.	均改为38,启用驱动接收延时.驱动测试效果无改善.
	网口改为20,U口30,测试U口尚可,网口还需要改进.
	网口改为15,测试尚可.
7.	网口改为25,关闭驱动接收延时.测试效果同网口15,开启接收延时.
8.	MAX_RUSH_STEPS_ON_DRV_PRT改为68,
	MAX_RUSH_STEPS_ON_DRV_PRT_ETHERNET由25改为35.开启接收延时.网口接收延时由10改为50.
	测试结果,U口和网口效果差不多.
9.	ReadInBuffer()效果.COM口延时50,其他端口延时20.
	测试结果,U口和网口效果差不多.
10.	去掉延时,E口改为15,U口改为25.测试E口打印效果没有提高.
	开启延时.测试E口打印效果没有提高.
	关闭延时,E口改为20.效果有待改善.
11.	恢复原值.
12.	MAX_RUSH_STEPS_ON_BITMAP_PRT由68改为50.
	当连续打印相连的图片时,中间会有白道.
13.	CheckPrintContentFinishOfGraphic()恢复修改.
	修改后测试打印效果同上.
	CheckPrintContentFinishOfGraphic()恢复.


程序版本:0.232
编写人员: 
编写日期:2013-3-18
1.	PrintLineBuffer()与SystemTimer3Func()检查完毕,没有发现配合不正常的地方.
	目前标准设置下打印满行汉字速度为160mm/s.
2.	PrintLineBuffer()中ILDE,WRITING,SPI_SENDING三种状态的停止定时器去除.
	测试速度不变.
3.	AdjustMotorStep()修改.
	添加一个全局变量标志最大允许的加速步数.因为打印类型决定了一次打印缓冲区内容
	的最大加速步,所以不需要逐点行判断,只需要在一行开始进行.
	g_bMaxRushStep添加.	extern	u8	g_bMaxRushStep;
	InitParameter()添加该变量初始化.
	WaitToPrintLineBuf()添加该变量的计算.决定本次打印缓冲区中所有内容的最高限度速度.
	AdjustMotorStep()修改.不需要再计算最高限速,直接引用g_bMaxRushStep.
	在调用AdjustMotorStep()时之前的加热和走行距工作已经全部完成.
	所以先调整gStepCount防止超过当前打印缓冲区的最高限速,再根据加热时间进一步调整gStepCount.
	ProcessHeatAndMotor()和ProcessMotor()也需要修改.其中不计算最高速度,只管递增.
	EndFeedMotor()修改.添加g_bMaxRushStep的初始化.设置为最大值.
	修改后字符可以打印.浓度深.需要调整.
4.	STD_HEAT_ENERGY减半,改为原来的标准值.
	测试打印经常停止,有的打印为半空白和压缩.
	EndFeedMotor()中去掉g_bMaxRushStep的初始化.打印不再压缩.
5.	WaitToPrintLineBuf()中去除g_bMaxRushStep的计算.
	AdjustMotorStep()中添加g_bMaxRushStep的计算.
	ProcessHeatAndMotor()和ProcessMotor()修改.不根据g_bMaxRushStep判断,只根据极限值判断.
	EndFeedMotor()修改.添加g_bMaxRushStep的初始化.设置为最大值.
	电机驱动模式改为1/4步.
	修改后字符打印测试正常.测试最高速度180mm/s.一次加热条件下.
6.	AdjustMotorStep()中添加g_bMaxRushStep的计算.
	GetMaxAccelerateSteps()修改,根据温度,驱动模式,字符行间距,图形模式判断最大加速度.
	此为一个缓冲区的公共部分.根据加热次数的单独判断.
	AdjustMotorStep()修改.添加根据加热次数判断最大加速值的处理.
	测试打印有时电机走不动.
7.	电机驱动改为半步.
	测试打印有时电机走不动.
8.	改为全步驱动方式.
	测试打印有时电机走不动.
9.	EndFeedMotor()中去掉g_bMaxRushStep的初始化.按键上纸效果不变.


程序版本:0.233
编写人员: 
编写日期:2013-3-19
1.	恢复原行间距处理流程,待加热最后一点行完毕再启动设置走行间距.
	恢复电机和加热处理中判断行间距启动控制处理.
	走电机时最高速度根据全局变量控制速度.
	SetGoLineSpace(),CheckPrintContentFinishOfGraphic()恢复.
	ProcessHeatAndMotor(),ProcessMotor()修改.根据g_bMaxRushStep限制最高速度.
	AdjustMotorStep()修改.去掉一个临时变量.
	使用全步驱动.
	按键上纸还会出现电机走不动.
2.	改用1/8驱动.大部分时候按键上纸正常.连续走纸无问题,短促走纸会出现电机走不动.
3.	FEED_MOTOR_ILDE_NUMBER由3改为1.
	EndFeedMotor()中添加g_bMaxRushStep的初始化.
	还会出现电机走不动现象,但是概率降低.
4.	EndFeedMotor()中去掉g_bMaxRushStep的初始化.该变量由启动打印的进程初始化.
	去掉结束擎住处理处理.
	按键上纸正常.
	测试打印不正常.
5.	STD_HEAT_ENERGY值加倍.
	修改后测试能打印.效果不理想.
6.	ProcessHeatAndMotor(),ProcessMotor()修改.不根据g_bMaxRushStep限制最高速度.
	AdjustMotorStep()修改电机速度调整.确保本点行加热的电机步加速完毕不超过最高限速.
	这样加热时最高速度不会超过限速,而走行间距无最高限速.
	修改后测试能打印.效果不理想.
7.	AdjustMotorStep()修改.恢复原逐点行计算最高限速处理.
	WaitToPrintLineBuf()中去除g_bMaxRushStep的计算.
	GetMaxAccelerateSteps()修改.恢复全判断.
	修改后效果不变.
8.	FEED_MOTOR_ILDE_NUMBER由1改为2,修改后效果有改善.
9.	恢复结束擎住处理.
	效果还是不理想.


程序版本:0.234
编写人员: 
编写日期:2013-3-19
基于0.230修改.0.231~0.233修改目的为提供最高打印速度.
1.	AdjustMotorStep()修改电机步调整计算.
	修改后满行汉字打印速度最高160mm/S.
2.	ProcessHeatAndMotor(),ProcessMotor()修改.
	去掉电机最高速度计算,根据极限最大速度走电机.
	FEED_MOTOR_ILDE_NUMBER由3改为2.
	修改后出现按键上纸电机走不动的现象.
3.	去掉结束擎住处理,修改后按键上纸正常.
	测试打印不正常,打印不流畅,经常停顿.
4.	FEED_MOTOR_ILDE_NUMBER由2改为3.
	测试打印还是会出现这种现象.
5.	添加一个全局变量标志最大允许的加速步数.
	g_bMaxRushStep添加.初始化为最高加速值.
	extern	u8	g_bMaxRushStep;
	AdjustMotorStep()修改.添加该变量赋值.
	ProcessHeatAndMotor(),ProcessMotor()修改.根据该变量值限速.
	FEED_MOTOR_ILDE_NUMBER由3改为2.
	修改后打印效果差,经常停顿.打印越多,速度越慢,效果越差.
6.	AdjustMotorStep()计算算法错误.修改.
	修改后测试感觉正常.打印浓度很深.
7.	STD_HEAT_ENERGY减半,改为原来的标准值.
	测试打印经常停止,有的打印为半空白和压缩.
	ProcessHeatAndMotor()和ProcessMotor()修改.不根据g_bMaxRushStep判断,只根据极限值判断.
	测试打印经常停止.无改观.
	AdjustMotorStep()修改.不计算速度限制,只根据加速表和加热时间调整电机步.
	测试打印速度非常慢.
	ProcessHeatAndMotor()和ProcessMotor()修改.恢复自计算限速.
	测试打印速度非常慢.
11.	STD_HEAT_ENERGY恢复,打印正常.
	测试满行汉字打印速度150.
12.	ProcessHeatAndMotor()和ProcessMotor()修改.只根据极限值判断.
	测试满行汉字打印速度160.
	改为一次加热.测试满行汉字打印速度160.无改变.
13.	加热时间值固定为50,8步驱动测试.最高速度无改变.
	加热时间值固定为35,8步驱动测试.最高速度无改变.而且还出现整行压缩.打印浓度合适.
	加热时间值固定为60,4步驱动测试.最高速度180.打印浓度稍淡.
	加热时间值固定为200,2步驱动测试.最高速度220.打印浓度合适.开始打印时有状态停顿.
	恢复加热时间计算得到,2步驱动测试.最高速度180~200.打印浓度稍淡.开始打印时有状态停顿.
14.	GetHeatTime()修改.去掉电机宽度调整计算.
	STD_HEAT_ENERGY由理论值0.21改为0.315.
	添加结束擎住处理.
	修改后测试打印流畅,速度200.连续批量发送时出现电机走不动现象.
	FEED_MOTOR_ILDE_NUMBER由3改为2.修改后测试效果不变.
	AdjustMotorStep()修改.添加速度限制计算.修改后测试效果不变.
	去掉结束擎住.修改后不会出现电机走不动现象,但是开始打印时有状态停顿.
	STD_HEAT_ENERGY改为0.3,GetHeatTime()恢复电机宽度调整计算.USE_FULL_ASSERT去掉.
	修改后开始打印不再停顿.但是最后一段电机走不动.打印浓度较深.
	恢复结束擎住处理,STD_HEAT_ENERGY改为0.21,修改后打印开始电机走不动.
	改为4步驱动,效果不变,打印开始电机走不动.
	改为1步驱动,打印效果良好.按键上纸有时电机走不动.打印浓度淡.
	去掉结束擎住.按键上纸有时电机走不动.批量打印正常.打印浓度淡.
15.	动态加热,STD_HEAT_ENERGY改为0.3,单步驱动.测试按键上纸电机走不动.
	改为8步驱动.按键上纸正常,打印时电机走不动.
16.	2步驱动,加热时间固定返回150,动态加热,去掉结束擎住.
	测试按键上纸正常,打印正常.开始阶段有时有停顿几次.
17.	FEED_MOTOR_ILDE_NUMBER由2改为3.
	SetGoLineSpace()重优化.
	CheckPrintContentFinish()修改,不管状态如何都启动TIM4.
	修改后按键上纸正常,连续批量打印正常,开始不停顿,中间不会卡住.打印浓度适中.
18.	使用计算时间方式.少量打印无问题.批量打印电机走不动.
	2步驱动,150us加热时间.动态加热.
	使用固定加热时间方式,批量打印非常顺畅.最高速度220mm/s.
19.	启用结束擎住,否则容易电机被粘住走不动.
20.	错误和缺纸控制线颠倒.修改LED宏定义.


程序版本:0.235
编写人员: 
编写日期:2013-3-19
修改加热时间计算方法.使用基于试验效果的简化补偿计算方法.
1.	PaperCoefficent[]不再使用.
	cHeatTimeTable[]添加.
	GetAdjustHeatTimeOfPowerVoltage()添加.根据测量外部电压值
	与标准电压值比较进行加热时间补偿.
	EndFeedMotor()中添加限速的初始化.
	测试打印走不动电机,按键无法上纸.
2.	设定为2步驱动,150us加热时间.动态加热.不启用结束擎住.
	测试连续打印和按键上纸均正常.
	如果启用结束擎住则电机会走不动.
3.	设定为2步驱动,170us加热时间.动态加热.不启用结束擎住.
	打印又出现电机走不动.
4.	关闭FEED_MOTOR_MONITOR_ENABLE和NO_PAPER_RE_PRINT_ENABLE测试.
	测试按键上纸正常.打印开始一段有停顿,批量打印满行汉字测试速度195~205之间.
5.	添加结束擎住.
	测试按键上纸正常.多次发送过程中也会产生停顿.效果不错.
6.	GetHeatTime()效果.启用电压补偿计算处理.
	测试正常.24V下打印浓度正常.


程序版本:0.236
编写人员: 
编写日期:2013-3-20
1.	测试打印.
	电压低于21V时,走电机不正常.说明书要求最低电压21.6V.
	21,22,23,24,25,26V下全部分别测试打印,均正常.打印浓度适中.
	测试行间距32时批量打印速度至少200mm/s,打印中间发送数据时停顿过几次.打印浓度适中.
	还需要添加温度调整.
	行间距为0时打印浓度浅.行间距1点及以上打印浓度正常.
2.	以上的测试AdjustMotorStep()中都有速度限制的处理.去掉最高速度限制测试.
	行间距0时打印不连续,但是无压缩.
	行间距1时打印压缩.
	行间距2及以上时,打印连续,速度快,无压缩.
3.	AdjustMotorStep()恢复限速.
	GetMaxAccelerateStepsOfLineSpace()修改.根据行间距限速时,只限制2点以下的.
	行间距0点:10,30~50均正常打印,但是均突突跳,尤其是超过30以上更明显.
						10及以下电机噪声有不明显,但是打印浓度浅.
	行间距1点:40~90均正常.


程序版本:0.237
编写人员: 
编写日期:2013-3-20
1.	将selftest.c中的全部变量都定义为const型.
	PrintString()修改.将其中的输入参数改为const型,并修改函数体中对应指针.
	编译通过后RW_RAM占用空间减少了28字节.
2.	修改控制方式.修改最后的行间距设置.简化SetGoLineSpace()处理.
	SetGoLineSpace()修改.进入后无需等待原行间距值走完,直接设置即可.
		需要走行间距直接添加上,不需要走行间距不做修改.不设置电机定时器,只启动定时器.
	ProcessHeatAndMotor(),ProcessMotor()修改.不处理设置行间距的情况.
	GetMaxAccelerateStepsOfLineSpace()修改.行间距0设置限速100,1及以上不限速.
	测试行间距0打印正常,1压缩.
	改为行间距0为100,1为110.其他为126.修改后测试均正常.纵向横向放大从1到8均正常.
	改为行间距0为110,1为120.修改后测试都压缩.恢复修改.
	测试字符汉字打印通过.
	测试图像打印通过.
	测试条码打印通过.
3.	GetMaxAccelerateStepsOfBitmapPrint()修改.单独限速,不与驱动模式相同.
	MAX_RUSH_STEPS_ON_DRV_BITMAP添加,按照行间距0点效果处理.限速100.
	测试条码和图形打印正常,但是打印浓度低.主要是起始部分浓度低.
	需要添加初始加速部分的温度补偿.补偿后应该不再有这种缺陷.
4.	驱动限速修改.暂按照图形限速测试.测试E口.
	限速100.WH驱动测试压缩.SP驱动测试基本不压缩.
	限速80.WH压缩更严重,SP效果无改善.
	DRIVE_PRT_MODE_RX_DELAY_ENABLE启用.SP驱动打印过程中经常停止.需进一步优化.
5.	Command_16()修改,将读取多余数据放到最后处理.
	PrintOneDotLine()修改.原处理有错误.需要将加热控制管脚赋值部分放到检测
		之前行加热走电机完成之后.
	SP驱动实现模式决定了走空白部分可以很快,但是在此期间最多只能准备好下一点行的内容,
	所以如果逐点行处理的模式无法实现高速连续打印.除非将逐点行内容集中放到某个缓冲区,
	等待积攒到一定数据才集中打印.如此才能达到高速的情况.
6.	限速60测试.效果有改善,但是不理想.
	去掉驱动接收等待,限速50测试.WH驱动压缩较少,SP效果略有改善.
	Command_1B13()修改,1B13指令执行时作为驱动模式.
	限速40,WH测试打印很快.但是打印过程中出现压缩.
	Command_1B13()修改,1B13指令执行时进入驱动模式,不退出.则打印正常.
7.	MAX_RUSH_STEPS_ON_DRV_BITMAP改为MAX_RUSH_STEPS_ON_PRT_BITMAP,修改引用处.
	MAX_RUSH_STEPS_ON_WH_DRV_PRT添加,为1B13指令使用.
	g_tPrtCtrlData.PCDriverMode变量的含义进行修改,=0为正常打印模式.
	=1为SP驱动打印模式,=2为WH驱动打印模式,
	Command_1B24()修改.修改判断条件,区分驱动为SP驱动.
	Command_1D76()或许也需要修改.
	EndFeedMotor()修改,添加处理WH驱动的情况.如果有WH驱动,则取消.
	GetMaxAccelerateStepsOfDrivePrint()修改,区分WH驱动和SP驱动.
	将WH和SP两种驱动的速度宏定义名称改变,区分处理.
	测试WH限速100,80,60,40会压缩.E口压缩比U口重.
	允许驱动接收延时,WH限速40.还是有压缩.改用串口测试,无压缩.应该是驱动程序不处理握手导致.
8.	WH驱动串口35,其他100,测试串口稍有压缩.
	串口改为20,其他30,测试串口和E口均正常,U口有点压缩.
	ReadInBuffer()修改.串口延时50,其他一律20.测试S不压缩,E,U压缩.
	其他一律10,测试E,U,S三种都不压缩.
9.	SP驱动串口限速15,其他一律30.驱动延时与WH驱动时设置相同.
	测试也不压缩.


程序版本:0.238
编写人员: 
编写日期:2013-3-20
本版本主要修改一维条码打印.将其由位图打印模式改为发送一次后,循环打印.
1.	BARCODE_PRT_AS_BITMAP_ENABLE禁用.改用一次发送条码数据,循环加热实现方式.
	测试当先打印条码图形后打印HRI时,工作正常.先打印HRI后打印条码图形时,图形为空白.
2.	PrintBar()修改.
	g_tPrtCtrlData.PrtDataDotIndex在打印完HRI后会被设置为.LeftLimit,需要保护.
3.	编写修改新模式条码打印处理,测试成功.
	左间距默认0,正向打印右对齐时HRI最右端出现额外的一点乱码.
	其他正反向时左、中、右打印均正常.
	使用原图形打印模式的程序测试也出现这一现象.
4.	.CodeAimMode相关的赋值与判断全部改用宏定义实现.
	CodebarBufToHeatElementNormalDir()修改.去掉递增1个字节的判断.修改后结果不变.
5.	LineBufToHeatElementNormalDir()修改.递增1个字节有时会溢出.再加上最大值判断.
	修改后测试打印正常.
	条码打印的速度可以达到最高速度.
6.	以上测试都是按照左间距为0测试的,还需要继续测试左间距不为0的情况.
	设置左边距为90,测试不打印条码.打印的HRI内容有多出的.需要继续修改.
	使用图形方式打印,表现相同.
	测试之前0.208版本表现相同.
	使用的设置左边距指令错误.


程序版本:0.239
编写人员: 
编写日期:2013-3-21
GetCodeBarStr()			接收原始数据
FormatCodeUpc_A()
	->EanCheckCode()	计算并添加校验码
	->EnaFillToBuf()	转换为条码图形并存放于g_tUnderlineBuf中
1.	当设置的左边距不为零时,HRI字符的右间距计算错误.计算的右间距比合理值偏大.
	PrintBarHRI()修改.计算字符右间距时去掉PrtCtrlData.PrtLeftLimit.
	修改后测试正向打印设置左边距不为零时,左对齐打印正常,
	居中时HRI偏右,居右时偏右,超过应该的右边界.
	测试非条码字符打印左边距及对齐方式及颠倒打印配合正确.
	目前条码填充后返回值条码宽度为从0开始到条码所在位置结束的所有内容,
	而PrtCtrlData.PrtDataDotIndex值不变,具体条码图形为从.PrtDataDotIndex开始.
	从而导致条码对齐打印出错.
2.	
	FormatCodeUpc_A()->EnaFillToBuf()
	FormatCodeUpc_E()->
	FormatCodeEan13()->EnaFillToBuf()
	FormatCodeEan8()->EnaFillToBuf()
	FormatCode39()->
	FormatItf25()->
	FormatCodabar()->
	FormatCode93()->
	FormatCode128()->
	返回值计算方法都相同.
	修改以上所有涉及到的函数的返回值计算方法,修改为返回值为条码数据的宽度点数值.
	Command_1D6B()修改.打印之前添加判断打印区域是否超过,只有不超过才打印.
	调整实际打印图形宽度变量值为包含实际图形的宽度值.
	PrintBarBitmap()修改.去掉参数判断.因为已经调整到Command_1D6B()了.
	PrintBar()修改.去掉打印HRI之前保护并调整PrtCtrlData.PrtDataDotIndex的处理.
	因为打印HRI之前字符还没有被编辑并存放到打印缓冲区,所以.PrtDataDotIndex的值
	不能人为改变.
	修改后测试打印正常.
3.	Line_dir相关地方全部改为宏定义.
	字符宽度,高度赋值相关的地方全部改为宏定义.
	print.h, charmaskbuf.h 头文件中某些宏定义放到defconstant.h中.
	修改某些宏定义名称,将其修改为可理解性更好的方式.
	去掉某些用不到的宏定义.将不同名称同样内容的宏定义替换整合.
	将加热时间改为宏定义.
	编译通过.
4.	下一版本完善加热时间计算.


程序版本:0.240
编写人员: 
编写日期:2013-3-21
完善加热时间计算.
1.	添加起始行部分额外温度补偿处理.
	删除原计算方法的程序.删除无用的程序.
	g_bFeedMotorStartStep添加.
	StartFeedMotor()中添加该变量初始化.StepFeedMotor()中递增.
	GetAdjustHeatTimeOfFirstLineHeat()添加.根据加速步数进行调整.
	测试打印效果消除了打印起始浓度淡的问题.
2.	设置左边距为37,测试满行打印汉字最后一个汉字有一部分没有完全打印出来.
	LineBufToHeatElementNormalDir(),UnderLineBufToHeatElementNormalDir(),
	CodebarBufToHeatElementNormalDir()修改.修改判断是否有转换未完成的内容部分.原判断不准确.
	LineBufToHeatElementReverseDir(),UnderLineBufToHeatElementReverseDir(),
	CodebarBufToHeatElementReverseDir()修改.除改左移.
	修改后字符打印反向正常,正向打印还存在少内容的错误.
3.	LineBufToHeatElementNormalDir(),UnderLineBufToHeatElementNormalDir(),
	CodebarBufToHeatElementNormalDir()修改.最后的内容改为全复制.去掉i的递增和判断.
4.	启用缺纸重打.
	基本测试未发现问题.


程序版本:0.241
编写人员: 
编写日期:2013-3-22
目前程序在使用反显打印时,如果打印内容过多会造成电源供电不足导致重启或者烧掉保险.
1.	将反显打印时间减少一半.
	TypeDef_StructPrtMode添加打印控制变量CharNotFlag.
	SetLinePrtModeVariable()中添加该变量赋值.
	StartHeatAndRotateMotor()修改.字符反显打印时加热时间减半处理.
	测试打印纵向横向放大8倍,行间距0,ASCII字符满行连续打印.
	使用8A保险管没有出现异常.打印过程中出现过温保护,可自动解除过温.
	使用4A保险管没有出现异常.打印过程中出现过温保护,可自动解除过温.
2.	GetAdjustHeatTimeOfTemperature()添加.
	GetHeatTime()添加根据温度补偿处理.
	MIN_HEAT_TIME添加.
3.	将反显时加热时间改为标准时间的75%.
	测试打印正常.
4.	cStartHeatTimeCompensateTable[]起始温度补偿时间减少.
	测试正常.
	目前测试打印速度220mm/s.
5.	修改自检测打印内容,尽量对齐.
1D 42 01 1D 21 77 1B 31 18 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 50 51 52 53 54 55 56 57 58 59 60 0A
编写日期:2013-5-2
1.	网口行间距32实际测试最高速度200.
2.	串口行间距29实际测试最高速度205.打印连续.


程序版本:0.242
编写人员: 
编写日期:2013-3-25
1.	Command_1D2F()修改.修改填充数据指针首地址计算方式,添加左边距.
	否则在设置左边距不为零的情况下,打印点阵图形数据会缺失一部分.
2.	Command_1D51(),Command_1C70(),Command_1B13(),Command_1B2A(),
	也可能有同样的问题.待修改.
3.	GetMaxAccelerateStepsOfLineSpace()修改.
	改为行间距超过2点空白为最高速度,0点降低为90,1点降低为100,2点降低为110.
4.	Command_1B2A()修改.
	满一行后打印.超过一行的内容一律丢弃.
	测试正常.包括设置行间距及打印内容超过一行的情况.
	Command_1D51(),Command_1C70(),Command_1B13()检查.无需修改.
5.	加粗加重打印时降低打印速度.
	EMPHASIZE_PRT_FEED_SPEED_DEC_ENABLE添加.
	TypeDef_StructPrtMode添加新成员.
	SetLinePrtModeVariable()添加赋值.
	GetMaxAccelerateStepsOfEmphasizePrint()添加.
	GetMaxAccelerateSteps()添加对齐调用.
	目前加粗打印速度不受限制,连续打印多内容时会造成压缩或者电机失步.
	目前将速度降低为68,降低后测试正常,故障消除.


程序版本:0.243
编写人员: 
编写日期:2013-3-25
1.	GetMaxAccelerateSteps()修改.
	按照驱动模式/非驱动模式
								图形模式/非图形模式
												行间距
	的逻辑检测限速.
	将图形打印和加粗打印速度调整直接处理,不再通过函数调用.
	本U,E,S打印正常,0.244版本开始打印停顿,S有压缩.


程序版本:0.250
编写人员: 
编写日期:2013-4-3
使用AccessPort.exe调试串口.
1.	GetModeType()修改,SystemDelaymS()延时900ms的原参数错误.
	UART_MAX_SPEED_ENABLE宏定义正常程序应该关闭.
2.	GetModeType()修改.去掉关于以太网的检测.
	InitStdPeriph()修改.去掉InitResetEthernetButtonPort(),
	InitPrtCtrlResetEthernetPort()的初始化处理.
	之前的以太网口板机型以太网按键连接到某个端口,并有默认的上下拉.
	目前的三种正式电路中已经全部去掉.
	修改以太网口需要的管脚调整的程序.
	修改后测试行间距0,满行汉字打印,三种接口打印均顺畅正常.
3.	Command_1D56()修改.将自动上纸改为GoDotLine()实现.
	修改自动上纸的宏定义,放到debug.h中.
	修改自动上纸量的宏定义,与feedpaper.h中宏定义保持一致.
4.	并口调试修改.
	InitParallelDataPort()修改.数据管脚改为浮动输入.
	Read_LPT()修改.ReadParallelData()宏定义修改.
5.	ClearComInBufBusy()修改.并口清忙改用LPT_ACK_Out()实现.
	LPT_ACK_Out()修改.开始先置ACK高.
6.	InitParallelCtrlPort()修改.每个管脚单独初始化.添加READ_DATA的初始化.
	以上为0.244版本修改的地方.
	修改完毕,U口,网口打印正常,S口打印正常,连续发送时会出现乱码.
	可能是因为测试软件和缓冲区自身发生了溢出(最大8K).
	0.245版本跳过.
7.	将异常时的紧急保护全部放到一个公共函数EmergencyProtect()里面.
	并将相应中断的程序用该公共函数替换.
8.	SetParallelBusy()和ClearParallelBusy()相互调换.调整硬件改用NPN三极管实现.
9.	InitStdPeriph(),SetComInBufBusy(),ClearComInBufBusy()修改.
	改写原ETH相关的设置.原设置程序有错误.
	修改后忙信号控制正确.
10.	测试WH和SP两种驱动并口打印正常.
	以上为0.246版本的修改.
	修改后E,U,S三种端口打印测试通过.


程序版本:0.251
编写人员: 
编写日期:2013-4-3
使用AccessPort.exe调试串口.
1.	修改串口置忙清忙相关的处理.根据是硬件还是软件握手决定.
	SetUsartBusy(),ClearUsartBusy()添加两个新函数实现.原为硬件握手.
	添加串口参数相关的宏定义.目前按照注释中设计.待测试.
	原硬件握手方式的宏定义添加Hard.
	目前串口各种设置的各个参数的定义正好与规则定义相反.
	修改后使用115200,8,NONE,RTS协议打印正常.
	设置为X,7,ODD,RTS协议打印乱码.
2.	添加两个静态变量标志串口参数.
	SetCommand_1B09()修改.进入各个命令之前先给两个串口变量赋值.
	SetCommand_1B23()修改.赋值到两个静态变量,最终写入时再替换实际的参数,
	这样来确保通过串口来设置串口参数的过程中原来的通信规则不被随时变动.
	SetCommand_1B15()修改.将串口参数值单独先判断再重新赋值.
	修改后串口设置参数正常,测试115200,8,ODD,RTS协议打印正常;
	修改后串口设置参数正常,测试115200,8,EVEN,RTS协议打印正常;
	修改后串口设置参数正常,测试115200,7,ODD,RTS协议打印乱码;
	改用STC-ISP.exe调试串口.同样打印乱码.
	恢复为默认串口参数调试.


程序版本:0.252
编写人员: 
编写日期:2013-4-3
调试打印效果.行间距小于5,宽度为1,高度为2时,各种接口打印均压缩.
1.	去掉起步加热调整处理.将加热时间宏定义挪到heat.h中.
	注释掉不必要的变量节约内存.
2.	测试,串口下行间距0,:
	宽度1,高度1时,打印正常;
	宽度1,高度2时,压缩严重;
	宽度1,高度3时,偶有压缩;
	宽度1,高度4时,无压缩.
	GetMaxAccelerateStepsOfDifferentMagnification()新函数添加,
	处理不同宽度高度比时的情况.
	GetMaxAccelerateStepsOfLineSpace()修改,添加引用以上新函数的处理.
3.	测试不同纵向横向放大倍数组合,打印满行汉字,
	行间距0,1,2,只有横向放大倍数=1,纵向放大倍数=2,3才出现压缩.
	行间距3,4,5,6,7,8,9只有横向放大倍数=1,纵向放大倍数=2,3才出现压缩.
	行间距更高时没有测试.
	所以只需要判断横向=1,纵向=2或者3的情况.
4.	TypeDef_StructPrtMode, TypeDef_StructPrtCtrl 修改,
	添加新成员最大横向放大系数MaxRatioX.
	g_tPrtCtrlData.MaxRatioX = 1;				//行内最大横向放大倍数
	InitPrtCtrlDataParameter(), InitVariableToStartNewLine(),
	PrepareNewLine() 修改,添加相应变量初始化.
	SetLinePrtModeVariable()修改.添加相应变量赋值.
	FillPrintBuff()修改.添加相应变量赋值.
	修改后测试以上组合均正常.
5.	恢复起始步加热调整处理.
	修改后测试以上组合均正常.
6.	GetInterfaceType()修改.原处理错误.应该先移位再读取.
	否则只有网口机型不会判断接口出错,其他机型都会出错.


程序版本:0.253
编写人员: 
编写日期:2013-4-7
处理并口机型的纸信号相关的指令实现及修改.
1.	g_tError.PaperEndSensor,g_tError.PaperEndStop.
	添加并口缺纸和不缺纸信号输出宏定义.
	添加并口缺纸信号处理的调试宏定义.
	SystemTimer2Func()修改.添加并口缺纸信号处理.
	目前缺纸停止打印错误中包含了纸将尽.
	ErrorDetect()修改.改为将纸信号的判断单独区分纸尽和纸将尽,
	并根据是否允许纸将尽判断纸将尽信号来决定错误信号返回.
	修改后测试并口PE信号输出与指令规定符合.
	Command_1B63()修改,0x34情况下PE总是有效.
	1B6333指令修改和测试完毕.
2.	SetEmergencyProtect()修改.不关闭切刀.
	ReleaseEmergencyProtect()修改.先等待1s.
	测试先进入纸将尽,再发送打印内容,只有撤除纸将尽后才开始打印.
	测试通过.
3.	并口测试工具打印批量数据发送时打印中间有停顿,出现拉伸.
	后面不再停顿.
	串口115200测试中间不停顿.速度220.
4.	PrintModeSet()中变量ModeSetString[]改为常量型.
5.	测试WH驱动打印各个端口的最高速度.
	并口测试:
	限速30,测试正常.
	限速50,打印压缩.
	限速40,基本都能正常打印出来,有打印效果不理想的地方.
	限速35,打印压缩.
	最终选择限速30.
	自检打印能顺利通过,通过WORD打印压缩,停顿.还需要调整.
	U口测试:
	限速30,自检通过.
	网口测试:
	限速30,自检基本能通过,基本都能正常打印出来,有打印效果不理想的地方.
6.	限速改为20.
	U口,网口自检通过,WORD打印通过.
	限速改为25.
	网口WORD打印出现压缩.
	保持限速20.
	U口,网口WORD打印通过.串口115200时出现压缩,无乱码.
7.	串口限速由20改为15.出现打印乱码.
	串口限速改为25.基本无乱码.
	由25改为30,出现拉伸,行间距压缩等现象.
	串口限速改为20.自检打印乱码.
8.	S=20,E=20,P=25,U=30,
	E,U,P自检和WORD打印都通过.
	S效果稍差.
	P=30,WORD打印压缩.改为25.
9.	g_tError.PaperEndStop初始化时默认值改为02.
10.	EXTI15_10_IRQHandler()修改.纸仓盖打开时,按键无效.
11.	DOWNLOAD_BITMAP_MAX_DATA_BYTES修改.原宏定义错误,原值为数据量值.
	DOWNLOAD_BITMAP_MAX_DATA_LENGTH修改.原宏定义错误,直接改为最大图形数据值.
12.	Command_1D56(), Command_1B69(), Command_1B6D()修改.
	切刀指令只有在行首才有效.添加该处理.
13.	Command_1C71()修改.添加擦除前设置擦除起始地址赋值.改为块擦除.
	添加按键禁止处理.
14.	去掉g_tResetEthButton及相关程序.无需该变量.
	gbyFeedTaskFlag改为g_bFeedTaskFlag,
	gcRAMBitMapNumber改为g_bRAMBitMapNumber,
15.	还需要添加操作NV FLASH时的相关处理:
	即使按下上纸键，打印机也不上纸。
	打印机不处理实时指令。
	即使ASB被允许，打印机也将停止回传ASB状态值。


程序版本:0.254
编写人员: 
编写日期:2013-4-8
1.	giCodebarPositionSpace,去掉.
	SleepModeFlag 改为 g_bSleepModeFlag,
	RoutinFlag 改为 g_bRoutinFlag,
	gMotorRunFlag 改为 g_bMotorRunFlag
	WriteFlashFlag 改为 g_bWriteFlashFlag,
2.	gbyFeedMotorStepCount 改为 g_bFeedMotorStepCount, 放到feedpaper.c.
	g_cMaintainRountinWriteFlag 改为 g_bMaintainRountinWriteFlag
	giRxFinishFlag 改为 g_bRxFinishFlag
	giLineEditBufStatus 改为 g_bLineEditBufStatus
	CharacterSet 改为 m_tbCharacterSetTable
	giDealOneLineTimeCount 改为 g_iDealOneLineTimeCount
	gbyHeatElementBuf 改为 g_tbHeatElementBuf
	PaperendADValue	改为 g_tPaperendADValueTable
	TemperatureValueTable	改为 g_tTemperatureValueTable
	BlackmarkADValue 改为 g_tBlackmarkADValueTable
	PneADValue 改为 g_tPneADValueTable
	mbyDriveCycleStepNumber	改为 m_bDriveCycleStepNumber
	FeedMotorRushTable 改为 g_tFeedMotorRushTable
	HeatCtrlPin	改为 m_tHeatCtrlPinTable
	mcStoreIndex 改为 m_bStoreIndex
	g_cPrtSPIDMATxStatusFlag 改为 g_bPrtSPIDMATxStatusFlag
	g_cPrtSPIDMAIntForDriveMode 改为 g_bPrtSPIDMAIntForDriveMode
	BpsValue 改为 m_tBpsValueTable
	VersionString内容修改.
	修改告警电压范围为正负10%.
编写日期:2013-4-9
3.	ErrorLedFlash()添加.
	MemManage_Handler(), BusFault_Handler()添加指示灯闪烁.
4.	串口参数设置检查.数据位7时必须设置奇偶校验,否则硬件上工作错误.
	USART1_IRQHandler()修改.将公共接收部分放到前面,修改判断奇偶校验的方式.
	原方式不全面.


程序版本:0.255
编写人员: 
编写日期:2013-4-10
1.	去掉二维条码相关的程序.
2.	ProcessModeType()修改.
	将正常模式时上电时的上纸由FeedPaper()实现改为由GoDotLine()实现.
	只单向上纸,不反向上纸.否则上电后维持一段时间的电流但是电机不走动.
	1B4B指令有待检测实际效果.
3.	将所有设置命令按照从小到大顺序重新排列.不改变其内容.
4.	1B4B指令作为1B13执行.
	本版本与IAP 0.10版本配合可以正常升级.
5.	MISRA规则有待逐条修改.


程序版本:0.257
编写人员: 
编写日期:2013-4-22
以0.255修改.
1.	R_Counter 改为 g_tResetable_Counter
	R_CounterBK 改为 g_tResetable_CounterBK
	C_Counter 改为 g_tCumulate_Counter
2.	u8	改为 uint8_t
		u16	改为 uint16_t
		u32	改为 uint32_t
		vu8	改为 volatile uint8_t
		u16	改为 volatile uint16_t
		u32	改为 volatile uint32_t
3.	FillPrintBuff(), FillPrintBuff()中的局部变量 Line 数据类型由s8改为u8.
	s16 改为 int16_t,
4.	g_tbHeatElementBuf 数据类型去掉 volatile.
	TypeDef_StructCharMaskReadBuf, TypeDef_StructLinePrtBuf, TypeDef_StructHeatCtrl,
	TypeDef_StructBarcodeCtrl, TypeDef_StructInBuffer, g_tInBuf,
	定义中去掉各个变量的 volatile.
	StartPrintLineBufChar()等函数中指针p类型改为普通型, 原为volatile型.
5.	目前的警告主要只剩下string.h相关的.
6.	COMPANY_FLAG 宏定义放到 公共头文件中.名称改为 COMPANY_NAME_STRING.
	并修改对应比较及默认变量赋值替换.
	器件型号定义改为宏定义 MODAL_NAME_STRING. 修改默认变量赋值.
	修改自检时软件版本号的赋值. 使用字符串自动连接的方式实现.
	测试通过.
7.	DriveCutPaper()相关程序调用的切纸方式参数全部改为宏定义模式.
	包括自检时切纸用默认切纸.
8.	ADC转换结果处理.将错误状态更新处理放到新函数中.
	UpdateErrorStatusByADCResult()添加.
	DMA1_Channel1_ADFunc()重新编写.使用指针和数组实现. 去掉了其中DBG_ADC相关的程序.
	测试通过.


程序版本:0.258
编写人员: 
编写日期:2013-4-23
以0.257修改.
1.	将所有数据类型不是int32_t的变量的 << 相关的操作的地方一律改为显式数据类型转换.
	将所有数据类型不是int32_t的变量的 ~ 相关的操作的地方一律改为显式数据类型转换.
2.	Command_1C70(), Command_1D2F(), Command_1D51(), 修改.
	将其中 TEMP_BUF_LEN 相关的地方用 MAX_RATIO_Y 替代.
	去掉其宏定义和解除宏定义的处理.
3.	PrintSoftwareVersion()修改. 不再使用 # 操作符实现字符串连接.
	VersionString 定义修改.
	测试通过.
编写日期:2013-4-24
4.	PRINTER_In(), PRINTER_Out() 函数声明添加返回值类型.
	UpLoadData()输入指针参数改为易变性.修改USB回传的实现方式.
	absacc.h 头文件包含去掉.
	TypeDef_StructInBuffer 中Buf[]去掉volatile型.
	g_tTemperatureValueTable[], g_tPneADValueTable[], g_tPaperendADValueTable[],
	g_tBlackmarkADValueTable[] 定义中宏定义前都添加强制数据类型转换.
	SystemTimer2Func(), Command_1B70()修改. 修改钱箱处理, 时间访问改为使用两个临时变量.
	SystemTimer2Func()修改.判断钱箱延时是否已到条件修改.改为>=.
	GetAdjustHeatTimeOfPowerVoltage()修改.修改易变性变量的访问方式.改为使用临时变量.返回值强制转换.
	MAX_RIGHT_SPACE_HORIZONTAL,MAX_RIGHT_SPACE_VERTICAL 修改.修改宏定义数据类型.改为最大255的模式.
	Command_1B20()修改.计算时强制转换为uint8_t型.不再比较.
	Command_1D6B()修改.strcpy()实现强制转换.
	Command_1D2845()之前包含的各个暂时未实行的空函数都添加间隔空行.
5.	TypeDef_StructDrawer修改. OFF_Time去掉volatile型.
	SystemTimer2Func(), Command_1B70()修改.恢复原处理.判断条件修改.
	目前除了barcode.c, assert()外无告警提示.
编写日期:2013-4-25
6.	assert()修改,实现强制类型转换.告警消除.
	SystemTimer2Func()修改.判断钱箱延时是否已到条件修改.恢复为==
7.	测试并口驱动打印内容较多时出现打印过程中死机.
	调试发现程序接收缓冲区已满, 打印缓冲区正在打印过程中, 状态为SPI_SEND_OVER, 
	但是程序流程在等待WaitPreviousPrintFinish()执行完毕.此时TIM3已经停止处理加热和走电机,
	导致该处程序成为死循环.
	SystemTimer2Func()修改.将其中状态非ILDE时启动PRT_CHECK_TIM使能.
	调试发现不再死机,所有内容全部打印出来,但是打印效果较差.


程序版本:0.259
编写人员: 
编写日期:2013-4-25
以0.258修改.
1.	去掉驱动模式下接收数据时延时处理.
	测试打印效果无改善.
	恢复修改.添加并口接收时最大可能延时30处理,原为最大延时10.
	测试打印效果无改善.
	MAX_RUSH_STEPS_ON_WH_DRV_PRT_LPT 由25 改为 20.
	测试打印效果有改善,拉伸和压缩基本消失.但是中间有突突跳的时候.
	去掉驱动模式下接收数据时延时处理.
	测试打印效果有改善,打印更平稳.
2.	SystemTimer2Func()修改.去掉状态非ILDE时启动PRT_CHECK_TIM使能.
	测试打印正常. 但是打印平稳度还是不去掉更好. 考虑可靠性, 保存使能.
3.	Command_1B13()修改. 实际处理的接收数据量根据放大倍数调整.
	为了适应WIN7 下的新驱动程序,修改为不管内容是否满行一律自动换行模式.
	该驱动不发送0D. 而之前的驱动自动添加0D.
	在这种情况下,打印速度进一步降低.
	Command_1B4B()修改. 改为按照正常的不自动换行的处理模式.
	修改WH驱动最大加速值,所有接口加速值一律减半处理.
4.	恢复驱动模式下接收数据时延时处理.
	最大延时串口时延时300, 其他端口延时3.
	测试两种驱动, 串口115200, 并口 均可正常打印.
编写日期:2013-4-28
5.	PutCharToInBuffer(), ReadInBuffer()需要修改.原处理方式有错误.


程序版本:0.260
编写人员: 
编写日期:2013-5-2
1.	PutCharToInBuffer()修改.原处理方式有错误.
	FillRealTimeCommand()添加.填充实时指令.
	ReadInBuffer()修改.原处理方式无错误,只是有重复操作的地方,降低效率.
	测试:接收和读取的总字节数一致,但是少于发送工具发送的总字节数.
	结果打印乱码.中间肯定有丢失数据.
2.	g_tInBuf 恢复为 volatile.
	串口测试依然出现丢数.
	使用网口测试发送15147字节接收和读取均无丢数,打印无乱码,错码.
	发送39933字节接收和读取均无丢数,打印中间有停顿.
3.	SystemTimer2Func()去掉状态非ILDE时启动PRT_CHECK_TIM使能.
	使用网口测试发送57834字节接收和读取均无丢数,打印中间有停顿.
4.	网口行间距32点达不到最高速度.
5.	关闭ADC更新错误状态标志位,网口行间距32点达不到最高速度.
6.	恢复ADC更新错误状态标志位,改为固定最大1次加热,行间距28,
	串口115200,实测最大速度211mm/s.几乎无停顿.基本符合预期.
	网口自动发送间隔10ms实测最大速度204mm/s.中间出现停顿.
	增大自动发送间隔到30ms实测最大速度176mm/s.中间出现停顿.
7.	串口使用access.exe程序测试硬件握手没有出现丢数.工具发送与POS接收数据相等.
	打印正常,无停顿.
8.	U口使用打印测试工具发送6855字节无丢数,打印顺畅,正常.
9.	WaitHeatAndFeedPaperFinish()修改,改为调用 WaitPreviousPrintFinish() 和 
	WaitHeatAndFeedFinish().
	WaitPreviousPrintFinish()修改.添加计时,超过某个时间后还未跳出,则启动打印检查定时器.
	根据 g_tSystemCtrl.SleepCounter 的值进行超时判断.
10.	使用三种接口测试命令和驱动打印均通过.


程序版本:0.277
编写人员: 
编写日期:2013-8-26
从0.261至0.276之间的版本,WH串口驱动打印时出现硬错误hardfault.原因不明.
从0.261至0.276之间的版本所做的改动在各个过程版本的文件中.
0.260版本WH串口驱动打印工作正常.本版本从0.260开始修改.
1.	修改0.261版本的串口中断接收,按照0.260处理,串口打印依然乱码.
2.	修改bootload,配合测试.
	启动文件修改.堆栈容量由0x1000 改为 0x500.使能 Tamper_Detection 的处理.
	ConfigOptionFlash()全部启用.
	配合BOOTLOAD 0.11版本升级测试成功. 分别通过串口和U口升级成功. 需要先加密bin.
	目前BOOT 和 APP 程序不处理FLASH保护及SWJ锁定.
	未测试.
3.	USART1_IRQHandler()修改.
	先读取奇偶校验位值,再读取数据寄存器值.这样如果出现奇偶校验错误,可以对其进行清零.
	正常功能处理数据时,先处理判断奇偶校验,然后再处理数据位数.修改后测试:
	设置为7位数据,无校验情况下:
		实际发送端工具软件使用7位数据,无校验,无法正常接收.
		实际发送端工具软件使用8位数据,无校验,可以正常接收.
	设置为7位数据,有校验情况下:
		实际发送端工具软件使用7位数据,相应校验,可以接收,但是接收的数据只接收到一个字节的7位,
		不包括最高位MSB.这样只能接收0x80以下的ASCII,无法接收汉字编码.
		实际发送端工具软件使用8位数据,相应校验,接收到数据可以收全8位,但是无法奇偶校验将出现错误,
		还是会处理为?或者丢弃.
	设置为8位数据,无校验:
		实际发送端工具设置与之相同,可以正常接收汉字编码.
		实际发送端工具设置为8位数据,奇校验/偶校验,依然可以正常接收汉字编码.
	设置为8位数据,有校验:
		实际发送端工具设置与之相同,可以正常接收汉字编码.
		实际发送端工具设置为8位数据,错误的校验,接收到校验错误,将不处理该字符.
	所以:
	设置为7位数据+无校验情况下,显示应该为8位数据+无校验.
	修改后S口WH驱动打印正常.
4.	PrintUsartParameter()修改.
	PrintUsartParameterReal()添加.前者负责判断,后者负责实际打印.
	当设置为7位数据位+无校验时,实际显示8位数据位.
	测试自检打印串口显示内容与预期相符.
5.	g_TypeDef_StructSysCconfig, g_ctSysDefaultValue 修改.
	将字符串相关的内容全部放到最后,其他内容放到前面.
	修改后无法发现USB设备.恢复后正常.
6.	修改串口设置.各种机型的串口均使能,但是只有S+U的才打印自检可见,其余均不可见.
	DBG_UART_VISIBLE_ENABLE 宏定义添加.
	修改自检打印信息.测试时串口信息可以直接打印,正式产品时只有并口或网口为0,
	串口为1时才打印串口信息.
	PrintModel(), PrintInterfaceType() 修改.
	网口,并口机型自检测试通过.
	修改后S口WH驱动打印正常.
7.	InitCommonGPIO()修改.添加带BOOT模式时禁用JTAG/SWJ.
	可以配合BOOT版本0.12配合升级,升级后可以正常工作,JTAG被禁用,但是SWJ还可以使用.
	修改BOOT端禁用SWJ后就不能使用SWJ了.
	暂时不禁用升级模式时的SWJ.
	修改后S口WH驱动打印正常.
8.	0.261版本所做修改的地方已经全部照样修改过.S口WH驱动打印测试通过.
	堆栈容量由0x1000 或者 0x500 S口WH驱动打印均可以正常打印.


程序版本:0.278
编写人员: 
编写日期:2013-8-26
继续测试0.262版本修改过的地方.
1.	PrintOneLine()修改.图形模式时不走行间距,但是需要重新清零各个控制变量.
	添加调用PrepareNewLine().
	修改后S口WH驱动打印正常.
继续测试0.263版本修改过的地方.
2.	添加1B6B指令.配合驱动打印实现切纸.具体实现同1D56指令.
	AUTO_FEED_AFTER_CUT_STEPS 定义挪到 feedpaper.h.
	测试通过.
	修改后S口WH驱动打印正常.
3.	MAX_RUSH_STEPS_ON_WH_DRV_PRT_USB 由 15 改为 10.
	测试U口驱动打印效果差别不大.
	MAX_RUSH_STEPS_ON_WH_DRV_PRT_USB 改为 15.
	ReadInBuffer()修改. 驱动时串口最大延时300, 其他最大延时3.
	测试U口驱动打印打印效果更均衡,速度更快. 浓度稍淡.
	测试网口驱动打印效果同上. 浓度稍淡.
	命令定义字符浓度正常.
4.	GetHeatTime()修改. 初始步阶段增加加热时间直接实现, 不用通过函数.
	DRV_PRT_HEAT_TIME_ADJUST_ENABLE添加, 增加驱动打印模式下加热时间补偿.
	WH驱动时增加加热时间150.
	测试打印浓度良好.
5.	MAX_RUSH_STEPS_ON_SP_DRV_PRT 由 30 改为 15.
	MAX_RUSH_STEPS_ON_SP_DRV_PRT_COM 由 20 改为 10.
	测试SP驱动U口和网口自检打印良好.
6.	WH驱动限速对应参数值修改为与SP相同.
	测试正常.
	修改后S口WH驱动打印正常.
7.	修改寿命试验程序的自检纸张长度值宏定义.
	ReliabilityTestKm50(), ReliabilityTestMinute(), ReliabilityTestCutterLife()修改.
	等待打印结束的等待放到写入参数之前.
	实际测试如果打印过程中缺纸, 停止打印, 但是换纸后中间等待时间中依然按照已经打印完成计算次数. 错误.
	StartFeedMotor() 函数中发现错误后停止各个定时器并关闭上纸和加热,然后退出. TIM3控制中下面的程序
	会继续执行定时, 从而让打印继续下去.
	StepFeedMotor() 修改. 当出现错误时一直等待错误被解除.
	修改后不再出现以上错误, 测量次数计算正确. 但是打印的第一行内容有可能会被压缩. 因为起始定时时间会计算错误.
	此为重要修改.
8.	ProcessModeType()修改. 正常模式下切纸处理改为寿命测试时不切纸.
	normal.c文件中添加 #include	"reliable.h".
9.	ReliabilityTestKm50()修改. 添加打印提示信息.
	修改后S口WH驱动打印正常.


程序版本:0.279
编写人员: 
编写日期:2013-8-26
继续测试0.264版本修改过的地方.
1.	测试2分钟打印实际每次打印间隔为2分11秒多点, 下次比上次时间多延时约12秒.
	InitReliableTest()修改. 延时间隔由1ms改为1s.
	TIM5_IRQHandler()修改. 由判断ms改为判断s.
	修改后定时准确了.
	分钟测试附加长度改为23, 50km测试附加长度改为25.
2.	TEST_CUTTER_LIFTE 改为 TEST_CUTTER_LIFE. 替换相应地方.
	切刀测试附加长度改为40.
	提交该版本进行测试.
	修改后S口WH驱动打印正常.
	使用P05测试正常.串口驱动打印不死机.


程序版本:0.280
编写人员: 
编写日期:2013-8-26
继续测试0.265版本修改过的地方.
使用P05测试正常.串口驱动打印不死机.
1.	将驱动打印公司的变量改为宏定义.	替换对应程序的地方.
	DRV_PRT_TYPE_NONE等.
2.	添加P05相关的程序.
	CheckInterface()修改.添加根据机型进行条件编译.
	PrintModel(), PrintInterfaceType(), PrintUsartParameter()修改.添加根据机型进行条件编译.
	有待实际测试.
3.	DMA1_Channel1_IRQn 与 TIM2_IRQn 优先级互换. DMA1换成更高.
	使用P05测试正常.串口驱动打印不死机.


程序版本:0.281
编写人员: 
编写日期:2013-8-26
继续测试0.266版本修改过的地方.
将0.266版本的selftest.h和.c文件替换.
1.	按照新规则改写自检打印样条程序.
	按照英文,GB18030,BIG5三种编码方式提供自检信息.每部分内容为:
	生产者公司名称及标示
	打印机型号信息
	软件版本信息
	打印机接口信息
	打印机固定参数信息
	打印机用户可修改参数信息
	可支持的打印文字内容实例
	其他
	特殊程序的内容
2.	PrintStartTile()修改.根据系统默认语言打印提示信息.
	测试出现错误,当设置为BIG5时,发送BIG5编码打印内容为乱码.
	分析发现编译器将BIG5码内容编码时按照GB18030的编码方式进行编码而非BIG5编码方式.
	打印BIG5之前将系统语言改为GB18030,打印完毕再恢复为BIG5.
	测试打印BIG5自检通过.
3.	PrintManufacturer()修改.根据系统默认语言打印提示信息.
	测试打印BIG5自检通过.
4.	PrintModel(),PrintSoftwareVersion()修改.
	根据系统默认语言打印提示信息.测试打印BIG5自检通过.
5.	PrintInterfaceType(),PrintParallelParameter()修改.
	根据系统默认语言打印提示信息.测试打印BIG5自检通过.
6.	PrintUsartParameterReal()修改.
	根据系统默认语言打印提示信息.测试打印BIG5自检通过.
7.	PrintUSBParameter(),PrintEthParameter()修改.
	根据系统默认语言打印提示信息.测试打印BIG5自检通过.
8.	修改后使用P05测试正常.串口驱动打印不死机.
	使用P05测试三种语言设置自检打印均符合预期.


程序版本:0.282
编写人员: 
编写日期:2013-8-26
继续测试0.267版本修改过的地方.
1.	测试使能USBID后PC无法识别打印机.无法自动安装驱动.
2.	简化0.266版本修改程序的使用,将公共部分放到主调程序中控制,测试三种语言打印通过.
	PrintSoftwareVersion()修改.添加下发日期信息.测试通过.
	添加 DBG_NEW_METHOD_SELFTEST 宏定义. 否则使用的还是老方式的自检.
	SystemSelfTest()中去掉条码和黑块的打印.去掉切刀前的等待.
	寿命测试的所有宏定义必须在寿命测试程序中才能有效,否则全部关闭宏定义.
	测试通过.


程序版本:0.283
编写人员: 
编写日期:2013-8-27
继续测试0.268版本修改过的地方.
1.	PrintCapacity()添加.打印固定性能参数.测试三种语言打印通过.
	PrintStartCommon()添加.开头之前的全放到此处.
	将下标参数改为局部变量,将各个自检打印程序改为根据变量打印.
	测试三种语言打印通过.
	使用0.268的selftest.c/.h文件替换.修改版本号.
	测试正常.


程序版本:0.284
编写人员: 
编写日期:2013-8-27
继续测试0.269版本修改过的地方.
使用0.269的selftest.c/.h文件替换.修改版本号.
1.	PrintCapacity()修改,添加条码打印内容.
2.	PrintVarable()添加.打印可设置选项.
	提示内容按照三种语言处理,具体选项全部按照ASCII处理.
	SystemSelfTest()修改.在其中单独处理语言选项.
3.	PrintASCIICharacter(),PrintChineseCharacter()修改.
	添加提示信息.改为按照输入参数打印.
	测试均通过.
4.	PrintBarCodeType(),改为按照输入参数打印.打印一个示例.
	测试不打印具体内容.有错误.
	暂时不打印黑块和条码.
5.	三种语言设置下打印测试通过.
	直接打印自检正常.
	打印自检完毕接着打印通信接口内容正常.
	WH驱动打印S/U/E均正常.


程序版本:0.285
编写人员: 
编写日期:2013-8-27
继续测试0.270版本修改过的地方.
1.	测试P04/P05网口打印自定义RAM图形,
	同时执行1D 2F 00~03时会发生1D 2F 01压缩成一条线的错误.
	单独执行每一条指令1D 2F 0x时不会出现压缩.
	组合测试两条指令及三条指令发现,出现压缩的规律:
	0x	00 
	0x	01
	00	01	0x
	00	0x	01
	01	00	0x
	01	0x	00
	02	0x	0x
	03	0x	0x
	Command_1D2F()修改.去掉处理前的等待打印结束.
	去掉WaitHeatAndFeedPaperFinish().
	修改后不再出现任何压缩.

继续测试0.271版本修改过的地方.
1.	DRIVE_PRT_MODE_RX_DELAY_ENABLE打开,但是只对串口有效.
	ReadInBuffer()修改,驱动接收延时只对串口有效,延时时间由300改为100ms.
	最高限速20,S限速15,
	U限速20,E/P限速15,均无延时.
	U/E口驱动打印一打印就死机.
2.	ReadInBuffer()修改,驱动接收延时E/P/U均恢复为延时3ms.
	修改后U/E驱动打印正常.
	
继续测试0.272版本修改过的地方.
1.	测试实时开钱箱指令,10 14 fn m t.
	Command_1014fnmt()修改.添加m和t参数有效性的检查处理.
	目前程序如果连续开启两个钱箱,只能逐个开启,不能同时开启.
2.	修改P05机型端口检测程序.之前不检测只按照串口和网口赋值.
	CheckInterface()修改.
	修改后测试通过.
3.	P05接了二极管降压,打印效果显得比P04浅.目前二极管已经去掉.
4.	上纸电机驱动电压不能低于22.2V,所以电压误差告警应该设置为6%之内.
5.	测试P05的16进制打印时第一行缺少自动换行.
	HexMode()修改.
6.	测试十六进制打印工作正常.
	WH驱动打印S/U/E均正常.


程序版本:0.286
编写人员: 
编写日期:2013-8-27
继续测试0.273版本修改过的地方.
1.	测试P05的16进制打印时第一行缺少自动换行.
	HexMode()修改.修改缓冲区长度,修改缓冲区处理方式,无需用指针.
	使用0.273版本的HexMode()替换.
	P04测试16进制打印通过.
2.	defconst.h修改. P04/P05宏定义改为单独定义其中之一.
	另外自动去掉另一种的宏定义以防止同时定义二者.

继续测试0.274版本修改过的地方.
1.	调整旋转打印时速度,解决压缩故障.
	TypeDef_StructPrtMode修改,添加CharCycle90项目.
	GetMaxAccelerateSteps(),SetLinePrtModeVariable()修改.
	添加旋转90度打印限速检查.
	PrintStartTile()中去掉是否有在线升级信息的打印.
2.	修改后WH驱动打印S/U/E均正常.
	正常指令打印正常.旋转/放大/反黑组合打印正常.
	连续打印下载RAM位图正常.


程序版本:0.287
编写人员: 
编写日期:2013-8-27
继续测试0.275版本修改过的地方.
添加Hardfault异常时候的LED提示.
开机初始化时,切刀初始化如果无纸则不动作,修改此处.
1.	添加Hardfault异常时候的LED提示.
	HardFault_Handler()添加状态指示灯提示,每隔固定时间闪烁6次,然后常亮.
	MemManage_Handler(),BusFault_Handler(),UsageFault_Handler()添加注释.
2.	DBG_RCV_DATA_LOSE 相关的变量前面添加 g_u.
3.	InitStdPeriph()修改.串口初始化二者颠倒.
	先USART_Config(),再InitUsartPort().
	测试不再出现加电PC端串口接收到一个不需要的FF或者其他值的字符.
4.	SystemInit()修改,添加mem,bus,usage三种异常的中断允许.
5.	修改后测试字符及驱动打印正常.
	驱动打印的深浅浓度不令人满意.
6.	驱动打印时,串口延时由100改为50.
	测试WH驱动S口打印效果没有改变.
	串口延时由50改为5.
	测试WH驱动S口打印效果没有改变.
	E口打印效果良好,U口稍有停顿.


程序版本:0.288
编写人员: 
编写日期:2013-8-27
测试驱动打印.
1.	去掉驱动打印时的限速,去除E/U/P口的延时等待.
	U/E口驱动打印一开始打印就死机.
	S口驱动打印正常.
2.	恢复读数时E/U口的延时等待,U/E驱动打印正常.
	继续提高E/U口速度.
	E限速由 15 改为 20 , U限速由 20 改为 30 .
	修改后二者可以正常打印,中间断行增加.
3.	E/U读数时延时等待由 > 3 改为 > 1.
	修改后二者可以正常打印.
4.	E限速由 20 改为 30 , U限速由 30 改为 40 .
	修改后E/U口过快出现压缩,突突.
5.	E/U读数时延时等待由 > 1 改为 > 0.
	S读数时延时等待由 > 5 改为 > 1.
	修改后E/U口恶化,S口变化不大.
6.	E/U读数时延时等待由 > 0 改为 > 3.
	S读数时延时等待由 > 1 改为 > 3.
	S限速由 15 改为 20.
	修改后S口变化不大,E/U口不再压缩,但是电机不是最平稳.
7.	S限速由 20 改为 15.
	U限速由 40 改为 30.
	S读数时延时等待由 > 3 改为 > 100.
	E/U读数时延时等待由 > 3 改为 > 15.
	修改后E口压缩,U口基本不压缩.
8.	E读数时延时等待由 > 15 改为 > 10.
	U读数时延时等待由 > 15 改为 > 5.
	修改后E口压缩,U口基本不压缩.
9.	E限速由 30 改为 20.
	U限速由 40 改为 30.
	S读数时延时等待由 > 100 改为 > 80.
	修改后S可以接受,E可以接受,U电机稍微不稳.
10.	U限速由 30 改为 25.
	U/E读数延时均改为 > 15.
	效果变化不大.
11.	U限速由 25 改为 20.
	U/E读数延时均改为 > 5.
	U/E基本可以接受.
	U/E读数延时均改为 > 1.
	E效果比U好.
	E读数延时改为 > 2.
	U读数延时改为 > 3.
	二者效果基本可以接受.
12.	实测速度:
	U口	79mm/s, U口限速15更合适.
	E口	85mm/s, E口限速20合适.
	S口	25mm/s, S口限速3更合适.
13.	P口驱动打印实际效果不理想.
	使用原0.272版本驱动打印效果理想,速度合适,电机平稳,字迹均匀.
	P限速由 20 改为 15.
	P驱动打印基本可以接受,有些停顿.
	P读数时延时等待由 > 3 改为 > 10.
	效果基本同上.
	P读数时延时等待由 > 10 改为 > 80.
	打印效果基本可以接受.
	P读数时延时等待由 > 80 改为 > 50.
	实测速度:
	P口	79mm/s.
14.	堆栈长度增加1倍修改为0x1000.
	S/P驱动打印测试正常.
15.	将此版本作为P05测试小组测试版本提交.


程序版本:0.289
编写人员: 
编写日期:2013-8-28
添加正常状态时通过状态(即错误)指示灯提示.
1.	FlashErrorLed()修改.重新编写.
	变量 LedNumber 改为 LedFlashNumber.
	LedCount 改为 LedTimeCount.
	LED_FLASH_MS, LED_FLASH_INTERVAL_MS 挪到 defconst.h.
	LED_FLASH_INTERVAL_MS 改为 LED_FLASH_TOTAL_INTERVAL_MS.
	处理方式逻辑基本同之前函数. 
	但是修改了同时出现缺纸及其他状态的时候的提示错误.
2.	添加正常状态下指示灯提醒.
	正常状态下每隔30S状态指示灯闪烁一次.
	LED_FLASH_NORMAL_TOTAL_INTERVAL_MS 添加.
	NormalStatusFlashLed()添加.
	SystemTimer2Func()修改.
3.	测试通过.
4.	使用USB转TTL测试串口驱动打印工作正常,使用RS232接串口驱动打印死机.
	后测试串口驱动打印死机.
	修改堆栈为0x800后还是死机.
5.	Command_1B13()修改. 检查打印之前已编辑好的行缓冲区处理放到最前面.
	修改后依然死机.
6.	修改堆栈为0x1000.
	使用USB转TTL测试串口驱动打印工作正常,使用RS232接串口驱动打印死机.
	去掉TVS后依然死机.
7.	修改堆栈为0x800.
	MAX_BYTES_OF_IN_BUF 由 4K 改为 7K.
	MAX_RSV_BYTES_OF_IN_BUF 由 512 改为 1K.
	MIN_RSV_BYTES_OF_IN_BUF 由 256 改为 128.
	2 级优化编译.
	修改后依然死机.
	恢复COMIN的修改. 0 级优化.
8.	原等待延时100. 死机.
	改为10, 没有死机但是停止打印.
	调试发现堆栈地址设置为 2000 0500, 与预期 2000 0800不符.
	使用V3.5默认库的HD 启动文件替换.
	调试发现堆栈地址改为 2000 B2D0.


程序版本:0.293
编写人员: 
编写日期:2013-9-2
以0.289修改.调试WH驱动串口打印死机.
命令解析和打印内容编辑使用 g_tPrtDataBuf 和 g_tPrtCtrlData 配合使用.
打印缓冲区使用 g_tLinePrtBuf ,其中包括打印内容和打印控制相关变量.
二者之间并行处理.
当前编辑缓冲区空闲时, 先编辑打印内容, 编辑满后检查打印缓冲区是否空闲,
如果忙则等待.
如果空闲则复制相关打印内容和控制变量到打印缓冲区,启动打印;清空编辑缓冲区
及控制变量,准备下次编辑.
1.	CodeRollCtrl(), EmphaSizeProcess(), FillPrintBuff()修改.
	添加判断输入参数最大值的处理, 确保操作不越界.
	添加指针处理, 用完后即置为NULL.
	g_tPrtCtrlData.LineHigh 用来表示编辑过程中字符的最高点数 CharHigh
	g_tPrtCtrlData.MaxPrtDotHigh 用来表示打印缓冲区内容中打印最高点数.
2.	FillDataPrintBuff()修改.
	修改地址计算方法,减少乘操作.
3.	FillPrintBuff()可以分拆为填充左边距, 字符实体, 右边距, 下划线
	四个部分内容的子程序.有待修改.
	CopyPrtDataToLineStruct() 名称有待 改为 CopyDataToLinePrtStruct().
4.	将LINE_EDIT_BUF 和 CHAR_MARSK_READ_BUF 相关的宏定义分别改用缩写替换.
	g_tPrtDataBuf 名称改为 g_tLineEditBuf. 相应替换.
	测试后各种组合指令测试通过.
5.	PrepareNewLine(), CopyPrtDataToLineStruct(), ClearLinePrtBuf(),修改.
	添加判断各种参数范围合法性,防止内存操作越界. 指针用完指零.
	TypeDef_StructPrtMode, TypeDef_StructPrtCtrl 宏定义修改,调整变量排列方式.
	测试后各种组合指令测试通过.
	SetLinePrtModeVariable()修改. 添加 PrtWidth 成员的赋值. 
	调整各成员赋值顺序. 按照定义顺序赋值. 指针用完指零.
	PrepareNewLine() 修改. 调整参数赋值顺序, 按照定义顺序赋值. 
	添加 CharWidth, CharHigh成员的赋值.
	CodeRollCtrl(), FillPrintBuff(), FillDataPrintBuff()修改. 指针用完指零.
	测试后各种组合指令测试通过.
6.	ProcessCharMaskReadBufEdit()修改.
	编辑缓冲区空闲,填充检查为满时,只设置满标志,退出.不执行打印后再继续填充.
	修改后各种组合指令测试通过.
	自检通过.
	16进制打印时会出现不能正确换行的错误. 恢复修改也有同样错误.
	HexMode()错误. 修改 HEX_PRT_CHAR_LEN 值. 增加1.
	数组变量名称改为 PrtDataStr[].
7.	WaitPreviousPrintFinish()函数处理有问题.
	GetTimerEnableStatus()添加. 检查指定定时器使能状态.
	SystemTimer2Func()修改. 检查到打印状态不为ILDE 且打印定时器关闭情况下开启之.
	WaitPreviousPrintFinish()修改为一直检查状态值是否为ILDE.
	修改后十六进制打印还会出现换行错误.
	串口驱动打印不再死机.


程序版本:0.294
编写人员: 
编写日期:2013-9-3
1.	HexMode()修改. 只保留一个NUL字符. 无需手动添加空格.
	测试16进制打印通过.
2.	CopyPrtDataToLineStruct() 改为 CopyEditDataToLinePrtStruct().
	PrintOneLine()修改. 修改处理走行间距判断. 逻辑与之前相同.
	InitHeatElementBuf(), InitHeatElementBufLeftEmpty(), PRINTER_Out()等修改.
	除少数地方外将所有 memset() 操作的个数参数改用 sizeof() / sizeof([0]) 实现.
	替代使用宏定义实现.	指针用完指零.
	Command_1D76()修改. 添加参数范围判断.
3.	InitLinePrtBuf(), GetPrintStatus()修改. 改用简化处理模式. 
	TypeDef_StructPrtMode 宏定义修改, 去掉跳格的相关控制. 无用.
	CopyDotLineDataToHeatElementBuf()修改. 指针用完指零.
	PrintLineBuffer()修改. 直接用变量,无需指针.
	DBG_UNDER_LINE_PRT 改为 UNDER_LINE_PRT_ENALBE.
4.	StartPrintLineBufChar()修改指针名称, 指针用完指零.
	修改处理字符和下划线的流程. 
	测试正向打印下划线正常.
	测试反向打印下划线为1点时, 打印为空白. 2点时打印正常.
	GetLinePrtBufStartColumnIndex(), LineBufToHeatElementNormalDir()修改. 
	添加变量合法范围判断. 防止内存越界访问. 添加异常返回值处理.
	LineBufToHeatElementReverseDir()


程序版本:0.295
编写人员: 
编写日期:2013-9-5
StartPrintLineBufChar()
	if (DIR_NORMAL)
		FillHeatElementBuf(*, )
			LineBufToHeatElementNormalDir()
		sHeat_StartDMATx()
		FillUnderLineToHeatElementBuf()
			UnderLineBufToHeatElementNormalDir()
		sHeat_StartDMATx()
	if (DIR_REVERSE)
		FillUnderLineToHeatElementBuf()
			UnderLineBufToHeatElementReverseDir()
		sHeat_StartDMATx()
		FillHeatElementBuf()
			LineBufToHeatElementReverseDir()
		sHeat_StartDMATx()
1.	LineBufToHeatElementNormalDir(), LineBufToHeatElementReverseDir(),
	UnderLineBufToHeatElementNormalDir(), UnderLineBufToHeatElementReverseDir()
	修改. 添加变量范围合法性检查处理. 防止内存越界.
	目前程序还不能完全防止下标越界.
	下划线正向打印时, 按照打印点行数从高到低顺序变化表示先打印最高行, 依次降低.
	下划线反向打印时, 按照打印点行数从高到低顺序变化表示先打印最低行, 依次升高.
	所以下划线反向打印时计算点行数的计算特殊.
2.	下划线改用BIT3 替代BIT7 标志是否打印下划线. 所有变量赋值和判断改用宏定义实现.
	这样以后下划线缓冲区也可以同时用来处理上划线. 
	目前的下划线打印处理程序对于反向打印时1点行和2点行会有冲突,出现错误.
	需要修改其打印控制流程处理.
3.	修改下划线加热数据的提取计算. 先统一按照正向打印提取, 
	然后如果反向打印再逆序加热数据.	数据发送方式全部一致.
	ReverseByte(), ReverseStreamEachBit() 添加.
	FillUnderLineToHeatElementBuf() 修改. 
	修改后实现效果错误. 暂时不实行该修改.


程序版本:0.296
编写人员: 
编写日期:2013-9-5
修改下划线打印实现方法.
1.	TypeDef_StructPrtMode 添加 UnderlinePrintIndex.
	SetLinePrtModeVariable()修改. 添加新成员的赋值.
	StartPrintLineBufChar()修改. 修改正向打印时下划线处理.
	UnderLineBufToHeatElementNormalDir()无需修改. 
	CheckPrintContentFinishOfChar()修改. 修改正向打印时下划线处理.
	当点数为1时不打印.
	FillPrintBuff()修改. 下划线添加时改为 |= .
	SetLinePrtModeVariable()修改. 下划线相关成员的赋值放到WaitToPrintLineBufOfChar().
	WaitToPrintLineBufOfChar()修改如上.
	正向打印下划线0,1,2点各种组合测试通过.
2.	StartPrintLineBufChar()修改. 修改反向打印时下划线处理.
	UnderLineBufToHeatElementReverseDir()修改. 修改反向打印时下划线处理.
	CheckPrintContentFinishOfChar()修改. 修改反向打印时下划线处理.
	HEAT_TIME_MIDDLE 由 300 改为 350.
	HEAT_TIME_HIGH 由 400 改为 450.
	反向打印下划线0,1,2点各种组合测试通过.
	反向打印1点行时字迹较淡.
	添加m_bReversePrintUnderlineFlag 标志反向下划线打印标志.
	StartPrintLineBufChar(), StartHeatAndRotateMotor(),
	CheckPrintContentFinishOfChar()修改. 处理该变量. 额外增加加热时间.
	修改后反向打印1点行时浓度与正向1点行差不多.
	测试感觉不合适.去掉该修改.
3.	WaitToPrintLineBufOfGraphic()检查.
	目前只处理BitImageFlag. 图形打印时不处理下划线.
	StartPrintLineBufGraphic()检查. 修改变量名称, 指针用完指零.
	去掉不必要的多余局部变量, 添加变量参数安全范围检查.
	图形打印检查结束.
4.	Command_1B13()修改.
	开始处理前不检查是否有等待打印的内容.不等待之前是否打印完成.
	最大接收字节数根据g_tPrtCtrlData.PrtLength 计算.
	检查参数安全.修改处理流程.直接设置控制参数,如果处理过程中满行则直接打印;
	如果不满行则处理完后再打印.
	修改后串口驱动测试不死机. 打印乱码.
	测试打印RAM位图正常.
5.	CopyEditDataToLinePrtStruct()修改. 修改不完全复制时候的判断条件.
	Command_1B13()修改. 填充时不管接收数据是否为0, 均按照非零字符流程处理.
	修改后E 口驱动打印正常. S口打印乱码, 但是不死机,正常全部处理完毕.
	驱动串口读数延迟时间由10 改为 150.
	修改后效果同改之前差不多.
	恢复延迟. Command_1B13()修改. 修改满行判断条件.修改后效果同改之前差不多.


程序版本:0.297
编写人员: 
编写日期:2013-9-6
1.	Command_1B13()修改. 填充时当接收数据不为0才按照非零字符流程处理.
	修改后E 口驱动打印正常. S口打印乱码, 但是不死机,正常全部处理完毕.
	驱动后继续字符打印正常.
2.	GetLPBProcessStatus()添加. 判断LPB处理是否正常完成.
	SystemTimer2Func()修改. 调用以上函数处理LPB. 暂时禁用.
	Command_1B13()修改. 满行后不打印直接退出循环. 串口读数延时由150 改为 15.
	修改后串口驱动无改善.
3.	禁用驱动延时, E 口工作正常, S 口调试发现出现丢数.
	ReadInBuffer()修改. 取数时只关中断,不置忙.置忙由各个中断中进行,解除忙由读数中进行.
	修改后 E 口工作死机. 恢复以上修改.
4.	ProcessCharMaskReadBufIlde()修改. 添加接收缓冲区无数据时检查按键处理.
	修改后按键随时都能起作用.
	驱动S 口 9600bps能够正确打印. 驱动打印自检正常.
	57600bps用调试软件能够正确打印, 驱动打印自检不行.
	115200bps用调试软件有时正常,有时乱码.
	配置为921600bps,COM1能达到的最高速度,测试发现打印全部为乱码.
5.	ReadInBuffer()修改. 取数时不关中断,只置忙.
	修改后S口 115200bps驱动可以正常打印,有部分丢数. E口乱码.
6.	ReadInBuffer()修改. 取数修改g_tInBuf.BytesNumber时不关中断,
	先判断g_tInBuf.BytesNumber值再修改. 
	修改后E 口有时打印乱码,有时不打印.
	ReadInBuffer()修改. 修改g_tInBuf.BytesNumber时除了串口外都关中断. 串口不关.
	测试E口每次打印的接收和处理字节数相同. S 口每次都不同.打印乱码.
7.	使能驱动打印延时,S 口最大延时300,其他均不延时.
	S 口驱动打印乱码且有丢数. E 无乱码,无丢数.
	9600bps驱动打印无乱码, 丢9个字节.
8.	接收缓冲区由4K改为6K. 调试发现9600bps时接收及保存数据均正确, 读数及位置均正确,
	但是标示剩余字节数的值比正确值少10.
9.	ReadInBuffer()修改. 修改g_tInBuf.BytesNumber时都关中断.
	调整后接收处理字节数相等. 但是接收过程中有丢数. 不禁止中断共接收106161字节.
	禁止中断后接收数变少,中间有丢数. E口正常.
10.	禁用驱动延时等待,还是打印乱码.
11.	NormalStatusFlashLed()修改. 添加关闭蜂鸣器.
	测试蜂鸣器工作符合说明.
	串口驱动还是有待解决.


程序版本:0.298
编写人员: 
编写日期:2013-9-6
1.	ReadInBuffer()等修改. 所有关闭中断的地方处理完变量后立即开中断.
	串口驱动自检还是乱码.
	调试测试使用软件接收比发送少,但是差距有减少.
	改之前发送	10440	实际接收	10417
	改之后发送	10440	实际接收	10433
2.	USART1_IRQHandler()修改. 简化接收处理. 不处理校验及错误码. 直接保存.
	结果没有改善. 实际接收	10430/10431.
	ReceiveInterrupt()只处理串口1.还是乱码.
	使用测试工具,如果每次发送的数据量不超过接收缓冲区的满值,
	接收处理值相同,	无丢数,无乱码. 数据量2900字节, 连续测试 60900字节. OK.
	改接收缓冲区相关变量还是乱码.
3.	编写测试程序. 只接收, 不处理. 满后置忙. 
	使用测试工具一次发送超过满区域的数据.
	3840为分界点,低于3840不满,大于等于3840开始满.
	一次发送低于3840, 不置忙, 单个发送, 满后置忙, 再发送无法进行. 正确.
	一次发送3842, 全部发送过来, 全部接收到, 置忙. 再发送无法进行. 有问题.
	一次发送3872, 接收到3856后停止接收,置忙,测试软件死机. 有问题.
	使用驱动程序打印自检,接收到3855字节后停止接收,置忙,不再接收.
4.	串口驱动延时等待最大1ms.
	使用P04_0.276测试程序配合测试 71019 字节, 可以完全顺利打印完全部内容.
	连续两次发送打印正常.
	串口驱动程序打印乱码.
	网口驱动打印正常.


程序版本:0.299
编写人员: 
编写日期:2013-9-10
上一版本未关闭驱动打印读数接收延时.只接收不读取.
1.	测试工具一次发送3841, 接收到3841, 检测信号已置忙. 再发送则不再接收.
	测试工具一次发送3905, 接收到3841, 检测信号已置忙. 不再接收.
	测试说明串口接收及忙信号处理正常.
2.	恢复读数处理, 测试工具一次发送4075, 接收到4075, 打印正常.
	驱动S自检,正常打印完毕,中间有乱码.
	串口限速由15改为5. 打印中间停止, 打印乱码.
	等待很长时间才继续打印.	等待过程中忙信号为低. 
	串口限速由15改为10. 打印不停止, 打印乱码. 乱码减少.
	使用测试工具一次发送 10461 字节打印无乱码.
	使用测试工具一次发送 8163 字节打印无乱码.
	使用测试工具一次发送 15335 字节打印无乱码.
	使用测试工具一次发送 18251 字节,有时打印乱码,有时打印无乱码.
	使用测试工具一次发送 20579 字节,有时打印乱码,有时打印无乱码.
	调试时打印无乱码,接收和处理字节相等,无丢数.
	使用测试工具一次发送 31055 字节,有时打印乱码,有时打印无乱码.
3.	使用P04_0.276测试程序配合测试 71019 字节, 可以完全顺利打印完全部内容.
	无丢数, 不死机, 打印内容很正常.
	配合测试一次 186201 字节. 很正常.
4.	MAX_RUSH_STEPS_ON_WH_DRV_PRT_COM 改为 15.
	使能驱动打印串口读数等待延迟50.
	配合测试一次 186201 字节. 很正常.
	配合测试连续发送5次以上内容, 会出现乱码.
5.	使能驱动打印串口读数等待延迟300.
	还会出现以上情况.
	网口打印出现乱码. 重装驱动后网口恢复正常.
6.	串口限速5, 不延时等待.
	串口限速4, 不延时等待.
	配合测试连续发送2次以上内容, 正常.
7.	串口限速15, 延时等待60. 
	ProcessMotor()修改, FEED_MOTOR_ILDE_NUMBER 由 2 改为 1.
	修改后还出现乱码.
	PrepareNewLine()修改. 直接全清空. 修改后还出现乱码. 恢复.
8.	USART1_IRQHandler()修改. 进入先置忙, 退出前再次处理解除忙.
	修改后打印全为乱码. 恢复.
9.	ReadInBuffer()修改. 
	调整字节数时只关中断, 不置忙. 由满变不满时一并清除忙. 
	修改后打印全为乱码. 网口也打印乱码. 恢复.
	DRV_PRT_COM_MIN_DELAY_MS 改为 1. 还打印乱码. 网口也打印乱码. 


程序版本:0.300
编写人员: 
编写日期:2013-9-11
由0.298版本修改.
1.	添加三个新函数, 处理当前活跃的通信端口的忙信号和中断信号.
	原 ReceiveInterrupt()只处理了串口. 恢复.
	端口枚举宏定义更改COM为0, LPT改为1.
	ReadInBuffer()修改, 将所有的 
	SetComInBufBusy() 改为 SetActiveComInBusy(),
	ClearComInBufBusy() 改为 ClearActiveComInBusy(),
	ReceiveInterrupt(DISABLE) 改为 DisableActiveReceiveInterrupt(),
	ReceiveInterrupt(ENABLE) 改为 EnableActiveReceiveInterrupt(),
	虽然如此修改不正确, 测试串口.
	配合测试发送一次还会出现打印乱码. 恢复修改.
2.	MAX_RSV_BYTES_OF_IN_BUF 改为 1024,
	MIN_RSV_BYTES_OF_IN_BUF 改为 256,
	配合测试发送一次还会出现打印乱码.
3.	串口初始化速度改为 4500KBPS,
	测试打印乱码. 立刻发完.
	恢复修改.
4.	修改0.276版本测试程序, 串口发送程序修改, 
	发送一个字节后判断 USART_FLAG_TC 等待本字节发送完毕.
	P05无接收缓冲等待.
	测试连续3次发送或者单次发送均无错误. 字迹均匀深浅一致, 电机有振动.
	使能驱动接收等待. 
	测试连续3次发送或者单次发送均无错误. 字迹均匀深浅不一致, 电机没有振动.
	使用驱动程序打印自检还会乱码.
5.	UpLoadData()修改.
	修改USART1和ETH_USART的发送结束判断. 先发送, 然后一直等待发送结束.
6.	MAX_RSV_BYTES_OF_IN_BUF 改为 512,
	MIN_RSV_BYTES_OF_IN_BUF 改为 128,
	测试连续3次发送或者单次发送均无错误. 字迹均匀深浅不一致, 电机没有振动.
7.	串口波特率改为 921600.
	测试连续3次发送或者单次发送均无错误. 字迹均匀深浅基本一致, 电机没有振动.
	可见可以达到最高921600bps.


程序版本:0.301
编写人员: 
编写日期:2013-9-11
1.	将通信端口中断相关部分改为宏定义.
	usart.h添加串口中断号宏定义 USART_IRQ_NUMBER, 修改相关程序.
2.	检查跳格相关的所有程序.
	DEFAULT_HT_WIDTH 宏定义添加.
	InitTabStructParameter()修改. 修改默认跳格设置初始化计算.
	Command_09()修改, 添加执行跳格时行已满的处理.
	Command_1B44()检查.
	测试跳格相关指令通过.
3.	Command_0A(), Command_0D()检查.
4.	Command_1004()检查, 测试四个参数的各种状态通过.
	切刀错误无法测试.
5.	Command_1005n()检查, 修改清空打印缓冲区操作.
	添加清除可能的打印未完成变量标识. 最后再开接收中断.
	10 05 02处理完毕.
	CutError()修改. 
	添加等待切刀位置到位后, 再根据g_tError.R_ErrorRecoversFlag 等待.
	可以通过指令10 05 01 来解除切刀错误. 以继续执行程序.
*10 05 01暂时未测试完毕. 因为切刀错误不可随便实现.
	上电切纸完成后返回值为1, 而不是0.
6.	CutPaper()修改. 修改注释和各个阶段返回值.
	除了最后一种情况返回错误外, 其他都返回正确.
	修改后切刀工作正常.


程序版本:0.302
编写人员: 
编写日期:2013-9-12
1.	g_tError.R_ErrorFlag 为 1 表示切刀位置错误,
	CutError()中将其赋值. 添加注释.
	Command_1005n()修改. 只有发生了可恢复错误才执行该指令. 不包括可自动恢复错误.
	1005指令检查完毕.
2.	Command_1014fnmt()修改.
	修改并口忙的检查. 处理实时开钱箱程序检查结束.
	Command_1B20()检查完毕.
	Command_1B21()修改. 加粗模式只对字符有效, 对汉字无效.
	Command_1B24()检查完毕.
	Command_1B25()检查完毕.
	Command_1B26()检查完毕. 修改指针定义初始化, 用完指零.
3.	Command_1B2A()检查完毕. 原处理有缺陷.
	修改指针定义初始化, 用完指零.
	修改最大接收数据判断, 改用设置的控制变量值判断.
	去掉打印之前检查当前缓冲区需要打印的处理。
	修改处理流程. 不一定在首行才处理.
	修改后处理的结果可以与之前未完成的位图或者字符混合编辑.
	编辑过程中满行则打印, 多余数据丢弃.
	不管是否满行, 都需要设置控制变量.
	修改后混合测试8, 24点图形与汉字字符下划线放大指令混合测试通过.
	Command_1B2D()检查完毕.
	Command_1B32()检查完毕.
	Command_1B33()检查完毕.
4.*	Command_1B3D()检查完毕. 未测试. 
	g_tSystemCtrl.PrtDevOe 改为 g_tSystemCtrl.PrtDeviceDisable. 修改对应处.
	DataProcess()修改. 无需在此处处理1B3D, 
	只需要在ProcessCharMaskReadBufIlde()中处理即可.
5.*	Command_1B3F()检查完毕. 未测试.
	修改指针定义初始化, 用完指零.
*	GetAscIIDotData()修改. 修改判断条件. 
	9*17和12*24两种字体可以单独定义, 所以需要分开判断.
6.	g_tRealTime 改为 g_tRealTimeCmd, 修改对应地方.
	InitMacroStructParameter(), InitInbufParameter()修改. 
	去掉输入参数变量. 由调用函数在调用前判断.
*	InitParameter()修改. 
	对应修改以上函数调用处理. 添加 g_bLineEditBufStatus 初始化.
*	Command_1B40()检查完毕.
7.	Command_1B45()检查完毕.
	Command_1B47()检查完毕.
8.*	Command_1B4A()修改. 无需等待, 直接启动打印.
	Command_1B4D()检查完毕.
	Command_1B52()检查完毕.
	Command_1B53()检查完毕.
	Command_1B56()修改. 简化参数2的赋值.
	Command_1B5C()检查完毕.
	Command_1B61()修改. 添加标准模式下行首才有效的处理.
9.	1B6333()检查完毕.
	SystemTimer2Func()中处理并口缺纸输出控制.
*	1B6334()检查完毕. g_tError.PaperEndStop 相关程序有待测试.


程序版本:0.303
编写人员: 
编写日期:2013-9-13
1.	TypeDef_StructError 修改. 
	PaperSensorFlag 改为 PaperSensorStatusFlag,
	PaperEndSensor 改为 LPTPaperEndSensorSelect,
	PaperEndStop 改为 PaperEndStopSensorSelect,
	调整各个变量定义顺序. 修改程序中对应地方.
	ErrorDetect()中已经处理了PNE. 但是只具体到点行上.
*	ErrorDetect()修改PNE处理. 
	当出现PNE时, 打印机打印完当前行并进纸后不再打印.
*	SystemTimer2Func()修改. 添加缺纸及PNE如上处理, 进入离线状态.
2.	*1B6335()检查完毕. 
	检查上纸按键处理. 根据修改的编程手册调整程序.
	g_tFeedButton 相关程序有待测试.
*	EXTI15_10_IRQHandler()修改. 添加按键有效性检查条件处理. 添加缺纸检查.
*	HexMode()修改. 退出16进制模式时, 清零按键状态变量.
*	CheckFeedButton()修改. 
	正常模式下不是处理宏定义时, 上纸前判断是否可以上纸但是不等待.
	如果可以上纸则上纸, 否则直接退出.
*	ProcessModeType()修改. 
	添加检测模式完成时, 先清空按键结构值. 因为之前检测过按键.
*	Command_1D5E()修改.
	程序执行前先禁用按键, 执行完毕恢复按键之前的定义.
3.*	Command_1B64()修改.
	去掉打印当前缓冲区之前的等待. 无需等待. 参数转换为32位.
	Command_1B69()检查完毕.
4.*	CommandSystemString()修改, 添加"WHSP".
	添加指令集枚举定义. 将程序中指令集定义处全部修改为枚举常量.
5.	Command_1B6B()检查完毕. WH扩充指令.
	Command_1B70()检查完毕. 删除多余注释.
	Command_1B74()检查完毕.
	g_tPrtCtrlData.Line_dir 改为 g_tPrtCtrlData.LineDirection
	更改结构定义及相关地方.
6.	Command_1B7B()检查完毕.
	Command_1B6D()检查完毕.
	Command_1B75()检查完毕.
*	Command_1B76()修改. 添加执行前检查是否是离线状态.
	离线状态下不回发.
7.	测试打印浓度降低.
	单字节指令和1B指令全部检查完毕.


程序版本:0.304
编写人员: 
编写日期:2013-9-13
1.*	Command_1C50()修改.
	添加参数合法性判断.
	添加打印前判断之前的打印任务全部完成.
	GetPrintProcessStatus()添加. 对应返回值宏定义添加.
	待测试.
2.*	Command_1D21()修改. 添加参数最大范围的检查处理.
3.	Command_1D2841()修改. 添加关闭 / 打开通信中断处理.
	HexMode()修改. 添加打开通信中断处理.
	Command_1D2844()修改. 修改变量类型为16位. 修改赋值方式,用指针实现.
	Command_1D2A()修改, 修改赋值方式, 用指针实现.
	Command_1D2F()修改, 指针用完指零.
4.	TypeDef_StructSysCconfig 中 PrintWidth 改为 PrintWidthSelect,
	修改对应处.
	检查打印区域, 左边距, 总打印区域, 最大可打印区域变量赋值.
	g_tPrtCtrlData.PrtRightLimit 无用. 
5.	Command_1D3A()检查.
	Command_1D42()检查.
	Command_1D49()修改. 指针用完指零.
	Command_1D4C()检查.
	Command_1D50()检查.


程序版本:0.305
编写人员: 
编写日期:2013-9-14
1.	Command_1D56()检查.
*	Command_1D57()修改. 添加设置可打印区域不小于一个字符宽度.
	修改可以放下一个字符的计算, 添加调整左边距计算.
*	设置左边距指令需要按照该方式修改.
*	Command_1D4C()修改. 按照以上计算方法修改.
*	Command_1D5E()修改. 修改执行参数判断. 明确判断参数的合法值.
	取宏数据时, 判断条件改为 < 而不用 != 以防止数组非法访问.
*	ReadInBuffer()修改. 取宏数据时, 判断条件改为 < 而不用 != 以防止数组非法访问.
2.	Command_1D61()检查.
*	AutomaticStatusBack()修改. 自动返回时间间隔改为100.
	修改清空内存、默认参数值赋值、最终赋值处理、上传参数计算方法等. 去掉多余注释.
*	WriteFlashParameter()修改. 执行前先禁止ASB返回和实时指令. 指针用完归零.
3.	宏定义 Maintenance_Counter 改为 g_tMaintenanceCounter.
	变量 g_tResetable_Counter 改为 g_tResetableCounter
	g_tCumulate_Counter 改为 g_tCumulateCounter
	g_tResetable_CounterBK 改为 g_tResetableCounterBakeup
	替换相应程序地方.
4.*	Command_1D6730()修改. 添加判断标准模式下在行首才执行该程序.
*	WriteFlashParameter()修改. 添加禁止按键使能处理.
	Command_1D6732()修改. 修改转换值调用方法. 分别赋值, 集中转换.
	Command_1D72()修改. 
	Command_1C21()检查.
	Command_1C26()检查.
	Command_1C2D()检查.
	Command_1C2E()检查.
	Command_1C32()检查. 指针用完指零.
	Command_1C43()检查.
	Command_1C53()检查.
	Command_1C57()检查.
	Command_1D48()检查.
*	Command_1D68()修改. 添加检查参数, 确保高度值不能为0.
	Command_1D6B()检查.
	PrintBar()修改. 修改判断条件, 不影响流程.
	Command_1D77()检查.
	Command_1C70()修改. 修改标准模式且在行首的判断处理.
*	Command_1C71()修改. 添加 ASB状态禁止处理.
	添加X,Y方向参数个数合法范围的检查.
	修改标准模式且在行首的判断处理.
*	Command_1D76()修改. 修改标准模式且在行首的判断处理.
	添加复制加热数据之前等待之前加热完成.
5.	所有指令检查一遍结束,有待测试.


程序版本:0.306
编写人员: 
编写日期:2013-9-14
1.	故意制造切刀位置错误, 切纸过程中报错, LED指示灯工作正确.
	使用手动方式复位切刀后, 发送10 05 01解除可恢复错误.
	10 05 01测试完毕. 测试成功.
2.	测试打印不清晰. 首行浓度高.
	加热时间宏定义各级均减少50. 修改后测试效果更差.
	CopyEditDataToLinePrtStruct()恢复使用复制同时清空的程序. 效果不变.
	可能是打印纸张较差.
	加热时间改为300, 400, 500.
	cStartHeatTimeCompensateTable[] 中各个值修改, 减少. 减少数量.
	修改后自检打印效果基本可以, 字迹散. 首行浅.
	添加加热附加时间宏定义, 调整值. 中等浓度下字迹一致.
3.	Command_1B3D()测试完毕.
4.	加热时间改为400, 500, 600.
	修改后中等浓度打印清晰.


程序版本:0.307
编写人员: 
编写日期:2013-9-16
1.	Command_1B21()修改. 加粗打印对所有字符汉字均有效.
2.	测试顺时针旋转90与倒置打印配合测试,
	还包括下划线1点,汉字字符左间距11右间距13,加重打印
	按照以下顺序变化测试:
	顺时针旋转90	倒置打印	结果
	0				0			OK
	0				1			OK
	1				0			ERROR
	
	顺时针旋转90	倒置打印	结果
	1				0			OK
	1				1			OK
	0				0			OK
	
	顺时针旋转90	倒置打印	结果
	0				0			OK
	1				0			OK
	
	0	1转变为	1	0组合时出现错误.
	单独测试这两条指令, 0	1转变为	1	0组合时OK.
	测试以上组合发现添加 1C 21 80 汉字下划线时出现该错误.
3.	Command_1C2D()修改. 
	设置点数时修改 = 为 |=.
	FillPrintBuff()修改. 
	处理下划线时修改判断条件处理. 便于理解.
	SetLinePrtModeVariable()修改. 
	将下划线最高打印点数赋值放到这里. UnderlineMaxPrtHigh
	WaitToPrintLineBufOfChar()修改. 
	将下划线最高打印点数赋值解除. UnderlineMaxPrtHigh
	CopyEditDataToLinePrtStruct()修改. 全复制和全清除处理.
	复制下划线时同时参考LEB和LPB.
	PrepareNewLine()修改. 修改参数判断条件.
	修改后还出现以上问题.
4.	PrepareNewLine()修改. 添加清除 g_tPrtCtrlData.UnderlineMaxPrtHigh.
	CopyEditDataToLinePrtStruct()修改. 复制下划线数据时分两种情况处理.
	SetLinePrtModeVariable()修改. 添加 UnderlinePrintIndex 的赋值.
	修改后以上打印正常.
5.	CopyEditDataToLinePrtStruct()改用复制同时清除, 非全部清零的程序.
	按照以上进行修改.
	ClearLinePrtBuf()修改. 修改判断条件. 
	添加 UnderlineMaxPrtHigh, UnderlinePrintIndex 清零.
	修改后以上打印正常.
6.	Command_1B2D(), Command_1C2D()修改. 
	修改下划线点数设置时赋值. 由 = 改为 |=.
	下划线2点与1点效果无区别. 有错误.
7.	反显打印时效果不好.
	StartHeatAndRotateMotor()修改.
	字符反显打印时, 原处理为加热时间改为75%. 去掉.
	修改后测试打印效果更差. 几乎走不动.
	加热时间改为50%. 修改后打印流畅但是浓度太浅.
	将浓度设置为100%, 最高速度限制.
	GetMaxAccelerateSteps()修改. 添加反显打印速度限速.
	MAX_RUSH_STEPS_ON_CHAR_NOT_PRT 添加. 
	修改后打印中间停止有白道.
	加热时间暂时设定为75%.
8.	测试自定义汉字与硬汉字库汉字共同打印通过.
	测试各种放大倍数组合测试通过.
9.	Command_1B4A()测试完毕.
10.	缺纸指示灯闪烁错误. 不再提示缺纸. 待修改.


程序版本:0.308
编写人员: 
编写日期:2013-9-17
1.	FlashErrorLed()修改. 
	三种错误下只处理错误指示灯和蜂鸣器,不处理缺纸指示灯.
	缺纸指示灯集中在不执行宏中处理. 
	修改后测试正确.
2.	测试十六进制打印正确.
3.	Command_1D76()测试四种模式, 不同数据量及不同起始位置测试通过.
	测试数据不满宽,满宽,超宽等各种情况测试通过.
4.	Command_1B76()测试. 
	缺纸时进入离线状态,不再回发. 但是恢复有纸后依然不回发.
	SystemTimer2Func()修改. 缺纸时进入离线, 不缺纸时解除离线.
	修改后测试正常.
5.	Command_1C71(),Command_1C70()配合测试通过.
	图形配合放大打印字符在/不在行首测试通过.
	一次定义4幅位图,逐个打印通过.
	Command_1C70()修改.
	调整参数n 和 m 的读取判断顺序. 确保两个参数都被读取再判断.
	一次定义12幅位图,逐个打印通过.
6.	使用工具下载位图及打印位图测试通过.
	全部下载, 同时全部打印. 
	Command_1C50()测试通过.
7.	Command_1B64()测试通过.
8.	Command_1D2A()下载RAM位图及打印RAM位图测试通过.
9.	Command_1D5E()测试.
	测试打印次数执行错误.
10.	Command_1D3A()开始/结束宏定义处理. 按照以下处理修改
	宏定义开始:
	.DefinitionFlag = 1;
	.Number = 0;
	.GetPointer = 0;
	.RunFlag = 0;
	.SetFlag = 0;
	宏定义过程中,每次 ReadInBuffer(),
	if ((g_tMacro.DefinitionFlag == 1) && (g_tMacro.Number < MACRO_SIZE))
		g_tMacro.Buffer[g_tMacro.Number] = GetChar;
		g_tMacro.Number++;
	宏定义结束:
	.DefinitionFlag = 0;
	.Number -= 2;
	.SetFlag = 1;
	
	Command_1D5E()执行宏定义修改. 
	执行前如果正在进行宏定义:
	.DefinitionFlag = 0;
	.Number = 0;
	.GetPointer = 0;
	.RunFlag = 0;
	.SetFlag = 0;
	
	Command_1C71(), Command_1D76()30, Command_1D2841()修改. 
	添加如果执行该指令时正在定义宏, 则停止定义宏, 并清除宏处理.
	
	Command_1D5E()执行宏定义时处理有错误.
	ProcessCharMaskReadBufIlde()修改. 
	修改读数条件, 添加判断g_tMacro.RunFlag.
	修改后测试宏定义执行正确.
	目前宏定义执行时程序执行前先禁用按键, 执行完毕恢复按键之前的定义.
	这样回传的ASB或者其他状态查询指令回传的结果会与实际情况不符.
	有待进一步改进.
	Command_1D5E()修改. 开始执行时不禁止按键, 但是执行结束清空按键.
11.	Command_1C71()目前执行前先禁用按键, 执行完毕恢复按键之前的定义.
	这样回传的ASB或者其他状态查询指令回传的结果会与实际情况不符.
	有待进一步改进.


程序版本:0.309
编写人员: 
编写日期:2013-9-18
1.	测试12*24点阵自定义字符及混合设置打印正常.
	包括选择/取消用户自定义字符,单独禁止某个用户自定义字符,
	纵向横向同时放大,字符右间距,加粗,旋转,下划线,反显,倒置.
	Command_1B3F(),GetAscIIDotData()已测试.
2.	Command_1D57()修改. 
	修改左边距 .PrtLeftLimit 同时立即修改 .PrtDataDotIndex以确保二者一致.
3.	Command_1C3F()添加. 取消用户自定义汉字.
4.	Command_1B45(), Command_1B47()修改. 添加汉字加粗打印的处理.
5.	ConfigOptionFlash()去掉不用.
	直接使用3.5版本的启动文件, 配合升级0.14升级程序后不工作.


程序版本:0.310
编写人员: 
编写日期:2013-9-22
1.	ConfigOptionFlash()恢复.
	MarkLocation()添加 中间标示.
	启动文件按照0.264版本修改.
	__initial_spTop 改为 0x20000800,
	Reset_Handler 实现改为 3.5版本自带, 不初始化外部RAM.
	测试升级后可正常工作.
	CodePageString[] 中CP 替换为PC.


程序版本:0.311
编写人员: 
编写日期:2013-9-30
1.	Command_1B13()修改. 填充完毕先打印再接收多余数据.
	EnableReceiveInterrupt(), DisableReceiveInterrupt()添加. 提高处理效率.
	将程序中ReceiveInterrupt(DISABLE) 替换为 DisableReceiveInterrupt()
	ReceiveInterrupt(ENABLE) 替换为 EnableReceiveInterrupt(),
	修改后使用串口驱动打印会乱码.
2.	串口读数驱动等待时判断缓冲区已有数据大于一定值时就认为缓冲区满.
	startup_stm32f10x_hd.s 修改. 
	去掉Tamper_Detection, 去掉FLASH_If_Erase处理.
	修改后还会打印乱码, 乱码增多.
3.	去掉串口驱动接收延时等待.
	修改后还会打印乱码.


程序版本:0.312
编写人员: 
编写日期:2013-10-10
1.	启动文件修改. 去掉多余的 Reset_Handler, SystemInit_ExtMemCtl 和 PassWord.
	不进行程序校验和检查.
	去掉所有ConfigOptionFlash(),不检查bootload.
	配合boot0.15测试升级成功.
	配合boot0.16测试升级成功.
2.	目前boot和app均未禁用SWJ.	
3.	设置读写保护的处理均在boot中.
	ConfigOptionFlash()删除.


程序版本:0.313
编写人员: 
编写日期:2013-10-13
1.	Command_1B20()修改. 原计算错误, 会丢失精度. 
	先计算, 再判断最大值范围, 最后赋值.
2.	Command_1D4C()修改. 修改计算方法, 原方法错误.
编写日期:2013-10-14
3.	TypeDef_StructPrintMode宏定义修改.
	将左右间距由8位改为16位.
	对应程序处全部检查修改为一致的数据类型.
	TypeDef_StructTab宏定义修改.
	TabNumber 改为 TabSetNumber,
	TabNumIndex 改为 TabIndex,
	TabIndex[] 改为 TabPositionIndex[],
	修改程序中对应位置.
4.	GetCodeBarStr()修改, 添加括号, 去掉不必要的临时变量.
	修改返回值计算. 第一种情况的原返回值包括了NUL在内, 现在返回值不包括NUL.
	修改后UPCE均可正常打印.


程序版本:0.314
编写人员: 
编写日期:2013-10-14~18
1.	检查处理UPCE处理程序.
uint16_t FormatCodeEan13(uint8_t * inbuf)
	EanCheckCode(inbuf, 12)
	uint16_t	EnaFillToBuf((inbuf + 1), 12, Temp, 0)
2.	添加ean.h/.c文件, 处理ean/upc条形码处理.
编写日期:2013-10-18
3.	编写完毕EAN13的编码处理.
	Command_1D6B()修改EAN13的处理. 使用手机测试通过.
	使用扫码枪测试通过.
	当校验码给的正确时, 打印的条码扫描出来也正确.
	当校验码给的错误时, 打印的条码扫描不出来,表现正确.
	

程序版本:0.315
编写人员: 
编写日期:2013-10-18
1.	CalEAN13CheckCode()修改实现. 简化计算.
	测试通过.
2.	继续编写UPCA的编码程序.
	UPCA相当于前置符0的EAN13.
	FormatCodeUPCA()实现. 测试通过.
	目前发送不带校验码的条码HRI字符打印没有居中, 
	应该是打印HRI时字符右间距取值没有处理四舍五入.


程序版本:0.316
编写人员: 
编写日期:2013-10-18
1.	继续编写EAN8的编码程序.
	CalEAN8CheckCode(), SetEAN8CheckCode(),GetEAN8CheckCode(), 
	EAN8ChangeToPrintData(), FormatCodeEAN8()添加.
	CheckPrtSpace()修改, 添加EAN8的处理.
	测试通过.



程序版本:0.317
编写人员: 
编写日期:2013-10-21
1.	继续编写UPCE的编码程序.
	UPCERestoreUPCA(), SetUPCECheckCode(),GetUPCECheckCode(), 
	UPCEChangeToPrintData(), FormatCodeUPCE()添加.
	CheckPrtSpace()修改, 添加UPCE的处理.
	未给出校验码,6位数据,测试通过.
	未给出校验码,7位数据,测试不通过.应该是UPCERestoreUPCA()错误.
	给出正确校验码,8位数据,测试通过.
	给出错误校验码,8位数据,测试通过.
	未给出校验码,11位数据,测试通过.
	给出正确校验码,12位数据,测试通过.
	给出错误校验码,12位数据,测试通过.
2.	UPCERestoreUPCA()修改后未给出校验码,7位数据,测试通过.
3.	Command_1D6B()修改. 
	目前EAN13/EAN8/UPCA/UPCE返回值为实际图形点数宽度,
	其他处理为包括g_tPrtCtrlData.PrtDataDotIndex在内,
	所以需要额外+g_tPrtCtrlData.PrtDataDotIndex.


程序版本:0.318
编写人员: 
编写日期:2013-10-23
1.	PrintStartTile()修改. 变量定义改为条件编译定义.
	版本号和日期改为宏定义然后替换, 具体变量改为局部定义.
	自检中除了VersionString和LanguageString外,其余全部改为局部定义.
	减少内存占用约600字节.
2.	USART1_IRQHandler()修改. 恢复处理校验.
	EnableReceiveInterrupt(), DisableReceiveInterrupt(), 减少判断.
	串口驱动打印无改善.
3.	ReadInBuffer()修改. 
	取消读数修改字节计数时先置忙操作.解除不满判断和清忙.
	串口驱动打印无改善. 修改后IP/USART驱动打印均乱码.
	PaperOutDetect()禁用. 修改后IP/USART驱动打印均乱码.
4.	ReadInBuffer(), PaperOutDetect()恢复修改.
	ETH正常, 串口正常但还是乱码. 
5.	m_tBpsValueTable[], cHeatTimeTable[], cStartHeatTimeCompensateTable[]
	g_tPaperendADValueTable[], g_tBlackmarkADValueTable[], g_tPneADValueTable[]
	g_tTemperatureValueTable[], 全部改为局部变量定义.
	去掉temp.h/.c文件.
6.	SP驱动打印最高速度调整.
	MAX_RUSH_STEPS_ON_SP_DRV_PRT 由 15 改为 30.
	接口全部改为最高速, S 有时有拉开, E 正常.
	MAX_RUSH_STEPS_ON_SP_DRV_PRT 由 30 改为 40.
	MAX_RUSH_STEPS_ON_SP_DRV_PRT_COM 由 30 改为 15.
	其余接口全部改为最高速, S有时有拉开, E 可以正常打印.
	MAX_RUSH_STEPS_ON_SP_DRV_PRT 由 40 改为 50.
	其余接口全部改为最高速, E 可以正常打印, 打印效果变差, 40合适.
	串口 10 合适.
7.	WH驱动打印最高速度调整.
	MAX_RUSH_STEPS_ON_WH_DRV_PRT 由 20 改为 30.
	MAX_RUSH_STEPS_ON_WH_DRV_PRT_COM 为 15.
	其余接口全部改为最高速.
	E 合适, S 打印效果合适, 乱码.
8.	WH驱动串口测试. 硬件握手. 
	以下波特率可以正常打印:	9600, 19200, 38400. 
	57600大部分可以正常打印. 有丢数和乱码.
9.	HEAT_TIME_MIDDLE 由 400 改为 360.
10.	去掉多余的文件.


程序版本:0.319
编写人员: 
编写日期:2013-10-24
1.	ReadInBuffer()修改. 
	SetComInBufBusy() 改为 SetActiveComInBusy()
	DisableReceiveInterrupt() 改为 DisableActiveReceiveInterrupt()
	EnableReceiveInterrupt 改为 EnableActiveReceiveInterrupt()
	ClearComInBufBusy() 改为 ClearActiveComInBusy()
	PaperOutDetect()暂时禁用.
	修改后57600还会出现一次乱码, 打印中间停顿一次.
2.	PutCharToInBuffer()修改. 
	只管保存, 不管是否会覆盖.
	测试发现驱动传递数据确实出现覆盖现象.


程序版本:0.320
编写人员: 
编写日期:2013-10-26
1.	PutCharToInBuffer(), PaperOutDetect()恢复修改. 
2.	Command_1B13()修改, 修改赋值计算, 实际处理效果相同.
3.	WH串口驱动打印最高速度改为10.
	中等浓度加热时间由360恢复为400.
	修改并口SP驱动打印限速30, WH驱动打印限速15,均匹配合适.


程序版本:0.321
编写人员: 
编写日期:2013-11-11
1.	根据迅普SO-OH32编程手册比较各个指令,待添加指令:
	1B 2B n			微打中作为允许/禁止上划线打印,无
	1B 55 n			微打中作为设置字符宽度放大n倍,已有,使用含义不同,POS为双向打印.修改为只修改字符.已修改完成.
	1B 56 n			微打中作为设置字符高度放大n倍,已有,使用含义不同,POS为旋转90度.修改为只修改字符.已修改完成.
	1B 57	n			微打中作为设置字符横向纵向放大n倍,已有,使用含义不同,目前为汉字字符同时生效.已修改完成.
	1B 58 n1 n2	微打中作为设置字符横向放大n1倍,纵向放大n2倍,无.已添加完成.
	1B 66 m n		微打中作为打印空格或空行,无.已添加完成.
	1B 6C	n			微打中作为设置左边距,无.已添加完成.
	1B 51	n			微打中作为设置右边距,无
	1C 55	n			微打中作为设置汉字横向放大n倍,无.已添加完成.
	1C 56	n			微打中作为设置汉字纵向放大n倍,无.已添加完成.
	1C 57	n			微打中作为设置汉字横向纵向放大n倍,已有,使用含义有扩展,参数范围扩大,可以兼容.已修改完成.
	1C 58 n1 n2	微打中作为设置汉字横向放大n1倍,纵向放大n2倍,无.已添加完成.
	1B 27				微打中作为打印曲线指令,无
	10 04 n			已有,参数含义待比较
	1D 61 n			已有,参数含义待比较
	1B 69				已有,此次要求作为切刀指令,POS中作为半切.与微打指令1B 69 n 允许/禁止反白打印冲突.
	18					清除打印缓冲区,无,使用含义不同,POS为页模式下清除打印数据
	1B 22 n			微打中作为允许/禁止16进制打印,无

编写日期:2013-11-12
2.	0.320版本程序在使用P05测试电源反显打印或者放大8倍打印时,会出现走纸不畅,
	尤其是在开始的前数十行打印经常停止.造成拉伸或者白道.
	使用P04电源测试任何组合打印均无任何问题.
	GetHeatTime()修改. 反显或者放大或者行间距0时,去除起始行额外加热处理.
	测试效果还是不理想.去除修改.
	改为使用1步1点行,效果有改进但是还是不理想.
3.	Command_1B57()修改.1B 57 n指令修改.只改变字符放大倍数,不改变汉字放大倍数.
	Command_1C57()修改.微打中作为设置汉字横向纵向放大n倍.
	Command_1B58()添加.1B 58 n1 n2	微打中作为设置字符横向放大n1倍,纵向放大n2倍,
	Command_1C58()添加.1C 58 n1 n2	微打中作为设置汉字横向放大n1倍,纵向放大n2倍,
	Command_1C55()添加.1C 55	n			微打中作为设置汉字横向放大n倍,
	Command_1C56()添加.1C 56	n			微打中作为设置汉字纵向放大n倍,
	Command_1B66()添加.1B 66 m n		微打中作为打印空格或空行,
	Command_1B6C()添加.1B 6C	n			微打中作为设置左边距,
4.	设置完字符和汉字的纵向放大倍数时,是否应该执行以下语句待检查.
	if (g_tPrtCtrlData.MaxRatioY < g_tPrtModeChar.HeightMagnification)
		g_tPrtCtrlData.MaxRatioY = g_tPrtModeChar.HeightMagnification;
	Command_1B56()修改.去除以上语句.
5.	Command_1B51()待添加.以下功能指令待添加.
	1B 51	n			微打中作为设置右边距,
	1B 2B n			微打中作为允许/禁止上划线打印,无
	1B 27				微打中作为打印曲线指令,无
	18					清除打印缓冲区,无,使用含义不同,POS为页模式下清除打印数据
	1B 22 n			微打中作为允许/禁止16进制打印,无
	

程序版本:0.322
编写人员: 
编写日期:2013-11-25
为P05新电源打印效果不佳而修改.
1.	GetMaxAccelerateStepsOfDifferentMagnification()修改.
	修改判断条件. 修改后测试P05使用新电源打印效果无改善.
	MAX_RUSH_STEPS_ON_DIFFERENT_MAGNIFICATION_PRT修改. 由80改为40.
	修改后不反显放大打印不再停顿. 反显打印全部停顿.
	MAX_RUSH_STEPS_ON_CHAR_NOT_PRT修改. 由20改为10.
	修改后反显打印有改善.但开始还是会停顿.
	FEED_START_US,FEED_STOP_US修改. 由10000改为20000.
	修改后反显打印无改善.
	改为40000.修改后反显打印无改善.
	将各项参数全部恢复,用P04测试完全OK.
2.	以下宏改为条件编译.
	MAX_RUSH_STEPS_ON_DIFFERENT_MAGNIFICATION_PRT修改. 由80改为40.
	MAX_RUSH_STEPS_ON_CHAR_NOT_PRT修改. 由20改为5.
	修改后P05打印基本不再出现异常.


程序版本:0.323
编写人员: 
编写日期:2013-12-19
1.	g_tMaintenanceCounter 类型定义改为 TypeDef_StructMaintenanceCounter,
	TypeDef_StructSysCconfig 名称改为 TypeDef_StructSysConfig,
	TypeDef_StructSysConfig 中 COM_BaudRate 改为 ComBaudRate,
		COM_Protocol 改为 ComProtocol,
		SYS_ShdnMode 改为 SysShutDownMode,
		CR_Enable 改为 CREnable,
		CfgFlag 改为 ConfigFlag,
	TypeDef_UnionSysConfig 中 Sys_Para_Buff 改为 bSysParaBuf,
	TypeDef_StructSystemCtrl 中 ShutDownCnt 改为 ShutDownCounter,
	TypeDef_StructStatus 中 ErrStatus 改为 ErrorStatus,
	g_cDbg025EnalbeFlag 改为 g_bDbg025EnalbeFlag,
	g_cDbg025FontFlag 改为 g_bDbg025FontFlag,
	DBG_PROCESS_TIME_EDIT_COUNT_WHILE_PRT 时需要处理的变量改为 b.
	替换对应处.
2.	pc开头的指针全部 改为 pb开头的指针.
	cBuf开头的变量全部 改为 bBuf开头的变量.
	Buff结尾定义的数组全部 改为 Buf结尾定义的数组.
	g_bRxFinishFlag 改为条件编译,放到需要的文件中.
	接口类型和命令集类型定义添加显示名称.
	TypeDef_StructDrawer成员调整定义先后顺序.
	以上所有的修改只影响程序的阅读,不应该影响程序执行逻辑等.
3.	AUTO_FEED_AFTER_CUT_ENABLE 关闭.
	目前切刀程序中如果切纸执行完毕会自动上纸8mm.
	CUT_OFFSET 由 21 改为 13.
	NO_CUT_OFFSET 由 24 改为 17.
	FEED_PAPER_MM_AFTER_CUT 由 8 改为 2.
4.	HEAT_TIME_LOW/M/H 当前为300, 400, 500;
	改为350,450,550.


程序版本:0.324
编写人员: 
编写日期:2014-5-26
1.	修改WH驱动打印处理.
	PrepareNewLine()修改, 当并行处理模式时, 如果为WH驱动打印模式, 则添加等待打印结束判断.
	g_tPrtCtrlData.PCDriverMode 赋值为 NONE.
	Command_1B13()修改, 直接编辑, 不判断是否需要先打印再填充处理.	


程序版本:0.325
编写人员: 
编写日期:2014-11-19
1.	custom.h  添加.
	添加加厚彩票纸打印的特殊种类.
	CUSTOM_LOTTERY_PAPER_ENABLE 添加.
	#ifdef	CUSTOM_LOTTERY_PAPER_ENABLE
		
	#else
		
	#endif
2.	heat.h 中相关加热时间宏定义修改, 改为条件编译.
	HEAT_TIME_MIDDLE / MAX_HEAT_TIME 修改.
	2000/6000	N
	feedpaper.h 中相关上纸加速步数宏定义修改, 改为条件编译.
	feedpaper.c 中相关上纸时间宏定义修改, 改为条件编译.
	selftest.c 中修改版本号. 改为条件编译.
编写日期:2014-12-5
3.	加热时间宏定义修改, 中等浓度6000即可清晰打印.


程序版本:0.326
编写人员: 
编写日期:2014-12-8
1.	Command_1B40(),Command_1D2841()修改. 
	InitParameter()执行前先等待当前打印处理完毕再初始化.
	InitParameter()修改. 打印缓冲区内容改为必须初始化, 无需判断是否是指令还是上电初始化.
2.	Command_09()原处理有错误.少统计了跳格次数. 超过设置的跳格次数则忽略.
3.	PrepareNewLine()修改. 跳格次数不能清零.
	修改后跳格设置处理正常.	
4.	ASB自动回复的时间间隔由1ms改为1s.
	ASB_INTERVAL_MS 由100 改为 1000.
5.	SystemSelfTest()修改, 添加清除按键参数.
6.	十六进制打印会出现错误.
	PrintString()修改. 其中有逻辑冲突的地方. 会造成丢掉字符.
7.	GetInBufBytesNumber()添加.
	HexMode()修改. 替换对应位置.
	修改处理方式, 改为打印前后提示信息及填充信息放到独立函数中.
	修改退出时对剩余数据的打印, 确保没有数据丢失.
	以上修改待测试.


程序版本:0.327
编写人员: 
编写日期:2014-12-9
1.	测黑标, 测纸传感器灵敏度值宏定义修改.
	白纸时, PE 小于0.3V
	黑标和胶辊时, PE 约为2.2V
	全空白式, PE 约为3.2V
2.	UpdatePaperStatusByADCResult(), UpdateBlackMarkStatusByADCResult(), 
	UpdatePaperNearEndStatusByADCResult(),UpdateTemperatureStatusByADCResult(),
	UpdatePowerStatusByADCResult(),	UpdatePaperAndBlackMarkStatusByADCResult() 添加.
	UpdateErrorStatusByADCResult()修改, 调整测纸传感器和黑标位置的判断.
	共用测纸和黑标传感器时, 黑标模式下只能确定黑标状态, 无法同时确定纸状态,
	只能通过其他方式确定.
	黑标模式下除了检测黑标外, 也清除缺纸信号. 否则如果开始缺纸或者没有找到黑标, 
	可能表现缺纸一直不打印.
3.	FindBlackMarkSensorIndependent(), FindBlackMarkSensorShared(),
	JudgeBlackMarkPosition() 添加.
	FindMarkPoint()修改, 调整找黑标的处理. 	
	FindBlackMarkSensorShared()有可能需要修改. 
	如果打印内容太少, 还处在黑标位置处, 则0C指令时会又回到该黑标处.
4.	0x0C  打印缓冲器内容并定位黑标功能已有.
	待测试黑标相关功能.


程序版本:0.328
编写人员: 
编写日期:2014-12-10
1.	添加57mm纸宽宏定义CUSTOM_57MM_PRT_DOT_NUMBERS.
	InitSystemCtrlStructParameter()修改, 将特制版本的纸宽设置为57mm.
	g_ctSysDefaultValue()修改, 将特制版本的纸宽设置为57mm.
	PrintPaperWidthSet()修改, 将特制版本的纸宽设置为57mm.
编写日期:2014-12-16
2.	增加加热时间, 调整相关宏定义, 调整电机加速时间表和相关宏定义.
	添加自检特殊编号, 修改默认参数为黑标.

